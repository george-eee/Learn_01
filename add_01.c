#define _CRT_SECURE_NO_WARNINGS//VS中使用scanf函数必备宏定义 scanf_s为VS专属
#include <stdio.h>
#include <string.h>


//hello world!
//int main()
//{
//	printf("hello world!\n\n");
//
//
//	return 0;
//
//}


//C语言的基本数据类型：
// char				字符型
// short			短整型	  【整
// int				整型
// long				长整型
// long long		更长的整型	型】
// float			单精度浮点数【实型
// double			双精度浮点数  即浮点型】
// void				无值型（空值型）


//C语言各基本数据类型的大小：
//int main()
//{
//	 printf("%zu\n", sizeof(char));		1
//	 printf("%zu\n", sizeof(short));	2
//	 printf("%zu\n", sizeof(int));		4
//	 printf("%zu\n", sizeof(long));		4
//	 printf("%zu\n", sizeof(long long));8
//	 printf("%zu\n", sizeof(float));	4
//	 printf("%zu\n", sizeof(double));	8
//	 printf("%zu\n", sizeof(void));		0
//
//	 return 0;
//}


//全局变量和局部变量同时出现时：
// int main()
//{
//	int a = 10;
//	void iu();
//	{
//		int a = 1;
//		printf("iu-->%d\n", a);
//	}
//	return 0;
//} //变量的赋值遵循就近原则----局部优先级高于全局


//全局变量和局部变量的作用域
//int main()
//{
//	void u();
//	{
//		int a = 1;
//		printf("u-->%d\n", a);
//
//	}
//	int a = 2;
//	printf("%d\n", a);
//
//
//	return 0;
//}


//常量之 数值常量
//int main()
//{
//	int a = 10;
//	printf("%d\n", a);
//	return 0;
//} 这种常量又称为字面常量


//常量之由 const 定义的常变量：
//int main(void)
//{
//	printf("hello world!\n\n");
//
//
//	return 0;
//
//}
//int main()
//{
//	const int a = 20;//const修饰导致a变为常变量
//	printf("%d\n",a);
//
//	return 0;
//}


//常量之由 #define 定义的标识符常量：
//#define max 100//此处 max 为define定义的标志符常量
//#define iu "abcdef"//此处两个宏定义都没有规定 形 可见后面被定义的内容不定
//int main()
//{
//	printf("%d\n", max);
//	int a = max;
//	printf("%d\n", a);//可见其可当作常量来使用
//	printf("%s\n", iu);//%s s:string 即打印字符串
//
//	return 0;
//
//
//}


//常量之 枚举常量
//enum Color
//{
//	RED,【枚举
//	GREEN,
//	BLUE  常量】
//}					   //R G B作为枚举类型Color的三种可能取值,这些可能取值便是枚举常量
//int main()
//{
//	int num = 10;
//	enum Color c = RED;//此处为对变量c的赋值操作 而赋的值便是枚举常量之一
//	int RED = 20;//容易发现，无法再次对枚举常量进行赋值或是更改操作
//	return 0;
//}


//基础求和程序
//int main()
//{
//	int num1 = 0;
//	int num2 = 0;
//	scanf("%d %d", &num1, &num2);// & 为取地址符 即获取已定义变量在内存中的位置 注意:此处为空格分隔:有时为逗号分隔！
//	int sum = num1 + num2;
//	printf("%d\n", sum);
//	return 0;
//
//
//}


//语句末尾勿忘  ； ！
//


/* 
关于数组以及数组内字符串长度的计算规则：
#include <string.h>;//strlen可计算字符串长度 但是需要此头文件！
int main() //F10+调试+窗口+监视 可进行查看程序在内存中的存取等操作
{
	char arr1[] = "abc";//char[4]
	char arr2[] = { 'a','b','c' };//char[3]
	char arr3[] = { 'a','b','c','\0' };//char[4]
	char arr4[4] = { 'a','b','c' };//char[4]  此处为不完全初始化数组
	//这说明 \0 仅在读取字符串时出现  是意为字符串读取到此为止的转义字符  而若读取单个字符形式的组合则无需\0 故内存占位将少一个字节
	//可是注意！在 printf函数中打印截至到\0为止 若无\0 则将出现错误:
	printf("%s\n", arr1);
	printf("%s\n", arr2);//报错
	printf("%s\n", arr3);//正常
	printf("%s\n", arr4);//输出为"abc"  此处为不完全初始化数组的打印结果

	printf("%d\n", strlen(arr1));//字符串长度为3
	printf("%d\n", strlen(arr2));//字符串长度为35
	printf("%d\n", strlen(arr3));//字符串长度为3
	printf("%d\n", strlen(arr4));//字符串长度为3  此处为不完全初始化数组的字符串长度计算结果
	//关于不完全初始化：若数组中的元素数目未达到定义数组的数目，则编译器会自动将未初始化的元素赋值为0；
	//0--数字零  即数值为0（不因编码方式而变化）
	//"0"--字符零  ASCII码值为48
	//"\0"--转义字符零  ASCII码值为0
	//可见 "\0"与被赋值的0（数字0）对于计算机而言是几乎等效的


	//这说明 \0占内存但不计入字符长度                       补充 拉丁字母长度为一字节  汉字长度至少为二字节
	 
	          //                                                        补充 常用打印类型有：
             //                                           %d        整型              
			//										      %s        字符串
		   //											  %c        字符型
		  //											  %f        float型
		 //												  %lf       double型
	    //												  %zu       size of类型的返回值
	   //												  %p		以地址型打印(打印出对应地址)
	return 0;


} */


//打印的标准模式：
//printf ("%...\n",",,,");
// 
// printf("%...\n"); 为字符串专属简写    建议统一写成标准模式；


//转义字符					释义
//\?							在书写连续多个问号时使用，防止他们被解析为三字母词
//\'							用于表示字符常量'
//\"							用于表示一个字符串内部的双引号
//\\							用于表示一个反斜杠，防止它被解释为一个转义序列符
//\a							警告字符，蜂鸣
//\b							退格符
//\f							进纸符
//\n							换行
//\r							回车
//\t							水平制表符  效果类似于 Tab
//\v							垂直制表符
//\ddd						    ddd表示一到三个八进制数字  编译器会将其转换为十进制后对应ASCII信息交换表里的字符后输出
//\xdd						    dd表示两个十六进制数字     同上
//\0							字符串的结束符
//备注：转义字符看似占多个字节 实则不然 均仅占位一个字节 为一个字符  如\t看似可打印出四个空格 实则是为单字符  示例如下


//存在转义字符的字符串长度计算
//int main()
//{
//	printf("%d\n", strlen("\ta"));   //长度为2
//	printf("%d\n", strlen("\x22 b"));//长度为3    注意 " "空格（占位符）也占了一个字节长度 
//
//	/*此处常见错误示范之-- > 试问下列字符串长度？*/
//    printf("%d\n", strlen("c:\test\628\test.c"));//长度为十四  易误以为是十三
//	printf("%d\n", strlen("abc\666"));//长度无法计算  易误以为是四
//	此处涉及到两个关于进制转义字符的常见错误 
//	1 前者\628 欲取八进制 但第三位却超过了8 故编译器自动判定为\62 而8则作为一个字符 这为错误一；
//	2 后者\666 欲取八进制 但换算为十进制后过大 超出了127 故无法在ASCII表中找到对应字符 故无法计算字符串长度 这位错误二；
//
//	return 0;
//} 


//注释
//C语言注释风格 /* */		不可嵌套 就近原则
//C++语言风格注释 //		可嵌套


//常见选择语句				常见循环语句
//1_ if  else                 while循环
//2_ switch                   for循环
//3_                          do...while循环


//if 语句示例
//int main()
//{
//	int a = 0;
//	printf("%s\n", "你想成为程序员大牛吗？");
//	printf("%s\n", "请选择1/0");
//	scanf("%d", &a);
//	if (a == 1)
//	{
//		printf("%s", "那就继续加油吧!");
//
//	}
//	else
//	{
//
//		printf("%s", "请不要忘记你为何开始！\n请选择1");
//	}
//
//	return 0;
//}
//"="表示赋值操作		"=="则表示判断或者比较两个值是否相等，是一种关系运算符


//while 语句示例
//int main()
//{
//	int line = 0;
//	printf("%s\n", "努力学习计算机知识");
//	while (line < 20000)
//	{
//		printf("练习敲代码:%d", line);
//		line++;
//
//		if (line >= 20000)										//常用技巧之--在打出函数名后按"Tab"键可快速生成{ }大括号;
//		{
//			printf("%s\n", "学习永不停止！");
//		}
//		else
//		{
//			printf("%s\n", "继续练习！");
//		}
//	}
//	return 0;
//}


//hhhhhhhhhhhhhhhhhhhhhh 是时候强调这件事情了少年！！！！！！
//没错！！！
//你个傻卵儿老是中英文字符搞混了还看不出来！！！ tmd报错的时候就使劲难受吧！
//尤其是这个 中文的"；" 和 英文的";"
//汗流浃背了吧老弟hhhhhhhhhhh
//其实关键就在于...字符所占的长度不同***
//仔细观察吧少年   line++


//C语言结构类型:
//1_顺序结构
//2_选择结构（分支结构）
//3_循环结构


//数组基础
//int main()
//{
//	int sss[3] = { 1,2,3 };
//	有序排列的同类数据元素的集合称为数组  (存储作用)
//				   0 1 2
//	为区分数组的各个元素 各分量对应着其数字编号 即下标 下标默认从零开始 如上;
//	printf("%d\n", sss[2]);
//	"[]"内自动识别为下标 而不是数字本身 若超出下标范围则输出错误，并且其中只能是常量不能是变量（VS不支持变长数组所致）；
//  事实上C99标准之前，数组的大小都是用常量或者常量表达式来指定的
//  而C99之后支持了变长数组，允许数组的大小是变量，但这种指定方式的数组是不能初始化的；
//  数组的初始化：int sss[3]={1,2,3};		不初始化：int sss[3];
//	return 0;
//}


//数组基础...
//int main()
//{
//	int ddd[7] = { 1,2,3,4,5,6,7};
//	int i = 0;
//	while (i <3)
//	{
//		i = i + 1;
//		printf("%d\n", ddd[i]);
//		i = i + 1;
//	}
//	关于循环的小知识：while用于判断是否进行下一次循环；但是语句本身会继续跑下去，只是可能不会再循环下一次了
//	这也是为何此处i++在下时能输出到三   
//	同时请注意i++在上和在下对输出结果的影响是不同的！
//	return 0;
//
//}


//比大小并输出的两种写法--1 直接型
//int main()
//{
//	int a = 0;
//	int b = 0;
//	scanf("%d %d", &a, &b);
//	if (a>b)
//	{
//		printf("%d\n", a);
//
//	}
//	else
//	{
//		printf("%d\n", b);
//	}
//	return 0;
//}

//比大小并输出的两种写法--2 间接型
//int Max(int x, int y)
//{
//	if(x>y)
//		return x;
//	else
//		return y;
//}
//int main()
//{
//	int a = 0;
//	int b = 0;
//	scanf("%d %d", &a, &b);
//	int c=Max(a, b);
//	printf("%d\n", c);
//	return 0;
//}


//错误示例之 if语句中 的return后返回值必须为常量；
//int Change(int z)
//{
//	if (z > 0)
//	{
//		return -1;
//	}
//
//	else
//	{
//		return 0;
//	}
//
//}


//求一个函数 使得 当x>0时输出-1；当x<0时输出1；当x=0时输出0；
//int change(int a)
//{
//	if (a<0)
//	{
//		return 1;
//	}
//	else if (a==0)//注意 =是赋值   ==是判断等号两边是否相等；
//	{
//		return 0;
//	}
//	else
//	{
//		return -1;
//	}
//
//}
//
//int main()
//{
//	int a = 0;
//	scanf("%d", &a);
//	int b = change(a);
//	printf("%d", b);
//	return 0;
//}


//操作符
//算术操作符：
//=  -  *  /  %
//加 减 乘 除 取模
//除
//int main()
//{
//	int a = 7/2;
//	printf("%d\n", a);
//	//结果为3；这是因为当a b 同为整数时  计算机进行的是整数除法；而只有当其中至少有一个浮点数时才会进行浮点数除法！！！！！；
//	float a = 7/2;
//	printf("%f\n", a);
//	//更改打印形式后发现；输出错误；这说明除法种类会影响打印结果；
//	int a = 7/2.0;
//	printf("%d\n", a);
//	//仅更改除法种类后发现 仍然打印不出浮点数结果；可见二者缺一不可！！！；
//	float a = 7/2.0;
//	printf("%f\n", a);
//	float a = 7.0/ 2;
//	printf("%.1f\n", a);
//	//若要保留到浮点后几位  可如上操作 保留一位为.1 两位...
//	float a = -7 / 2.0;
//	printf("%.1f\n", a);
//	//可见该操作符适用于含有负数的操作
//	return 0;
//}
//取模
//int main()
//{
	//int b = 7 % 2;
	//printf("%d\n", b);
	//取模操作符意为取余数 且该操作符两端仅能为整数 
	//int b = -7 % 2;
	//printf("%d\n", b);
	//可见该操作符能进行含负数的操作
	//return 0;
//}


//赋值操作符
//=	+=	-=	*=	/=	%=	&=	^=	|=	>>=	<<=
//int main()
//{
//	int a = 0;
//	a = 10;
//	a = a + 1;
//	printf("%d\n", a);
//	int a = 0;
//	a = 10;
//	a += 1;
//	printf("%d\n", a);//上下二者等效  即a+=便是a=a+...	类比可知后面的操作符的含义；
//	return 0;
//}


//双目操作符：需要两个操作数的操作符，如+ - * /等；
//单目操作符；仅需要一个操作数的操作符，相关如下：
//逻辑反操作符：
//首先！C语言中规定 变量值为零则为假 其余则为真
//int main()
//{
//	int a = 0;
//	if (a)//if (ture)
//	{
//		printf("%s\n", "hehe");
//	}
//	int a = 0;
//	if (!a)
//	{
//		printf("%s\n", "hehe");
//	}
//	可见逻辑反操作符可改变C语言中逻辑的真假判断，从而影响输出结果；
//	return 0;
//}
//负值-以及正值+：
//int main()
//{
//	int a = 10;
//	int b = -a;
//	int c = +a;
//	printf("%d\n", b);//-意为取值为负
//	printf("%d\n", c);//+意为+() 意义不大
//	return 0;
//}
//sizeof 操作符：
//注意！！！size of 是单目操作符 不是函数；
//int main()
//{
//	int a = 0;
//	printf("%d\n", sizeof(a));//4
//	printf("%d\n", sizeof(int));//注意 若为此写法 则无法取去括号来写；
//	printf("%d\n", sizeof a);//省略a的括号后结果仍然计算正确 可见其不是函数(是函数则不能去除a的括号，否则报错)
//	return 0;
//}
//int main()
//{
//	int ass[10] = { 0 };//后续自动不完全初始化为数值0；
//	printf("%d\n", sizeof ass);//40;可见sizeof 计算的是整个数组的大小 单位为字节;  注意\0 是在字符串中出现！而非此处的(整型)数组
//	printf("%d\n", sizeof ass[0]);//4 []内的数字对应下标 数组下标从零开始 [0]代表第一个数组内的元素；
//	printf("%d\n", sizeof ass / sizeof ass[0]);//10 可如此求出数组内元素的个数
//	return 0;
//}
//前后置++ --
//int main()
//{
//	int a = 10;
//	int b = a++;//此处为后置++ 即++操作在欲++的变量之后 后置++遵循先使用 后++的原则!
//	printf("%d\n", a);//11
//	printf("%d\n", b);//10
//	//int c = d++;//注意 此处这种先使用标识符 再定义的方式是错误的! 并不是前置++！
//	int d = 20;
//	int e = ++d;//这才是正确的前置++的写法 遵循先++后使用的原则！
//	printf("%d\n", d);//21
//	printf("%d\n", e);//21
//	return 0;
//}
//-- 原理等同
//(类型) 强制类型转换
//int main()
//{
//	int a = 3.1;
//	printf("%d\n", a);// 3 “初始化”: 从“double”转换到“int”，可能丢失数据 
//	//由此看出 1-哪怕赋值为浮点数 编译器仍按整型输出 且程序依然能跑；2-哪怕赋值为一位 编译时也默认按double型转换为int型
//	//为何为最终仍然为int? 因为最开始定义变量时在内存中获取的是int型的存储位置 故哪怕赋值为浮点数 仍然会被转化为整型
//	int b = (int)2.1;//(类型)可以强制转换其类型 此处 double-->int
//	printf("%d\n", b);//不再报这个错误：“初始化”: 从“double”转换到“int”，可能丢失数据
//	return 0;
//}


//关系操作符
// > < = <= >=		!=				==
//				用于测试不等于  用于测试等于
//着重！== 判断两端是否相等 
//int main()
//{
//	int a = 0;
//	if (a=1)//if语句()括号内会判断是否为真	a初始化为0 本为假 但是当赋值a=1后为真 故打印成功
//	{
//		printf("hehe\n");
//	}
//	return 0;
//}
//int main()
//{
//	int a = 0;
//	if(a==1)//a赋值为零 ==测试不等于1 故判断为假 打印失败
//	{
//		printf("hehe\n");
//	}
//	return 0;
//}


//逻辑操作符
//&& 逻辑与-并且...
//|| 逻辑或-或者...


//三目操作符（条件操作符）
//int main()
//{
//	int a = 1;
//	int b = 2;
//	int c = (a > b ? a : b);//条件操作符的示例：exp1 ? exp2 : exp3
//	int d = (a < b ? a : b);//			第一表达式是在进行判断；若一为真 则该操作符输出结果为就近原则 输出二；反之输出三
//	printf("%d\n", d);
//	printf("%d\n", c);
//	return 0;
//}


//逗号表达式
//特点：从左向右 依次计算 取最后表达式的结果为整个表达式的结果；
//int main()
//{
//	int a = 1;
//	int b = 2;
//	int c = (a + b, a * b, a - b);
//	printf("%d\n", c);//值为-1 满足特点；
//	return 0;
//}


//下标引用操作符
//[]是下标引用符 arr 和 3 是[]的操作数
//int main()
//{
//	int arr[10] = { 1,2,3,4,5,6,7,8,8,10 };
//	printf("%d\n", arr[3]);//4
//	printf("%d\n", 3[arr]);//4 可见[]对操作数的处理是一视同仁的
//	int n = 3;
//	printf("%d\n", arr[n]);//4 可见在[]利用下标引用已定义数组中的参数时 []中可以为变量 但是定义数组时[]中不能有变量
//	return 0;
//}
// 
// 
// 函数调用操作符：（） 括号不可省 且括号内外均为该操作符的操作数！


//关键字：C语言本身内置的 而非编写者可以自创的： 编写者定义变量名时也不可以用关键字来命名
//举例一：auto  auto一般被省略掉	define不是关键字！！！
//当定义局部变量时 进入局部变量的作用域时，局部变量自动开始生效；处作用域时自动失效 这便是 auto的作用效果：自动


//变量的命名
//1_应当有实际意义 并且编写者能看懂
//2_名字必须是字母 数字 下划线 组成 不能有特殊字符 不能以数字开头
//3_不能是关键字


//typedef:对类型重命名
//typedef unsigned int uit;//将无符号整型重命名为 uit;
//int main()
//{
//	uit a = 1;
//	int b = 1;
//	printf("%d\n", a);//1
//	printf("%d\n", b);//1
//	//两者打印结果相同；可见被typedef重命名之后的类型与命名前等效 只是更改了写法
//	return 0;
//}
////有时重命名 形如下所示
//typedef struct Node
//{
//	int data;
//	struct Node* next;
//}stde;//此时对于结构体类型 struct Node重命名为stde 此两种仅为不同情况下的写法；


//void test()
//{
//	//int a = 1;//结果：2，2，2...
//	static int a = 1;//结果：2，3，4...
//	a++; 
//	printf("%d\n", a);//为何先使用后加加打印结果为2？因为在a++的a之前并无使用a的地方 而语句从左往右继续执行 故到打印时已加一
//}
//int main()
//{
//	int i = 0;
//	while (i<10)//i为循环次数
//	{
//		test();
//		i++;
//	}
//	return 0;//为何循环打印出来是十个2 而不是2，3...？
//			 //这是因为建立函数test时 其中设置的变量a为局部变量 具有生命周期 每次进入作用域时都重新开始了
//}
//关于 static：
//1_使用static声明的变量是静态变量 初始值为0，其作用域被限制在其被定义的源文件中 生命周期为整个程序开始到结束;
//1-1 static修饰局部变量的时候改变了局部变量的存储位置 从内存的栈区改为了静态区 即原先的局部变量改变为静态(局部)变量了;
//1-2 static修饰全局变量的时候改变了其 外部链接属性-->内部链接属性 此工程的其他源文件便不能再使用这个全局变量了；
//2_使用static声明的函数是静态函数 作用域被限制在其被定义的源文件中 其不能被其他文件中的函数调用；
// 注意：函数本来也有外部链接属性的 若要调用具有该属性的函数或全局变量 只需在其前面加上 extern即可！
//3_使用static声明的代码块是静态代码块 其只会在第一次被使用时执行一次 之后不会再次执行.


//关于内存的分区:
//1_栈区(static) :存放局部变量(包括const定义的局部变量) 形参 返回值;先入后出	由编译器自动分配释放
//2_堆区(heap) : 调用函数 : malloc()和free();									由程序员分配内存和释放
//3_全局(静态)区(分为 .bass 以及 .data) :存放全局变量和静态变量;
//4_常量区(.rodata) :存放字符串 数字等常量以及const修饰的全局变量;
//5_代码区(.text):存放程序的执行代码 也可能有字符串常量和define定义的常量存放.


//计算机存储体系：
//1_寄存器(集成到CPU上)
//2_高速缓存(cache)
//3_内存
//4_硬盘
//越往上，与CPU交换信息的速度越快，空间越小，造价越高； 实际使用时信息会有自下往上的信息传递；
//关键字register:(寄存器)
//int main()
//{
//	register int a = 1;//register意为 建议将该变量的位置存放在寄存器中使其读写和运行速度更快 但只能是建议！
//	printf("%d\n", a);
//	return 0;
//}


//#define 不仅可以定义标识符常量 还可定义宏
//#define ADD(x,y) ((x)+(y))
//ADD为宏名 宏是宏 而函数是函数
//(x,y)中的x,y为宏的参数，参数是无类型；
//而((x)+(y))为宏体
//需要知道的是 宏是完成替换的 当下文ADD返回参数给宏时 宏自动给对应参数完成替换 如：
//int c = ADD(a, b)-- > int c = ((a)+(b));
//int main()
//{
//	int a = 10;
//	int b = 20;
//	int c = ADD(a, b);
//	printf("%d\n", c);
//	return 0;
//}


//指针***
//1_内存
//首先：计算机中程序的运行都是在内存中运行的
//为提升内存的使用效率 内存被划分成一个个小的内存单元(类似于excel表格形式) 每个内存单元的大小是一个Byte
//同时每个内存单元有自己的编号 称为该内存单元的地址 地址为便于编号采用16进制数表示(只是一种数据表示方式)
//补充 在计算机内部二进制数据转换为16进制数据最直接 最快捷 占用存储空间最小；
//在32位电脑中 可能的内存地址(寻址空间)数有2^32次方个 换算如下：(地址为32bit位 二进制 故有2^32次方种可能)
//2^32=4294967296Byte
//	=4194304Kb
//	=4096Mb
//	=4Gb 即4Gb个
//而在64位电脑中 可能的内存地址达到了惊人的16384Pb个 但受实例的限制 目前windows仅能支持达到512Gb的内存
//换算关系:
//8 bit =1Byte
//1024 Byte=1Kb
//1024 Kb=1Mb
//1024 Mb=1Gb
//1024 Gb=1Tb
//1024 Tb=1Pb


//2_查看内存地址
//int main()
//{
//	int a = 10;//向内存申请4个字节，用于存储10; 但实际上哪怕变量a要了四个字节单位 a仍然是放在第一个字节单位中;
//	printf("%p\n", &a);//0x 0000 00C5 D28F FC74 这便是内存地址之一(第一个字节的)(随机)	0x表示这个数据是16进制表示的
//	printf("%p\n", a);//000000000000000A	 而这是内存中的数据(16进制的 10) 
//	return 0;
//}
//也可直接查看内存地址调用等信息:F10+调试到末行+调试+窗口+内存+&a即可
//如上操作结果左侧为内存地址 中间为内存中的数据 右边为不准确的内存数据的文本解析


//查看字符类型的ascii码值：
//int main()
//{
//	char a = 0;
//	scanf("%c",&a);
//	printf("%d\n", a);//以整型输出字符时会默认输出ascii码值！
// //反之亦可以利用给定数值当作ascii码值反向输出对应字符：
//	int b = 0;
//	scanf("%d", &b);
//	printf("%c\n", b);//以字符型输出数字时会默认输出ASCII码表中对应字符！
//	return 0;
//}


//3_指针及指针变量
//int main()
//{
//	int b = 20;////注意 内存地址用编号表示 而地址也被称之为指针 而存储指针的变量就是指针变量
//	int* p = &b;//int是因为p存储着b的内存地址&b,而指向的数据为int类型的b  *说明p是指针变量
//	char c = 'w';//上下的p q均为指针变量的名字 而int* 和 char*为其类型声明
//	char* q = &c;//此处c为char型 故存放指向c地址的指针变量q应表示为char*型		对应关系！
//	//指针变量的意义？
//	*p=10;//解引用操作符，和取地址符在一定程度上是互逆关系：即通过p中存放的地址找到p所指的对象 *p就是p指向的对象
//	printf("%d\n", b);//10; 利用指针变量可以很容易地通过地址指向找到最初变量的地址 并且进行数据更改！
//	return 0;
//}注意：口头上经常就将指针变量叫为指针
//指针变量的大小？
//int main()
//{
//	printf("%zu\n", sizeof(char*));//8
//	printf("%zu\n", sizeof(short*));//8
//	printf("%zu\n", sizeof(int*));//8
//	printf("%zu\n", sizeof(long*));//8
//	printf("%zu\n", sizeof(long long*));//8
//	printf("%zu\n", sizeof(float*));//8
//	printf("%zu\n", sizeof(double*));//8
//	//为何结果全为8? 不管任何类型的指针都是在创建指针变量 指针变量是在存放地址的 指针变量的大小取决于存放地址时需要的空间
//	//而64位计算机机器内的地址均为64bit 也即8字节 故指针变量的大小为8字节
//	//值得一提的是 x86是32位处理器 其寄存器是32位的	x86只是由于其CPU架构为x86类型而得名
//	return 0;
//}


//结构体 struct
//C语言给了程序员自定义类型的能力 结构体便是一种自定义类型
//结构体使得C语言能够描述复杂类型 因为结构体是把单一类型组合在一起用的做法
//struct stu//创建结构体类型stu
//{
//	char name[20];
//	int age;
//	char sex[10];
//	char tele[12];//这四个均为结构体的成员(变量)
//};
//
//void print(struct stu* ps)//此处无需计算出值后返回而是直接打印 故使用void表明无返回值 ()内表明参数为结构体类型stu类型的指针变量ps
//{
//	printf("%s\n %d\n %s\n %s\n", (*ps).name, (*ps).age, (*ps).sex, (*ps).tele);
//	//*ps意为解引用指针变量ps以找到s ()是为了提升优先级 因为其优先级低于.和->操作符;'.'仍然是从结构体对象(变量s)中引用成员...
//	printf("%s\n %d\n %s\n %s\n", ps->name, ps->age, ps->sex, ps->tele);//->也是操作符 意为从结构体指针变量中引用成员...
//	//可以理解为 ps指向变量s的地址 而->则更进一步指向name的地址从而引用成员name 即指向的结构体的...
//	//->  =  (*). 此二者是等效的
//}
//
//int main()
//{
//	struct stu s = { " 张三",18,"男","12345678" };//由int ...类型可创建变量联想 结构体类型也是类型 故此处创建结构体类型变量s ："图纸"-->"房子"
//	//注意 结构体类型列出成员时均为{} 而创建相应变量时也用{} 而{}内" 张三"等是在进行相应的初始化 也即整个变量的初始化
//	//printf("%s\n %d\n %s\n %s\n", s.name, s.age, s.sex, s.tele);//.是操作符 意为从结构体对象(变量s)中引用成员... 即结构体对象的...
//	//printf("%s\n %s\n %d\n %s\n", s.name, s.sex, s.age, s.tele);//可见结构体变量创建后对于其成员的调用不必按照创建结构体类型时的顺序！
//	print(&s);//print是一个函数 ()内意为引用s的地址作为函数print的入口参数
//	return 0;
//}


//拆分输入输出
//int main()
//{
//	int a1, a2, a3 = 0;
//	scanf("%3d %3d %3d", &a1, &a2, &a3);//照此输入后 输入的整型数据会每三位数字一份放入到a1 a2 a3中 超出三位也只取三位
//	printf("%d %d %d", a1, a2, a3);
//	return 0;
//}
//注意：%m,nf表示输出的浮点数，m为宽度(域宽)，n为小数点右边数位(精度),未指定n时，隐含的精度为6(因为是单精度浮点型)；
//同时，在字符串的拆分输入输出时：
//int main()
//{
//	char a[10];
//	gets(a);//gets()可以读取含空格的字符串 而scanf不能 但是要用gets()时只能输入字符数组类型的变量；并且！gets()和scanf均不能检测越界
// 补充puts()的用法，puts()与前两个函数的区别是puts()在输出完后会自动换行；
//	printf("%6.3s", a);//要求输出前三个且占六列 %m.ns: 输出m列 但只取字符串字符串中左端n个字符 空格从左往右补位；
//	return 0;//注意 无论是浮点数还是整型还是字符串若写为%-m.n...则表示空格从右往左补位 但若是n>m 则会自动取n值以保证完整性；
//}
//注意：
//int main()
//{
//	char a[10];//由于此处要输入的是字符串数据 故不能用 char a=0;来进行初始化！而是应采用字符数组来放置字符串
//	scanf("%s", &a);
//	printf("%s\n", a);
//	return 0;
//}