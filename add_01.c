#define _CRT_SECURE_NO_WARNINGS//VS中使用scanf函数必备宏定义 scanf_s为VS专属
#pragma warning(disable:4996)//避免使用scanf时报 返回值被忽略;

//之后有时间一定要自学版本控制工具 如:git(最常用),svn(较简单),tortoisegit(简单).. 掌握这些工具是就业必备的基本功之一！！！
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <windows.h>
#include <time.h>
#include <math.h>
#include <stdbool.h>
#include <ctype.h>
#include <assert.h>
#include <stddef.h>

//hello world!
//int main()
//{
//	printf("hello world!\n");
//	return 0;
//}
//一个很重要的快捷键---------> Ctrl+F 快速查找指定内容 F:find 查找后按F3可以跳到相同内容的下一个位置 注意 这非常重要！！！

//C语言的基本数据类型：
// char				字符型
// short			短整型	  【整
// int				整型
// long				长整型
// long long		更长的整型	型】
// float			单精度浮点数【实型		//关于float类型的初始化 注意0.0或者3.14等等浮点数，编译器都会默认为double类型
// double			双精度浮点数  即浮点型】//所以需要写作 float f=0.0f; 即在初始化值后面加个f 编译器就会按照float型进行初始化
// void				无值型（空值型）
// 
//布尔类型 bool
//注意布尔类型是在C99标准之后才有的 用于定义表示真假值的变量 例如:
//bool flat = true;也就是1
//		或	= false;也就是0
//bool类型仅这两种取值！并且使用bool类型要包含<stdbool.h>这个头文件


//C语言各基本数据类型的大小：X64环境
//int main()
//{
//	 printf("%zu\n", sizeof(char));			1
//	 printf("%zu\n", sizeof(short));		2
//	 printf("%zu\n", sizeof(int));			4
//	 printf("%zu\n", sizeof(long));			8
//	 printf("%zu\n", sizeof(char* ));		8
//	 printf("%zu\n", sizeof(long long));	8
//	 printf("%zu\n", sizeof(float));		4
//	 printf("%zu\n", sizeof(double));		8
//	 printf("%zu\n", sizeof(void));			0
//   //值得一提的是 C语言为了保持跨平台的统一 所以char; short;int;long long;float;double;void等都采用了固定位数
//	 //不随系统位数变化而变化 但是long类型和指针变量类型的大小是根据系统位数而变化的 并且这两者是始终相等的
//   //例如 x86(32位)中两者的大小都是4个字节(4*8=32bit) 但是x64中两者都是8个字节(8*8=64bit)
//	 return 0;
//}


//全局变量和局部变量同时出现时：
// int a=0;
// int main()
//{
//	void iu();
//	{
//		int a = 1;
//		printf("iu-->%d\n", a);
//	}
//	return 0;
//} //变量的赋值遵循就近原则----局部优先级高于全局


//全局变量和局部变量的作用域
//int main()
//{
//	void u();
//	{
//		int a = 1;
//		printf("u-->%d\n", a);
//	}
//	int a = 2;
//	printf("%d\n", a);
//	return 0;
//}


//常量之 数值常量
//int main()
//{
//	int a = 10;
//	printf("%d\n", a);
//	return 0;
//} 这种常量又称为字面常量
//
//
//常量之由 const 定义的常变量：
//int main(void)
//{
//	printf("hello world!\n\n");
//	return 0;
//}
//int main()
//{
//	const int a = 20;//const修饰导致a变为常变量
//	printf("%d\n",a);
//	return 0;
//}
//
//
//常量之由 #define 定义的标识符常量：
//#define max 100//此处 max 为define定义的标志符常量
//#define iu "abcdef"//此处两个宏定义都没有规定 形 可见后面被定义的内容不定
//int main()
//{
//	printf("%d\n", max);
//	int a = max;
//	printf("%d\n", a);//可见其可当作常量来使用
//	printf("%s\n", iu);//%s s:string 即打印字符串
//	return 0;
//}
//
//
//常量之 枚举常量
//enum Color
//{
//	RED,【枚举
//	GREEN,
//	BLUE  常量】
//}					   //R G B作为枚举类型Color的三种可能取值,这些可能取值便是枚举常量
//int main()
//{
//	int num = 10;
//	enum Color c = RED;//此处为对变量c的赋值操作 而赋的值便是枚举常量之一
//	int RED = 20;//容易发现，无法再次对枚举常量进行赋值或是更改操作
//	return 0;
//}


//基础求和程序
//int main()
//{
//	int num1 = 0;
//	int num2 = 0;
//	scanf("%d %d", &num1, &num2);// & 为取地址符 即获取已定义变量在内存中的位置 注意:此处为空格分隔:有时为逗号分隔！
//	int sum = num1 + num2;
//	printf("%d\n", sum);
//	return 0;
//}

//语句末尾勿忘  英文分号； ！
//


//关于数组以及数组内字符串长度的计算规则：
//#include <string.h>;//strlen可计算字符串长度 但是需要此头文件！
//strlen的返回值是 size_t 也就是无符号整型(unsigned int)
//int main() //F10+调试+窗口+监视 可进行查看程序在内存中的存取等操作
//{
//	char arr1[] = "abc";//char[4]
//	char arr2[] = { 'a','b','c' };//char[3]
//	char arr3[] = { 'a','b','c','\0' };//char[4]
//	char arr4[4] = { 'a','b','c' };//char[4]  此处为不完全初始化数组
//	//这说明 \0 仅在读取字符串时出现  是意为字符串读取到此为止的转义字符  而若读取单个字符形式的组合则无需\0 故内存占位将少一个字节
//	//可是注意！在 printf函数中打印截至到\0为止 若无\0 则将出现错误:
//	printf("%s\n", arr1);
//	printf("%s\n", arr2);//报错
//	printf("%s\n", arr3);//正常
//	printf("%s\n", arr4);//输出为"abc"  此处为不完全初始化数组的打印结果
//
//	printf("%d\n", strlen(arr1));//字符串长度为3
//	printf("%d\n", strlen(arr2));//字符串长度为35
//	printf("%d\n", strlen(arr3));//字符串长度为3
//	printf("%d\n", strlen(arr4));//字符串长度为3  此处为不完全初始化数组的字符串长度计算结果
//	//关于不完全初始化：若数组中的元素数目未达到定义数组的数目，则编译器会自动将未初始化的元素赋值为0；
//	//0--数字零  即数值为0（不因编码方式而变化）
//	//"0"--字符零  ASCII码值为48
//	//"\0"--转义字符零  ASCII码值为0
//	//可见 "\0"与被赋值的0（数字0）对于计算机而言是几乎等效的
//	
//	//占位符表示:这里需要占一个位置给后面的数据使用
//	//这说明 \0占内存但不计入字符长度                       补充 拉丁字母长度为一字节  汉字长度至少为二字节
//	 
//	           //                                                  补充 常用打印类型(占位符类型)有：
//            //											%d        整型 (有符号)     
//			 //												%zd		  有符号/无符号整型(能在两者之间自动切换)
//			//												%s        字符串
//		   //												%c        字符型
//		  //												%f        float型
//		 //													%lf       double型
//	    //													%zu       size_t类型
//	   //													%p		  以地址型打印(打印出对应地址)
//	  //													%u		  无符号整型(即无负数)
//	return 0;
//	//	printf()参数与占位符是一一对应关系，如果参数有n个占位符,则printf()的参数就应该有n+1个;
//	//printf()允许限定占位符的最小宽度 %5d表示这个占位符的宽度至少为5位，若不足，则对应的值前面会添加空格，若超出，则正常输出
//}//如若用 %*d则表示自动取占位符宽度;


//打印的标准模式：
//printf ("%...\n",",,,");
// 
// printf("%...\n"); 为字符串专属简写    建议统一写成标准模式；


//转义字符					释义
//\?							在书写连续多个问号时使用，防止他们被解析为三字母词
//\'							用于表示字符常量'
//\"							用于表示一个字符串内部的双引号
//\\							用于表示一个反斜杠，防止它被解释为一个转义序列符
//\a							警告字符，蜂鸣
//\b							退格符
//\f							进纸符
//\n							换行
//\r							回车
//\t							水平制表符  效果类似于 Tab
//\v							垂直制表符
//\ddd						    ddd表示一到三个八进制数字  编译器会将其转换为十进制后对应ASCII信息交换表里的字符后输出
//\xdd						    x后面的dd表示两个十六进制数字     同上
//\0							字符串的结束标志符
//备注：转义字符看似占多个字节 实则不然 均仅占位一个字节 为一个字符  如\t看似可打印出四个空格 实则是为单字符  示例如下
//
//存在转义字符的字符串长度计算
//int main()
//{
//	printf("%d\n", strlen("\ta"));   //长度为2
//	printf("%d\n", strlen("\x22 b"));//长度为3    注意 " "空格（占位符）也占了一个字节长度 
//
//	/*此处常见错误示范之-- > 试问下列字符串长度？*/
//    printf("%d\n", strlen("c:\test\628\test.c"));//长度为十四  易误以为是十三
//	printf("%d\n", strlen("abc\666"));//长度无法计算  易误以为是四
//	此处涉及到两个关于进制转义字符的常见错误 
//	1 前者\628 欲取八进制 但第三位却超过了8 故编译器自动判定为\62 而8则作为一个字符 这为错误一；
//	2 后者\666 欲取八进制 但换算为十进制后过大 超出了127 故无法在ASCII表中找到对应字符 故无法计算字符串长度 这位错误二；
//	return 0;
//} 


//注释
//C语言注释风格 /* */		不可嵌套 就近原则
//C++语言风格注释 //		可嵌套


//常见选择语句				常见循环语句
//1_ if  else                 while循环
//2_ switch                   for循环
//3_                          do...while循环


//if 语句示例
//int main()
//{
//	int a = 0;
//	printf("%s\n", "你想成为程序员大牛吗？");
//	printf("%s\n", "请选择1/0");
//	scanf("%d", &a);
//	if (a == 1)
//	{
//		printf("%s", "那就继续加油吧!");
//	}
//	else
//	{
//		printf("%s", "请不要忘记你为何开始！\n请选择1");
//	}
//	return 0;
//}
//"="表示赋值操作		"=="则表示判断或者比较两个值是否相等，是一种关系运算符


//while 语句示例
//int main()
//{
//	int line = 0;
//	printf("%s\n", "努力学习计算机知识");
//	while (line < 20000)
//	{
//		printf("练习敲代码:%d", line);
//		line++;
//
//		if (line >= 20000)										//常用技巧之--在打出函数名后按"Tab"键可快速生成{ }大括号;
//		{
//			printf("%s\n", "学习永不停止！");
//		}
//		else
//		{
//			printf("%s\n", "继续练习！");
//		}
//	}
//	return 0;
//}


//hhhhhhhhhhhhhhhhhhhhhh 是时候强调这件事情了少年！！！！！！
//没错！！！
//你个傻卵儿老是中英文字符搞混了还看不出来！！！ tmd报错的时候就使劲难受吧！
//尤其是这个 中文的"；" 和 英文的";"
//汗流浃背了吧老弟hhhhhhhhhhh
//其实关键就在于...字符所占的长度不同***
//仔细观察吧少年   line++


//C语言结构类型:
//1_顺序结构
//2_选择结构（分支结构）
//3_循环结构


//数组基础
//int main()
//{
//	int sss[3] = { 1,2,3 };
//	有序排列的同类数据元素的集合称为数组  (存储作用)
//				   0 1 2
//	为区分数组的各个元素 各分量对应着其数字编号 即下标 下标默认从零开始 如上;
//	printf("%d\n", sss[2]);
//	"[]"内自动识别为下标 而不是数字本身 若超出下标范围则输出错误，并且其中只能是常量不能是变量（VS不支持变长数组所致）；
//  事实上C99标准之前，数组的大小都是用常量或者常量表达式来指定的
//  而C99之后支持了变长数组，允许数组的大小是变量，但这种指定方式的数组是不能初始化的；
//  数组的初始化：int sss[3]={1,2,3};		不初始化：int sss[3];
//	return 0;
//}
//
//
//数组基础...
//int main()
//{
//	int ddd[7] = { 1,2,3,4,5,6,7};
//	int i = 0;
//	while (i <3)
//	{
//		i = i + 1;
//		printf("%d\n", ddd[i]);
//		i = i + 1;
//	}
//	while()内的真假用于判断是否进入循环
//	注意i++在前和在后对输出结果的影响是不同的！
//	return 0;
//
//}


//比大小并输出的两种写法--1 直接型
//int main()
//{
//	int a = 0;
//	int b = 0;
//	scanf("%d %d", &a, &b);
//	if (a>b)
//	{
//		printf("%d\n", a);
//
//	}
//	else
//	{
//		printf("%d\n", b);
//	}
//	return 0;
//}

//比大小并输出的两种写法--2 间接型
//int Max(int x, int y)
//{
//	if(x>y)
//		return x;
//	else
//		return y;
//}
//int main()
//{
//	int a = 0;
//	int b = 0;
//	scanf("%d %d", &a, &b);
//	int c=Max(a, b);
//	printf("%d\n", c);
//	return 0;
//}


//错误示例之 if语句中 的return后返回值必须为常量；
//int Change(int z)
//{
//	if (z > 0)
//	{
//		return -1;
//	}
//
//	else
//	{
//		return 0;
//	}
//}


//求一个函数 使得 当x>0时输出-1；当x<0时输出1；当x=0时输出0；
//int change(int a)
//{
//	if (a<0)
//	{
//		return 1;
//	}
//	else if (a==0)//注意 =是赋值   ==是判断等号两边是否相等；
//	{
//		return 0;
//	}
//	else
//	{
//		return -1;
//	}
//}
//int main()
//{
//	int a = 0;
//	scanf("%d", &a);
//	int b = change(a);
//	printf("%d", b);
//	return 0;
//}


//操作符
//算术操作符：
//=  -  *  /  %
//加 减 乘 除 取模
//除
//int main()
//{
//	int a = 7/2;
//	printf("%d\n", a);
//	//结果为3；这是因为当a b 同为整数时  计算机进行的是整数除法；而只有当其中至少有一个浮点数时才会进行浮点数除法！！！！！；
//	float a = 7/2;
//	printf("%f\n", a);
//	//更改打印形式后发现；输出错误；这说明除法种类会影响打印结果；
//	int a = 7/2.0;
//	printf("%d\n", a);
//	//仅更改除法种类后发现 仍然打印不出浮点数结果；可见二者缺一不可！！！；
//	float a = 7/2.0;
//	printf("%f\n", a);
//	float a = 7.0/ 2;
//	printf("%.1f\n", a);
//	//若要保留到浮点后几位  可如上操作 保留一位为.1 两位...
//	float a = -7 / 2.0;
//	printf("%.1f\n", a);
//	//可见该操作符适用于含有负数的操作
//	return 0;
//}
//取模
//int main()
//{
//	int b = 7 % 2;
//	printf("%d\n", b);
//	//取模操作符意为取余数 且该操作符两端仅能为整数 
//	int b = -7 % 2;
//	printf("%d\n", b);
//	//可见该操作符能进行含负数的操作 负数取模结果的正负号由第一个运算数的正负决定;
//	return 0;
//}


//赋值操作符
//=	+=	-=	*=	/=	%=	&=	^=	|=	>>=	<<=
//int main()
//{
//	int a = 0;
//	a = 10;
//	a = a + 1;
//	printf("%d\n", a);
//	int a = 0;
//	a = 10;
//	a += 1;
//	printf("%d\n", a);//上下二者等效  即a+=便是a=a+...	类比可知后面的操作符的含义；
//	return 0;
//}


//双目操作符：需要两个操作数的操作符，如+ - * /等；
//单目操作符；仅需要一个操作数的操作符，相关如下：
//逻辑反操作符：
//首先！C语言中规定 变量值为零则为假 其余则为真
//int main()
//{
//	int a = 0;
//	if (a)//if (ture)
//	{
//		printf("%s\n", "hehe");
//	}
//	int a = 0;
//	if (!a)
//	{
//		printf("%s\n", "hehe");
//	}
//	可见逻辑反操作符可改变C语言中逻辑的真假判断，从而影响输出结果；
//	return 0;
//}
//负值-以及正值+：
//int main()
//{
//	int a = 10;
//	int b = -a;
//	int c = +a;
//	printf("%d\n", b);//-意为取值为负
//	printf("%d\n", c);//+意为+() 意义不大
//	return 0;
//}
//sizeof 操作符：
//注意！！！size of 是单目操作符 不是函数；
//int main()
//{
//	int a = 0;
//	printf("%d\n", sizeof(a));//4
//	printf("%d\n", sizeof(int));//注意 若为此写法 则无法取去括号来写；
//	printf("%d\n", sizeof a);//省略a的括号后结果仍然计算正确 可见其不是函数(是函数则不能去除a的括号，否则报错)
//	return 0;
//}
//int main()
//{
//	int ass[10] = { 0 };//后续自动不完全初始化为数值0；
//	printf("%d\n", sizeof ass);//40;可见sizeof 计算的是整个数组的大小 单位为字节;  注意\0 是在字符串中出现！而非此处的(整型)数组
//	printf("%d\n", sizeof ass[0]);//4 []内的数字对应下标 数组下标从零开始 [0]代表第一个数组内的元素；
//	printf("%d\n", sizeof ass / sizeof ass[0]);//10 可如此求出数组内元素的个数
//	return 0;
//}
//前后置++ --
//int main()
//{
//	int a = 10;
//	int b = a++;//此处为后置++ 即++操作在欲++的变量之后 后置++遵循先使用 后++的原则!
//	printf("%d\n", a);//11
//	printf("%d\n", b);//10
//	//int c = d++;//注意 此处这种先使用标识符 再定义的方式是错误的! 并不是前置++！
//	int d = 20;
//	int e = ++d;//这才是正确的前置++的写法 遵循先++后使用的原则！
//	printf("%d\n", d);//21
//	printf("%d\n", e);//21
//	return 0;
//}
//-- 原理等同
//(类型) 强制类型转换
//int main()
//{
//	int a = 3.1;
//	printf("%d\n", a);// 3 “初始化”: 从“double”转换到“int”，可能丢失数据 
//	//由此看出 1-哪怕赋值为浮点数 编译器仍按整型输出 且程序依然能跑；2-哪怕赋值为一位 编译时也默认按double型转换为int型
//	//为何为最终仍然为int? 因为最开始定义变量时在内存中获取的是int型的存储位置 故哪怕赋值为浮点数 仍然会被转化为整型
//	int b = (int)2.1;//(类型)可以强制转换其类型 此处 double-->int
//	printf("%d\n", b);//不再报这个错误：“初始化”: 从“double”转换到“int”，可能丢失数据
//	return 0;
//}


//关系操作符
// > < = <= >=		!=				==
//				用于测试不等于  用于测试等于
//着重！== 判断两端是否相等 
//int main()
//{
//	int a = 0;
//	if (a=1)//if语句()括号内会判断是否为真	a初始化为0 本为假 但是当赋值a=1后为真 故打印成功
//	{
//		printf("hehe\n");
//	}
//	return 0;
//}
//int main()
//{
//	int a = 0;
//	if(a==1)//a赋值为零 ==测试不等于1 故判断为假 打印失败
//	{
//		printf("hehe\n");
//	}
//	return 0;
//}


//逻辑操作符
//&& 逻辑与-并且...
//|| 逻辑或-或者...


//三目操作符（条件操作符）
//int main()
//{
//	int a = 1;
//	int b = 2;
//	int c = (a > b ? a : b);//条件操作符的示例：exp1 ? exp2 : exp3
//	int d = (a < b ? a : b);//			第一表达式是在进行判断；若一为真 则该操作符输出结果为就近原则 输出二；反之输出三
//	printf("%d\n", d);
//	printf("%d\n", c);
//	return 0;
//}


//逗号表达式
//特点：从左向右 依次计算 取最后表达式的结果为整个表达式的结果；
//int main()
//{
//	int a = 1;
//	int b = 2;
//	int c = (a + b, a * b, a - b);
//	printf("%d\n", c);//值为-1 满足特点；
//	return 0;
//}


//下标引用操作符
//[]是下标引用符 arr 和 3 是[]的操作数
//int main()
//{
//	int arr[10] = { 1,2,3,4,5,6,7,8,8,10 };
//	printf("%d\n", arr[3]);//4
//	printf("%d\n", 3[arr]);//4 可见[]对操作数的处理是一视同仁的
//	int n = 3;
//	printf("%d\n", arr[n]);//4 可见在[]利用下标引用已定义数组中的参数时 []中可以为变量 但是定义数组时[]中不能有变量
//	return 0;
//}
// 
// 
// 函数调用操作符：（） 括号不可省 且括号内外均为该操作符的操作数！


//关键字：C语言本身内置的 而非编写者可以自创的： 编写者定义变量名时也不可以用关键字来命名
//举例一：auto  auto一般被省略掉	define不是关键字！！！
//当定义局部变量时 进入局部变量的作用域时，局部变量自动开始生效；处作用域时自动失效 这便是 auto的作用效果：自动


//变量的命名
//1_应当有实际意义 并且编写者能看懂
//2_名字必须是字母 数字 下划线 组成 不能有特殊字符 不能以数字开头
//3_不能是关键字
//
//
//typedef:对类型重命名
//typedef unsigned int uit;//将无符号整型重命名为 uit;
//int main()
//{
//	uit a = 1;
//	int b = 1;
//	printf("%d\n", a);//1
//	printf("%d\n", b);//1
//	//两者打印结果相同；可见被typedef重命名之后的类型与命名前等效 只是更改了写法
//	return 0;
//}
////有时重命名 形如下所示
//typedef struct Node
//{
//	int data;
//	struct Node* next;
//}stde;//此时对于结构体类型 struct Node重命名为stde 此两种仅为不同情况下的写法；


//static及存储体系介绍
//void test()
//{
//	//int a = 1;//结果：2，2，2...
//	static int a = 1;//结果：2，3，4...
//	a++; 
//	printf("%d\n", a);//为何先使用后加加打印结果为2？因为在a++的a之前并无使用a的地方 而语句从左往右继续执行 故到打印时已加一
//}
//int main()
//{
//	int i = 0;
//	while (i<10)//i为循环次数
//	{
//		test();
//		i++;
//	}
//	return 0;//为何循环打印出来是十个2 而不是2，3...？
//			 //这是因为建立函数test时 其中设置的变量a为局部变量 具有生命周期 每次进入作用域时都重新开始了
//}
//关于 static：
//1_使用static声明的变量是静态变量 初始值为0，其作用域被限制在其被定义的源文件中 生命周期为整个程序开始到结束;
//1-1 static修饰局部变量的时候改变了局部变量的存储位置 从内存的栈区改为了静态区 即原先的局部变量改变为静态(局部)变量了;
//1-2 static修饰全局变量的时候改变了其 外部链接属性-->内部链接属性 此工程的其他源文件便不能再使用这个全局变量了；
//2_使用static声明的函数是静态函数 作用域被限制在其被定义的源文件中 其不能被其他文件中的函数调用；
// 注意：函数本来也有外部链接属性的 若要调用具有该属性的函数或全局变量 只需在其前面加上 extern即可！
//3_使用static声明的代码块是静态代码块 其只会在第一次被使用时执行一次 之后不会再次执行.


//关于内存的分区:
//1_栈区(static) :存放局部变量(包括const定义的局部变量) 形参 返回值;先入后出	由编译器自动分配释放
//2_堆区(heap) : 调用函数 : malloc(),free(),calloc(),realloc();					由程序员分配内存和释放(动态内存分配)
//3_全局(静态)区(分为 .bass 以及 .data) :存放全局变量和静态变量;
//4_常量区(.rodata) :存放字符串 数字等常量以及const修饰的全局变量;
//5_代码区(.text):存放程序的执行代码 也可能有字符串常量和define定义的常量存放.
//
//
//计算机存储体系：
//1_寄存器(集成到CPU上)
//2_高速缓存(cache)
//3_内存
//4_硬盘
//越往上，与CPU交换信息的速度越快，空间越小，造价越高； 实际使用时信息会有自下往上的信息传递；
//关键字register:(寄存器)
//int main()
//{
//	register int a = 1;//register意为 建议将该变量的位置存放在寄存器中使其读写和运行速度更快 但只能是建议！
//	printf("%d\n", a);
//	return 0;
//}


//#define 不仅可以定义标识符常量 还可定义宏
//#define ADD(x,y) ((x)+(y))
//ADD为宏名 宏是宏 而函数是函数
//(x,y)中的x,y为宏的参数，参数是无类型；
//而((x)+(y))为宏体
//需要知道的是 宏是完成替换的 当下文ADD返回参数给宏时 宏自动给对应参数完成替换 如：
//int c = ADD(a, b)-- > int c = ((a)+(b));
//int main()
//{
//	int a = 10;
//	int b = 20;
//	int c = ADD(a, b);
//	printf("%d\n", c);
//	return 0;
//}


//指针***
//1_内存
//首先：计算机中程序的运行都是在内存中运行的
//为提升内存的使用效率 内存被划分成一个个小的内存单元(类似于excel表格形式) 每个内存单元的大小是一个Byte
//同时每个内存单元有自己的编号 称为该内存单元的地址  地址为便于编号采用16进制数表示(只是一种数据表示方式)
//补充 在计算机内部二进制数据转换为16进制数据效率最高；注意：内存地址是不占用内存空间的！
//寻址：计算机根据对内存单元编排的编号(地址)快速找到需要的内存单元并进行数据的读/写操作 这个过程就是寻址
//寻址范围：指CPU能够寻址的最大内存容量/或者说CPU能够操作的最大内存容量
//补充 计算机的寻址范围是由处理器的地址总线的宽度(位数)决定的 也可以理解为CPU寄存器部件的位数 这两者一般是相匹配的
//在X86(32位)硬件环境中 计算机的寻址范围是0~2^32-1 计算如下：(地址为32bit位 二进制 故有2^32次方种可能 但由于从0开始 要末尾-1)
//而寻址空间(寻址范围的最大值)则是 2^32B/1024^3=4GB 注意 寻址范围是没有单位的 但是寻址空间是有单位的
//补充 寻址空间的基本单位是字节 因为每一个寻址空间中的地址都对应一个字节的内存单元 而寻址空间为和内存空间相对应 就采用字节作为基本单位
//2^32=4294967296Byte
//	=4194304Kb
//	=4096Mb
//	=4Gb 即4Gb个
//而在X64环境中 CPU的寻址空间更是达到了16EB
//但是受主板 运行效率 内存容量等等限制 目前是不可能达到这样大的寻址空间的
//换算关系:
//8 bit =1Byte
//1024 Byte=1Kb
//1024 Kb=1Mb
//1024 Mb=1Gb
//1024 Gb=1Tb
//1024 Tb=1Pb
//1024 Pb=1Eb

//补充---------------->>>>
//x64中内存地址用64位二进制数来作为编号..指针是用来存放内存地址的 地址为64位二进制数 那么指针至少就要占据64bit=8字节的内存空间
//这也是为什么x64和x86环境下指针类型所占据的内存空间不同 本质上是因为这两种环境下的地址编号的位数不同
//x86(32位处理器)中内存地址则是用32位二进制数作编号..再次强调 地址编号只是计算机默认规定的 不占用内存空间！
//其实x64也是属于x86系列的架构 只是寻址范围扩大了 运行效率更高了 但是本身其实就是x86系列的64位处理器版本
//而在x64中内存地址需要用16位16进制数来表示 因为2^64=16^16 同理x86中地址则用4位16进制数表示 因为2^32=4^16
//但是--------->>
//不管内存地址是32位还是64位 这些地址都只对应一个内存单元--也就是一个字节大小的内存空间
//关于地址和字节：
//如果存放的数据只占用了一个字节 那么这个字节对应的地址编号就是该数据的地址
//如果存放的数据占用了多个字节 那么该数据的地址就是第一个字节对应的地址编号
//这也是为什么如果我们打印两个相邻整数的地址 会发现虽然它俩各占四个字节但是都只打印出了一个地址编号 并且相差4
//同时 在计算机运行时 内存会动态分配存放数据的位置 所以同样的数据在每次运算时存放的地址可能会产生变化


//2_查看内存地址
//int main()
//{
//	int a = 10;//向内存申请4个字节，用于存储10; 但实际上哪怕变量a要了四个字节单位 a仍然是放在第一个字节单位中;
//	printf("%p\n", &a);//0x 0000 00C5 D28F FC74 这便是内存地址之一(第一个字节的)(随机)	0x表示这个数据是16进制表示的
//	printf("%p\n", a);//000000000000000A	 而这是内存中的数据(16进制的 10) 
//	return 0;
//}
//也可直接查看内存地址调用等信息:F10+调试到末行+调试+窗口+内存+&a即可
//如上操作结果左侧为内存地址 中间为内存中的数据 右边为不准确的内存数据的文本解析


//查看字符类型的ascii码值：
//int main()
//{
//	char a = 0;
//	scanf("%c",&a);
//	printf("%d\n", a);//以整型输出字符时会默认输出ascii码值！
// //反之亦可以利用给定数值当作ascii码值反向输出对应字符：
//	int b = 0;
//	scanf("%d", &b);
//	printf("%c\n", b);//以字符型输出数字时会默认输出ASCII码表中对应字符！
//	return 0;
//}


//3_指针及指针变量
//int main()
//{
//	int b = 20;////注意 内存地址用编号表示 而地址也被称之为指针 而存储指针的变量就是指针变量
//	int* p = &b;//int是因为p存储着b的内存地址&b,而指向的数据为int类型的b  *说明p是指针变量
//	char c = 'w';//上下的p q均为指针变量的名字 而int* 和 char*为其类型声明
//	char* q = &c;//此处c为char型 故存放指向c地址的指针变量q应表示为char*型		对应关系！
//	//指针变量的意义？
//	*p=10;//解引用操作符，和取地址符在一定程度上是互逆关系：即通过p中存放的地址找到p所指的对象 *p就是p指向的对象
//	printf("%d\n", b);//10; 利用指针变量可以很容易地通过地址指向找到最初变量的地址 并且进行数据更改！
//	return 0;
//}注意：口头上经常就将指针变量叫为指针
//指针变量的大小？
//int main()
//{
//	printf("%zu\n", sizeof(char*));//8
//	printf("%zu\n", sizeof(short*));//8
//	printf("%zu\n", sizeof(int*));//8
//	printf("%zu\n", sizeof(long*));//8
//	printf("%zu\n", sizeof(long long*));//8
//	printf("%zu\n", sizeof(float*));//8
//	printf("%zu\n", sizeof(double*));//8
//	//为何结果全为8? 不管任何类型的指针都是在创建指针变量 指针变量是用来存放地址的
//	//指针变量的大小取决于计算机内存地址编号的长度 64位处理器的计算机内部的内存地址编号均为64bit位 也即8字节的大小
//  //而指针是用来存放这些地址编号的 那么指针的大小就不能低于8字节 所以x64中指针的大小都是8字节的
//	//值得一提的是 x86是32位处理器 其寄存器是32位的	x86只是由于其CPU架构为x86类型而得名 类比可知其中指针的大小是4字节
//  //事实上 指针变量的大小只取决于计算机系统的位数 它的大小也等于该计算机中long int类型的大小
//	return 0;
//}


//结构体 struct
//C语言给了程序员自定义类型的能力 结构体便是一种自定义类型
//结构体使得C语言能够描述复杂类型 因为结构体是把单一类型组合在一起用的做法 本质上 结构体类型就是一个超级大数组！
//struct stu//创建结构体类型struct stu
//{
//	char name[20];
//	int age;
//	char sex[10];
//	char tele[12];//这四个均为结构体的成员(变量)
//};
//
//void print(struct stu* ps)//此处无需计算出值后返回而是直接打印 故使用void表明无返回值 ()内表明参数为结构体stu类型的指针变量ps
//{
//	printf("%s\n %d\n %s\n %s\n", (*ps).name, (*ps).age, (*ps).sex, (*ps).tele);
//	//*ps意为解引用指针变量ps以找到s ()是为了提升优先级 因为其优先级低于.和->操作符;'.'仍然是从结构体对象(变量s)中引用成员...
//	printf("%s\n %d\n %s\n %s\n", ps->name, ps->age, ps->sex, ps->tele);//->也是操作符 意为从结构体指针变量中引用成员...
//	//可以理解为 ps指向变量s的地址 而->则更进一步指向name的地址从而引用成员name 即指向的结构体的...
//	//-> 和 (*). 此二者是等效的
//}
//
//int main()
//{
//	struct stu s = { " 张三",18,"男","12345678" };//由int ...类型可创建变量联想 结构体类型也是类型 故此处创建结构体类型变量s ："图纸"-->"房子"
//	//注意 结构体类型列出成员时均为{} 而创建相应变量时也用{} 而{}内" 张三"等是在进行相应的初始化 也即整个变量的初始化
//	//printf("%s\n %d\n %s\n %s\n", s.name, s.age, s.sex, s.tele);//.是操作符 意为从结构体对象(变量s)中引用成员... 即结构体对象的...
//	//printf("%s\n %s\n %d\n %s\n", s.name, s.sex, s.age, s.tele);//可见结构体变量创建后对于其成员的调用不必按照创建结构体类型时的顺序！
//	print(&s);//print是一个函数 ()内意为引用s的地址作为函数print的入口参数
//	return 0;
//}


//拆分输入输出
//int main()
//{
//	int a1, a2, a3 = 0;
//	scanf("%3d %3d %3d", &a1, &a2, &a3);//照此输入后 输入的整型数据会每三位数字一份放入到a1 a2 a3中 超出三位也只取三位
//	printf("%d %d %d", a1, a2, a3);
//	return 0;
//}
//注意：%m,nf表示输出的浮点数，m为宽度(域宽)，n为小数点右边数位(精度),未指定n时，隐含的精度为6(因为是单精度浮点型)；
//同时，在字符串的拆分输入输出时：
//int main()
//{
//	char a[10];
//	gets(a);//gets()可以读取含空格的字符串 而scanf不能 但是要用gets()时只能输入字符数组类型的变量；并且！gets()和scanf均不能检测越界
// 补充puts()的用法，puts()与前两个函数的区别是puts()在输出完后会自动换行；
//	printf("%6.3s", a);//要求输出前三个且占六列 %m.ns: 输出m列 但只取字符串中左端n个字符 空格从左往右补位；
//	return 0;//注意 无论是浮点数还是整型还是字符串若写为%-m.n...则表示空格从右往左补位 但若是n>m 则会自动取n值以保证完整性；
//}
//注意：
//int main()
//{
//	char a[10];//由于此处要输入的是字符串数据 故不能用 char a=0;来进行初始化！而是应采用字符数组来放置字符串
//	scanf("%s", &a);
//	printf("%s\n", a);
//	return 0;
//}


//现在 恭喜你到达C语言初阶的世界!
//回顾：C语言语句分类：
//1_表达式语句
//2_函数调用语句
//3_控制语句
//4_复合语句
//5_空语句
//接下来要学习的是其中的控制语句
//前面提到C语言是一种结构性程序设计语言 三大结构便是 顺序 选择 循环
//而控制语句用于控制程序的执行流程，以实现程序的各种结构方式，它们由特定语句定义符组成 C语言提供了9种控制语句
//分成三类如下：
//1_分支语句(条件判断语句)： if语句  switch语句；
//2_循环执行语句：do while语句 while语句 for语句；
//3_转向语句：break语句 goto语句 continue语句；


//if语句：
//语法结构：1
//if(表达式)//若表达式的真值为1，则输出下列语句；
//	语句；
//int main()
//{
//	if (1==2)
//	{
//		printf("%s", "hello");//未输出"hello"
//	}
//	if (1<2)
//	{
//		printf("%s", "hehe\n");//输出"hehe"
//	}
//	int a = 1;
//	if (a=2)//编译器会将这里理解为对a的赋值 所以无论怎样都是"true"  上一步则会被理解为对变量a的初始化
//	{
//		printf("%d", a);//仍然输出了2  因为变量的使用是遵循就近原则的 
//	}
//	return 0;
//}
//语法结构：2
//if (表达式)
//	语句1；
//else
//	语句2；
//与上文同理，只是if和else后面跟的语句都默认只有一条 若要使用多条语句 需用{}括起来 VS中在if后使用Tab键可自动补全 {}表示代码块
//语法结构：3
//if (表达式)
//	语句1；
//else if (表达式)//else if可以多次使用以表明多分支
//	语句2；
//else
//	语句3；//适用于多分支结构
//int main()
//{
//	int age = 0;
//	scanf("%d", &age);
//	if (0 < age < 28)
//	{
//		printf("%s\n", "童年/少年/青年");
//	}
//	else if (28 < age < 50)
//	{
//		printf("%s\n", "中年");
//	}
//	else if (50<age<65)
//	{
//		printf("%s\n", "中老年");
//	}
//	else
//		printf("%s\n", "老年");
//	return 0;
//}//有意思的是 你将会发现不管输入多少 都会输出第一个结果 这是因为C语言并不完全支持数学中的写法
//在数学中 a<x<b 和 x>a且x<b 是等价的 但是在C语言中会认为这两者是 或 的关系 因此 我们需要对程序进行一些修改
//int main()
//{
//	int age = 0;
//	scanf("%d", &age);
//	if (age > 0 && age < 28)//在C语言中 &&表示并且，||表示或者；
//	{
//		printf("%s\n", "童年/少年/青年");
//	}
//	else if (age > 28 && age < 50)
//	{
//		printf("%s\n", "中年");
//	}
//	else if (age>50 && age<65)
//	{
//		printf("%s\n", "中老年");
//	}
//	else
//		printf("%s\n", "老年");
//	return 0;
//}//注意编译器当读取到if内为真时便不会再编译else后面的语句 反之若if内为假便不会编译if后面的语句
// //修改后程序运行正常 可见在C语言中要写成 x>a且x<b 的形式 才能被编译器正确处理；


//悬空else:
//int main()
//{
//	int a = 0;
//	int b = 2;
//	if (a == 1)
//		if (b == 3)
//			printf("%s\n", "haha");
//	else
//		printf("%s\n", "hehe");
//	return 0;
//}//猜猜打印结果？"hehe"吗？			哈哈 啥也没有
//这是因为 if语句是和就近的else匹配的 二者反之也是 所以第一个if是语法结构1的类型，又因为a\=1 所以下面的整个if else都不会执行
//这里容易误以为第一个if和else对齐从而以为会输出"hehe",但事实上 else本身位置是悬空的，与是否对齐无关 类似的悬空情况有很多
//亦得 写代码时要注意其可读性 并尽可能地用{}将代码块括起来 


//预防出现bug小技巧之一：
//在需要使用 == 判断左右两边是否相等时将变量放右边 常量放左边(常左变右)
//int main()
//{
//	int a = 10;
//	if (a=1)//不小心输入错误 少写了一个= 变成了赋值(无所谓真假)
//	{
//		printf("%s", "hehe");//仍然打印了"hehe" 这是因为编译器并不会对其if()内赋值操作报语法错误  这便导致了出现bug的潜在风险
//	}
//	return 0;
//}
//我们不妨写为：
//int main()
//{
//	int a = 10;
//	if (1=a)
//	{
//		printf("%s", "hehe");
//	}//编译器报错了 因为将一个变量赋值给一个常量是不被允许的！  在这种情况下 编写者便能在第一时间内发现这个错误
//	if (1==a)//修改后
//	{
//		printf("%s", "hehe");
//	}//这便于避免bug的出现
//	return 0;
//}

//:判断一个数是否是奇数 分支语句示例如下
//int main()
//{
//	int a = 0;
//	scanf("%d", &a);
//	if (1==a%2)
//	{
//		printf("%d为奇数",a);
//	}
//	else
//	{
//		printf("%d是偶数",a);
//	}
//	return 0;
//}


//输出1-100中的所有奇数:
//int main()
//{
//	int i = 1;
//	while (i<100)
//	{
//		if (1==i%2)
//		{
//			printf("%d\n", i);
//		}
//		i++;
//	}
//	return 0;
//}//这便是经典的循环+分支嵌套！
//纯循环写法:
//int main()
//{
//	int i = 1;
//	while (i<100)
//	{
//		printf("%d\n", i);
//		i += 2;//i+=2即i=i+2;
//	}
//	return 0;
//}

//在讲switch之前，紧急补充关于char类型的知识：
//int main()
//{
//	char a = -1;
//	unsigned char b = -1;
//	signed char c = -1;
//	printf("%d\n%d\n%d\n", a,b,c);//-1 255 -1
//	char d = 128;
//	unsigned char e = 128;
//	signed char f = 128;
//	printf("%d\n%d\n%d\n", d, e, f);//-128 128 -128
//	return 0;
//}//这里涉及到几个很古老的疑惑：
//为什么这里能用整型打印字符型数据？	为什么字符型数据打印为整型时会有有符号和无符号之分，并且打印效果迥异？
//char 类型声明用于存储字符，但是其本质上是整型的一个分支
//这是因为计算机并不能理解字符，所以在存储字符时实际存储的是整型数据，所以在打印时可采用%d,%c两种打印类型
//当采用%d类型时，则直接打印该字符在存储时使用的整型数据(与ASCII码表相对应)
//若采用%c类型时，则会在打印时再根据ASCII码表转换回整型对应的字符
//由此观之，char类型实质上就是整形的分支之一，所以甚至可以直接定义整型变量时使用char来声明
//但是这里又要注意
//1_在使用char类型创建变量时，存在 有符号和无符号之分，这里的有无符号实质是指一个字节(8bit)中首个个bit是否是符号位之分
// 若首bit是符号位，则这个字节大小由后7个二进制数表示，首位仅表示正负:1为负，0为正；			范围:-128到127
// 若首bit不是符号位，则字节大小由8个二进制数共同表示，显然此时能表示更大的数，但不能表示负数；	范围:0到255
//2_如上所示，有符号位字符类型写作 (signed) char;而无符号位字符类型则写作 unsigned char;前者的signed被大部分编译器认为可以忽略
//而上面程序中的无符号字符变量b因为存储整型范围限制，所以无法打印出负数
//而上面的有符号字符变量d和f也因为...，所以无法打印出>127的数
//有趣的是，对于无符号位char类型而言，全体整数都是由0-255的区间构成的，即从-无穷到+无穷是由无数个该区间一前一后紧挨着填充满的
//用样的，计算机对与有符号位char类型也是这么理解的，只不过区间是-128到127；
//由此，你便可以类比理解到 unsigned int,unsigned short int.etc以及用字符型来打印整型数据最后得到字符的原理
//最后，还需补充:无论是有还是无符号位char类型，能存储的整型数据区间大小都是256，但是ASCII码表仍然只能对应0-127
//补充一个定义 char类型定义一个字符类型的变量，而''内则称之为字符常量；


//switch 语句:是一种多路选择结构，通常用于替代一系列嵌套的if-else语句，使代码更清晰易懂;
//int main()
//{
//	switch (整形表达式)//()内是switch的开关，也就是分支结构执行的入口
//	{
//	case 整型常量表达式://整型常量表达式包括字符常量！理由见上
//		语句;//当case后的整型常量表达式==switch中的整型表达式时,程序才会进入这个分支，从而执行后面的语句;
//		break;//break是该分支结构结束的出口,若没有 break,则程序进入此分支之后的分支都会挨个进入并且执行;
//			 //需要知道的是 break能力是有限的 当存在嵌套switch时 内层的break只能跳出内层switch分支 而想要跳出外层则需要外层break才行
//	case...
//		语句;
//		break;
//	default://当switch结构中的case无一匹配时，程序便会进入default,并执行语句,然后退出switch分支结构;
//		语句;
//		break;//似乎哪怕没有default,分支结构依然会到此为止,但是default及后面语句的存在才可以确保程序至少会有一个默认行为！
//	//default语句可以放在switch中的任意一个位置...补充 case语句并不要求顺序 也就是说可以随意摆放case default位置 只要符合语法规则
//	}
// 
//	return 0;
//}
//下面是一个典型的switch语句:
//int main()
//{
//	int day = 0;
//	scanf("%d", &day);
//	switch (day)
//	{
//	case 1:
//		printf("星期一\n");
//		break;
//	case 2:
//		printf("星期二\n");
//		break;
//	case 3:
//		printf("星期三\n");
//		break;
//	case 4:
//		printf("星期四\n");
//		break;
//	case 5:
//		printf("星期五\n");
//		break;
//	case 6:
//		printf("星期六\n");
//		break;
//	case 7:
//		printf("星期天\n");
//		break;
//	default:
//		printf("输入错误\n");
//		break;
//	}
//
//	return 0;
//}
//如果想要在输入1，2，3，4，5时 输出工作日;6，7时 输出周末;可以按照如下操作:
//int main()
//{
//	int day = 0;
//	scanf("%d", &day);
//	switch (day)
//	{
//	case 1://即不使用出口break，任其执行下面的分支路径，直到break为止即可;
//	case 2:
//	case 3:
//	case 4:
//	case 5:
//		printf("weekday\n");
//		break;
//	case 6:
//	case 7:
//		printf("weekend\n");
//		break;
//	default:
//		printf("error\n");
//		break;
//	}
//
//	return 0;
//}
//补充:switch是可以嵌套的，但请注意,break仍然只和相应的的case对应,例如在嵌套的switch中，遇见break仅仅只会跳出当前嵌套，而不是整个分支结构


//while循环:
//int main()
//{
//	int i = 1;
//	while (i<=10)
//	{
//		//if (5==i)
//		//{
//		//	break;//打印结果为1234;可见在while循环中的break可以直接终止整个循环，这点与switch语句不同；
//		//}
//		if (5==i)
//		{
//			continue;//打印结果同样为1234但是右边|光标一直闪烁，这是因为程序一直在运行，还远未结束
//		}//可见continue可以跳过本次循环后面的代码，直接去判断下一次循环是否进行 由于i++在后 故i一直=5 陷入了死循环
//		printf("%d", i);
//		i++;
//	}
//
//	return 0;
//}
//int main()
//{
//	int i = 0;
//	while (i <= 10)
//	{
//		i++;
//		if (5==i)
//		{
//			continue;//为什么这次continue打印出了后面的数并且没有死循环? 这是因为i++在前，从i>5开始if分支便不执行了 于是循环继续 直到i>10为止
//		}
//		printf("%d", i);//打印出了123467891011
//	}
//
//	return 0;
//}


//int main()
//{
//	int ch = getchar();
//	//关于getchar():意为获取一个字符,注意仅为一个字符(人为输入的)，将其放置到变量ch中,类似于scanf();
//	//为什么用int不用char? 首先请注意，对于计算机而言，字符的实质就是ascii数字编码，因此getchar的返回值便是整型数据
//	//其次，当遇到读取错误或者读取到EOF(end of file)时,函数会返回一个'EOF',而EOF本质上是define定义的-1，故也需要整型返回 综上两点
//	//其实若只是常规用来读取字符，char类型也可以，因为char类型也是整型的一种
//	//但是考虑到可能会返回EOF，而EOF(整型的-1)用char类型返回长度会溢出，故综合考量下使用int类型为不会出错的选择
//		putchar(ch);
//	//关于putchar() 类似于printf() 输出int类型数据，但是要输出的字符常常使用unsigned char长度传递(8位)，故实际上这些字符被视为char类型处理；
//	return 0;
//}


//补充：为什么getchar 和scanf是截然不同的两种输入函数？
//因为getchar能够读取\n(空格)和回车，而scanf不能；当键盘的输入数据传递到缓冲区后,若是scanf，则会取走前面的数据而留下\n
//而这将导致在下一次读取时，缓冲区会有残留的数据(空格或回车等)，在一些需要重复读取输入的问题中将可能出错，比如请确认密码时；
//而putchar则不会出现这种情况 当然也可以用putchar来清空缓冲区然后再进行重复的读取输入;
//示例如下:
//int main()
//{
//	char password[20] = { 0 };
//	int ch = 0;
//	printf("请输入密码:\n");
//	scanf("%s", password);
//	printf("请确认密码(Y/N):\n");
//	ch = getchar();//此处采用scanf()读取同样会出错，原因如上；
//	if (ch == 'Y')
//		printf("确认成功\n");
//	else
//		printf("确认失败\n");
//	return 0;
//}
//修改后:(利用getchar来清空缓冲区)
//int main()
//{
//	char password[20] = { 0 };
//	int ch = 0;
//	printf("请输入密码:\n");
//	scanf("%s", password);//此处之所以不用&，是因为数组名本身就是地址
//	while (getchar() != '\n')//此处用循环getchar()清空而不是单个getchar()是为了以防在输入的密码中间有空格或者制表符存在的情况
//	{
//		;			// !=需连写，用于判断等式两边是否不相等
//	}
//	//事实上，scanf也能跳过空格和制表符等继续读取，只需要使用前导空格字符 即scanf(" %s",password);但是这种方式还是会导致缓冲区仍有余留
//	printf("请确认密码(Y/N):\n");
//	ch = getchar();
//	if (ch == 'Y')
//		printf("确认成功\n");
//	else
//		printf("确认失败\n");
//
//	return 0;
//}


//int main()
//{
//	int ch = '\0';//初始化为0也可以，因为'\0'的ascii码值就是0；
//	while ((ch = getchar()) != EOF)//注意，虽然getchar每次仅读取一个字符，但放入循环后便会一直读取,直到读取到\n换行继续等待下一次输入
//	{
//		if (ch < '0' || ch>'9')//此处意为当ch中字符对应的ascii码值 <0或者>9的ascii码值时将跳过此次打印，不会打印出来
//			continue;
//		putchar(ch);
//	}//这段代码的作用便是只打印数字字符，跳过其他字符的打印
//	//注意，含有getchar()的循环(其实是通用的方法...)如何让程序停止？ctrl+c(推荐)或ctrl+z+enter  而shift+esc可关闭过程窗;
//	return 0;
//}


//for循环：
//其实我们不难发现，while循环的主体就是三个部分
//int main()
//{
//	int i = 1;//这是对循环参量的初始化部分
//	while (i<=10)//这是循环的条件判断部分
//	{
//		printf("%d\n", i);
//		i++;//这是循环的调整部分
//	}
//	return 0;
//}//这三个部分其实就是while循环的主体，任意一个部分的改变都可能导致完全不同的循环
//可是这三个主体过于分散 不利于可能的修改 由此 我们开始for循环的新大门
//for语句:
//for (size_t i = 0; i < length; i++)//注意 各部分之间用;分隔开
//{
	//由这个for范例可以看出，for括号内其实就是三个主体部分 size_t是变量类型 i=...是初始化值 i<...是条件判断 i++为调整部分
//}
//接下来使用for来实现上一个程序
//int main()
//{
//	for (int i = 1; i <=10; i++)//肉眼可见地利于修改了
//	{
//		printf("%d\n", i);
//	}
//	//printf("%d\n", i);	注意 将打印语句放在for循环之外时 i便是一个未定义的标识符，可见由for循环定义的变量只能在for之内用
//	return 0;
//}//当然，for循环中同样有break and continue并且效果一致
	//但是for中continue满足时并不会跳过后面的调整部分，这与while中不同(while中会跳过i++从而陷入死循环)
//for循环的使用建议:
//1_不要在for循环体内修改变量，以防for循环失去控制；
//2_建议for语句的循环控制变量的取值采用[ )前闭区间后开区间的写法; i<=9是闭区间写法，而i<10则是开区间写法，这样的代码可读性更高
//3_注意，for循环中初始定义的变量的作用域仅限于for循环以内，当走出for之后，编译器便不再认for以内的任何变量值


//for循环的一些变种:
//int main()
//{
//	for  (; ;)//for循环中的三个部分均可以省略，但是不建议初学者这样操作，容易出错;
//	{
//		printf("hehe\n");//这里陷入了死循环;因为判断部分省略了之后这个判断就会恒成立，循环也就会一直进行;
//	}
//	return 0;
//}
//接下来是一个常见的错误引例:
//int main()//不省略
//{
//	int i = 0;
//	int j = 0;
//	for (int i = 0; i < 10; i++)
//	{
//		for (int j = 0; j < 10; j++)
//		{
//			printf("hehe\n");//此时打印了100个hehe 这是因为嵌套for循环的原则是先内后外 只有当内层循环完了之后外层才继续下一次循环
//		}//内层循环完打印十遍hehe，而外层要循环十次，外层嵌套的内层也就要跟着循环十次，故10*10=100;
//	}
//	return 0;
//}

//int main()//省略
//{
//	int i = 0;
//	int j = 0;
//	for (;i< 10;i++)
//	{
//		for (;j< 10;j++)
//		{
//			printf("hehe\n");//结果是打印了十个hehe;为什么呢?
//		}//这是因为对于j而言当j等于10第一次跳出循环时，后续再进入到这个循环时因为j没有初始化为0，所以j依然等于10导致
//	}//也就是说外层循环依然循环了10次，但是内层循环实际上只循环了第一次，后续几次根本没有进入内层循环
//	return 0;
//}
//提醒! for(int a=0;a<10;a++)中int a=0的写法是C99标准之后才支持的，一些较古早的编译器可能只支持for(a=0;a<10;a++)这种写法;

//事实上，可以使用多个变量来控制循环:
//int main()
//{
//	for (int x = 0,y=5; x < 3 && y>4; x++,y++)//这里便同时使用了两种变量来控制循环的开始与结束;
//	{
//		printf("hehe\n");
//	}
//
//	return 0;
//}

//int main()
//{
//	int i = 0;
//	int j = 0;
//	for (int i = 0,j=0; j=0; i++,j++)//请仔细观察！
//	{
//		printf("hehe\n");//为什么循环0次？ 因为判断条件为j=0;意为将0赋给j;0为假 故判断结果是不进入循环;
//	}
//
//	return 0;
//}

//do while循环:
//形如 :
//do
//	循环语句
//while(表达式)
//可见do while循环的特点是 至少先完成一次循环，然后再判断是否进行下一次循环;
//int main()
//{
//	int i = 1;
//	do
//	{
//		printf("%d\n", i);
//		i++;//注意 和while for 一样，若想要在循环中执行多条操作语句，需要用{}括起来;否则程序运行错误或者死循环！
//	}
//	while (i < 11);
//	return 0;
//}
//int main()
//{
//	int i = 0;
//	do
//	{
//		if (4==i)
//		{
//			//break;
//			continue;
//		}
//		printf("%d\n", i);
//		i++;
//	} while (i<10);//0 1 2 3后接空白死循环
//	//在do while语句中，break and continue和在while语句中具有相同效力
//	while (i < 11)
//	{
//		if (4 == i)
//		{
//			continue;
//		}
//		printf("%d\n", i);
//		i++;
//	}//0 1 2 3后接空白死循环
//	//这两者死循环的都因为后置i++，导致i一直等于4，然后一直被跳过...
//	for (int i = 0; i < 11; i++)
//	{
//		if (4==i)
//		{
//			continue;
//		}
//		printf("%d\n", i);
//	}
//	//在这三种写法中，仅有for循环成功达到了预期
//	//这也是为什么 在平时使用时最常用的便是for循环 提高容错 而且书写更方便;
//	return 0;
//}

//运用循环:
//计算阶乘 考虑递归或者循环;
//int main()
//{
//	int n= 0;
//	int t = 1;
//	scanf("%d", &n);
//	for (int i = 1/*i为1或者2均可*/; i <= n; i++)
//	{
//		t = i * t;//这里的t初始化必须均为1，这样1*i才会等于i本身, t的意义就是存储乘积并且迭代;
//	}
//	printf("%d\n", t);
//	return 0;
//}//这种方法不能实现大数运算，因为会溢出，只有模拟实现大数运算，才能解决内存溢出问题;

//计算阶乘之和;
//int main()
//{
//	int n = 0;
//	int t = 1;
//	int s = 0;
//	scanf("%d", &n);
//	for (int i = 1; i <=n; i++)
//	{
//		t = t * i;
//		s = s + t;
//		//需要注意 for循环中定义的变量是有其作用域的 当内外同时定义了一个变量时 一旦离开for 变量值就回归外部定义值了
//	}
//	printf("%d\n", s);//而s之所以能出for而且值为循环后的结果 是因为s不是for循环定义的变量 只是经过了循环
//	return 0;
//}
//另一种写法;
//int main()
//{
//	int n = 0;
//	int i = 1;
//	int sum = 0;
//	//这里可以再定义一个变量，就可以将这个程序改写为输入决定输出型;
//	for (int n = 1; n<=3 ; n++)
//	{
//		int p = 1;//此处添加上初始化;
//		for (int i = 1; i <=n; i++)
//		{
//			p *= i;//打印结果为15 原因是此处p没有在外层循环被初始化，导致内层循环计算单个阶乘时出错(p值一直叠加)
//		}
//		sum += p;
//	}
//	printf("%d\n", sum);//添加初始化后打印结果为9;
//	return 0;
//	//需要注意的是，这种嵌套for的写法时间和空间复杂度都提高了，因为每次计算一个阶乘后下一个都要从头开始，很浪费资源
//	//当我们采用上一个写法时，新阶乘只需要在前一个基础上*i就可以了，而原阶乘又可以直接拿去相加，节省了时间和空间
//}

//关于调试(Debug)
//需要知道，VS并不只是一个编译器，而是一个IDE，其中当然也包含了调试器
//在上方 项目 的下面可以看到Debug，这表示当前是调试版本，里面包含调试信息，程序员可以在里面进行各种调试，而后者则不能调试;
//而点击后可以选择为Release，也就是发布版本，这往往是进行了各种优化使得程序在代码大小和运行速度上都是最优解的，是利于发布和用户使用的版本
//常用的调试是 点按F10/F11 程序会自动按照流程走 F10与F11的区别在于后者可以帮助我们进入函数内部而前者会跳过函数代码块
//因此常用F11 点按后程序的执行情况便一句一句清晰可见 通常还需要用到监视窗口以看到变量值的变化，或者查看内存的地址变化等等
//还有的调试是F9(设置断点)+F5(执行调试)，不过这需要鼠标点按 故较少用
//年轻人，多做调试吧，提高自己的纠错能力，这也是代码水平的一部分！


//在一个有序数组中查找某个数n:
//int main()
//{
//	int i = 0;
//	int arr[] = { 1,2,3,4,5,6,7,8 };
//	int sz = sizeof(arr) / sizeof(arr[0]);
//	int k = 35;
//	for (int i = 0; i <=sz; i++)
//	{
//		if (arr[i]==k)
//		{
//			printf("找到了\n%d\n", arr[i]);
//			break;
//		}
//		if (i == sz)
//		{
//			printf("没找到\n");
//		}
//	}
//	return 0;
//}//这种低级算法好处是哪怕数组内部是无序的也同样可以使用,但是这本身比较浪费有序数组的条件
//接下来我们来讲二分查找:
//何为二分查找?
//经典猜数字:
//1到100请猜一个数，如何才能更快? 
//50 大/小 25/75 大/小 ...
//上述就是二分查找 这带来的是肉眼可见的速度提升，相较于枚举而言;下面我们来学习一下其代码表示;
//仍然用于在一个有序数组中查找某个数;
//int main()
//{
//	int arr[] = { 1,2,3,4,5,6,7,8,9 };
//	int sz = sizeof(arr) / sizeof(arr[0]);
//	int k = 0;
//	scanf("%d", &k);//k为欲查找数
//	int left = 0;//意为左逼近
//	int right = sz - 1;//意为右逼近，sz-1是因为当有sz个数时尾数的下标为sz-1
//	while (left<=right)
//	{
//		//int mid = (left + right) / 2;//如若担心mid的值越界(整型范围)，可改写为:
//		int mid = left + (right - left) / 2;//这种写法下允许了更大值和左右均遇到奇数时的查找,虽然仍然有越界可能;
//		if (arr[mid]<k)
//		{
//			left = mid + 1;//此处为何一定要+1?
//		}
//		else if (arr[mid]>k)
//		{
//			right = mid - 1;//此处为何一定要-1?
//		}
//		else
//		{
//			printf("找到了\n下标是%d\n", mid);
//			break;
//		}
//	}//若上面的循环中left right不加减1则当出现.5时，系统会保留为整数，当遇到边界值时,left/right会一直被赋为同一个值 导致死循环
//	if (left>right)//若不加减1 也同样无法出现left>right的情况 只能是陷入相等的死循环
//	{
//		printf("找不到匹配项\n");
//	}
//	return 0;
//}

//试着打印一个字符从两端到中间逐渐显现出的效果
//#include<windows.h>//这里为了展示渐进效果，需要使用sleep函数，而sleep需要从这个头文件蕴含的库函数中调用;
//#include<stdlib.h>//这里为了实现每次渐进仅展示一行的效果调用了系统命令 system("cls") 而调用system这个库函数需要包含这个头文件
//int main()
//{
//	char arr1[] = "Welcome to code world!!!";//arr1是欲显现的字符数组;
//	char arr2[] = "########################";//arr2是显现过程即开始过程挡住的字符数组(即渐进效果)
//	int left = 0;
//	int right = strlen(arr2 - 1);//用arr2/1均可，因为上下长度一致，strlen计算字符串长度会包含字符串中间的空格 -1是因为right是下标
//	//int right = sizeof(arr2 - 2);//此处-2是因为sizeof包含了"\0"故而计算出的个数会多一个;
//	while (left<=right)
//	{
//		arr2[left] = arr1[left];
//		arr2[right] = arr1[right];
//		printf("%s\n", arr2);
//			Sleep(1000);//Sleep 意为休眠多久多久，括号内的数字为多少分之一秒 此处为千分之一秒;S要大写 注意
//			system("cls");//system是一个库函数，可以执行系统命令 表示 clear screen 清屏
//		left++;
//		right--;
//	}
//	printf("%s\n", arr2);//这里是为了在while最后一次打印后不清屏而不得不添加的补充打印 目的仅仅是为了打印最后一次
//	return 0;
//}

//接下来试试 设计一个程序，使得用户可以输入密码并实现验证(<=3次) 假定密码为 abc123;
//#include<string.h>//本程序用到了 strcmp 调用此函数需要调用该头文件 考虑到此源文件开头已经包含了此头文件 此处便不再赘述;
//int main()
//{
//	int i = 0;
//	char password[20] = { 0 };//初始化一个字符数组 注意要确定字符数目的上限 否则程序不会正常结束;
//	printf("请输入密码\n");
//	for (i=0 ; i < 3; i++)//此处for不使用int i =0;
//	{
//		//这是因为一旦一个变量在for之中被声明 那么该变量的作用域将限制于for内 意为:这是一个在for循环内新创建的一个局部变量
//		//哪怕在外界已经声明了一个重名变量 当离开for时，该变量的值会立刻回归到外界声明的值;
//		//而外界声明了但for内不声明的变量的值便是可以带出for循环的了 此处便是为了带出i的值以使当三次输入错误时 最后的if语句能正常实现
//		scanf("%s", password);
//		if (strcmp(password,"abc123") == 0)//strcmp 意为string compare 用于字符间的比较 实质是比较ASCII码值之和
//		{
//			printf("密码正确\n");
//			break;//若无此跳出 则会陷入死循环
//		}// 当括号内前者大于后者时 strcmp返回一个正值 反之则返回一个负值(多数编译器对应返回的就是1和-1) 相等时则返回0;
//		else
//		{
//			printf("密码错误\n");
//		}
//		
//	}
//	if (3==i)
//	{
//		printf("三次密码均输入错误 请明天再试!\n");
//	}
//	return 0;
//}


//猜数字游戏
//思路:
//1 电脑随机生成一个数;
//2 玩家来猜一个数;
//3 电脑给出大/小/猜对;
//4 玩完后返回菜单页面,等候下一次选择;

//设计菜单页面:
//void menu()
//{
//	printf("####################\n");
//	printf("###请选择是否游玩###\n");
//	printf("#####  1 游玩  #####\n");
//	printf("#####  0 退出  #####\n");
//}

//设计游戏主体部分:
//void Game()
//{
////	printf("%d\n", rand());//srand是随机数发生器的初始化函数 和rand函数均被放于<stdilb.h>这个头文件中 故使用时需引入该头文件
////	printf("%d\n", rand());//原型: void srand (unsigned int seed) seed相当于一个种子 srand函数根据这个seed设置一个随机起点
////	printf("%d\n", rand());//而rand函数根据这个随机起点 返回一个随机数 范围是0~0x7ffff(32767) 注意 除非给一个变化的种子
////	printf("%d\n", rand());//否则这个随机数就是伪的随机数(多次编译时产生的随机数是一样的)
//	srand(1);//值得注意 rand函数每一次调用时都会查看之前是否调用了srand函数 若调用了 则rand函数会调用srand(seed)来初始化它的随机值
//	printf("%d\n", rand());//若之前没有调用srand 则会默认调用srand(1)来初始化它的随机值
//	printf("%d\n", rand());
//	printf("%d\n", rand());
//	srand(2);
//	printf("%d\n", rand());
//	printf("%d\n", rand());
//	printf("%d\n", rand());
//	srand(3);
//	printf("%d\n", rand());
//	printf("%d\n", rand());
//	printf("%d\n", rand());//由这三次结果可知 当每次输入不同的种子时 产生的每组随机数都是不一样的
//	//那么 接下来问题就变成了如何让srand(seed)中存在一个变化的种子
//}
//接下来介绍时间戳:
//time函数包含于<time.h>这个头文件中
//time函数可以获取当前的系统时间:是指从1970年1月1日零时零分到目前为止所经过时间的秒数累计 也即 时间戳
//可见时间戳就是一个一直都在变化的量
//time_t time(time_t*t); 这是time函数的形式 对于64位处理器 time_t是long int 或者 long long int类型
//该函数提供两种返回方式 返回值或者返回指针参数 当参数为空指针(NULL)时只返回值 而NULL的定义是(void*)0 可见time(NULL)和time(0)是等效的
//看来我们需要使用这个time(NULL) 但是srand()中的种子seed要求是unsigned int 类型 故我们还需要强制类型转换
//即 srand((unsigned int)time(NULL)) 这样便得到了一个变化的种子 接下来我们再来写一下游戏的主体部分试试
//void Game()
//{
//	int guess = 0;//guess用于放置玩家猜的值
//	int ran = rand()%100 + 1;//rand()%100表示的值将不会超过100(取模运算);即0~99 而+1后得到的范围就是1~100之间 范围更加合理了
//	int count = 0;//count用于记录猜的次数;
//	while (1)
//	{
//		printf("请输入数字\n");
//		scanf("%d", &guess);
//		if (guess<ran)
//		{
//			printf("你猜小了 笨蛋\n");
//		}
//		else if (guess>ran)
//		{
//			printf("你猜大了 傻卵\n");
//		}
//		else
//		{
//			printf("恭喜！ 你猜对了！\n共计猜了%d次\n",count+1);
//			break;
//		}
//		count++;
//	}
//}

//int main()
//{
//	int input = 0;
//	srand((unsigned int)time(NULL));
//	//将srand置于这里是因为整个工程中只需要设置一次随机生成数的起点就可以了 并非每次生成随机数都需要设置一次起点
//	//如果是后者 也就是说将这个srand置于Game函数中的话 将导致一旦生成随机数过快(相差不超过1s) 将生成同一个随机数 这是不可取的
//	do
//	{
//		menu();
//		scanf("%d", &input);
//		switch (input)
//		{
//		case 1:
//			Game();
//			break;
//		case 0:
//			printf("退出游戏\n");
//			break;
//		default:
//			printf("输入错误，请重新输入!\n");
//			break;
//		}
//	} while (input);//此处通过输入input的值来判断是否进入下一次循环 准确来说是输入值也就是真假值(0/1/其他) 这个设计很巧妙
//
//	return 0;
//}


//goto 语句 即瞬时跳转语句;
//C语言提供了可以滥用的goto语句和标记跳转的标号;
//但是从理论上来说 goto语句是没有太大实际意义的 因为没有它我们也能轻易写出代码来
//它的两个缺点:
//1_由于goto语句的随意性 导致它可能让整个程序的执行顺序变得混乱 这可能导致更多的bug出现 威胁程序的安全
//2_goto语句无法跳转到单独的函数代码块中 也就是说跳转的位置是受限的
//它的优点:
//goto语句最常用的就是用于跳出深度嵌套结构 比如多重循环 这是break难以达到的效果 因为它只能跳转到上一层循环 但goto却可以跳出整体
//这是一个goto语句的示例:
//int main()
//{
//	char input[20] = { 0 };
//	system("shutdown -s -t 60");//shutdown -s:关机指令 -t:设置关机指令(需要设置时间) 60则是设置的时间
//again:
//	printf("请注意！你的电脑即将在60秒后关机\n若输入:我是猪\n即可取消关机\n");
//	scanf("%s", input);
//	if (strcmp(input,"我是猪")==0)
//	{
//		system("shutdown -a");//-a 表示 -annul 即取消指令
//		printf("已取消关机:>\n");
//	}
//	else
//	{
//		goto again;
//	}
//	return 0;
//}//不难发现 这段代码也可以使用循环来写 也就是用循环主体替换again后面的内容即可


//函数:
//在C语言中函数的定义与数学中略有不同
//在C语言中 
//函数是一个子程序，是一个大型程序的某部分代码，由一个或多个语句块组成，负责完成某项特殊的任务，具有一定的独立性;
//特征:一般会有输入参数并有返回值，提供对过程的封装和细节的隐藏，这些代码通常被集成为软件库。
//分类：1_库函数 2_自定义函数
//为什么会有库函数?
//库函数是C语言后续发展来的 可以提高写代码的效率和代码的标准化程度 还可以降低出现bug的可能;
//在www.cplusplus.com中可以查看库函数列表
//通过这个网站我们可以很迅速地学习到各类库函数的用法
//简单总结一下，C语言常用的库函数有:
//IO函数
//字符串操作函数
//字符操作函数
//内存操作函数
//时间/日期函数
//数学函数
//其他
//当然，请注意使用这些库函数时必须要包含能调用这些库函数的头文件
//自定义函数也由以下几个部分组成：
//ret_type_(返回值类型...可以是void 即不返回) fun_name(函数名)(paral,*参数 参数最好写上类型！)
//{
	//statement;//语句项
//}//{}括起来的内容是自定义函数的主体部分 也即函数的实现
//需要知道 主体程序传递给函数的参数是实参 而函数名括号内的变量是形参 形参是实参的一份临时拷贝
//所以当自定义函数无返回值时 函数部分对形参的修改不会影响实参
//但是请注意 如果主程序传递到函数的是变量的地址 那么此时改动形参和改动实参的效果就可能是一样的
//因为当用一个指针变量来存放这个传递过来的地址后 一旦对这个这个指针进行解引用 那么此时就可以通过这个指针指向的地址直接对原变量(实参)进行修改
//所以 当我们需要函数对实参进行修改时 就可以传递实参对应的地址 反之则正常使用形参来进行函数操作就可以了
//这里其实也涉及到两种函数调用方式 1 传值调用(后者); 2 传址调用(前者)
//关于实参:
//实参是真实传递给函数的参数 实参可以是常量 变量 表达式 函数等 在进行函数调用时 实参必须要有确定的值 以便把这些值传递给形参
//关于形参:
//形参是指函数名括号中的变量 形参只有在函数被调用的过程中才实例化(分配内存单元) 并且形参在函数被调用完后会自动销毁 故形参只在函数调用的过程中存在
//形参和实参的命名可以相同 也可以不同 这两者的作用域不同 所以无论是否重名都不会互相影响 形参只是实参的临时拷贝

//求100~200之间的素数?(素数指仅能被1和自己整除的数 也就是说2到该数之间没有数可以整除该数)
//int main()
//{
//	int i = 0;//用i表示100~200之间的数
//	int count = 0;//count用于计算素数的个数
//	//for (i = 100; i <= 200; i++)//容易知道 当i>2后的素数必然是奇数 所以我们可以就此从源头上减小计算复杂度
//	for (i = 101; i <= 200; i += 2)
//	{
//			int t = 1;//用t的值来得知该数是否是素数
//			//for (int j = 2; j < i-1; j++)//思考 这里是否也可以简化?是否一定要用2到i-1之间每一个数去除试试?``````答案是否定的！
//			//由数学知识可知 其实我们只需要试到根号下i就可以了 因为根号i已经是除i以外最大的一个因数了
//			//所以我们稍作优化 降低其时间上的损耗;
//			for (int j = 2; j <= sqrt(i); j++)//sqrt 是开方函数 调用该函数需要包含<math.h>这个头文件
//			{
//				int z = i % j;
//				if (0 == z)
//				{
//					t = 0;//t为0则说明该数不是素数
//				}
//			}
//			if (1 == t)
//			{
//				printf("%d ", i);
//				count++;
//			}
//	}
//	printf("\ncount= %d\n", count);
//	return 0;
//}
//接下来我们来看看如何用函数表示
//int ion_prime(int n)//注意函数的命名 ion means is or not 而prime number意为素数 这里简写prime
//{
//	for (int j = 2; j <= sqrt(n); j++)
//	{
//		if (0 == n % j)
//		{
//			return 0;
//		}
//		//else
//		//{
//		//	return 1;
//		////为什么这种写法是错误的?  因为将return 1放入for内的话 这个for并未循环到sqrt(n)为止而是第一次循环就返回1 跳出了函数体
//		//}
//		//else if (1== n % j)
//		//{
//		//	return 1;
//		////不难发现 这种写法也是错误的 因为函数也会在第一次循环时提前结束
//		//}
//	}
//	return 1;//因此 我们直接将返回1放在for循环之外 让for循环完成之后再返回 真
//}
//int main()
//{
//	int i = 0;
//	int count = 0;
//	for (i = 101; i <= 200; i += 2)
//	{
//		if (ion_prime(i))//此处直接用函数返回值来进行真假判断 这是常见技巧
//		{
//			printf("%d ", i);
//			count++;
//		}
//		
//	}
//	printf("\ncount= %d\n", count);
//	return 0;
//}

//写一个函数 判断公元0到2000年之间有多少闰年
//首先我们需要知道 判断闰年有两个判断条件
//1_这个年份可以被4整除 但不可以被一百整除
//2_这个年份如果被400整除 那么这一年也是闰年
//由此 我们可以先写出一个不用函数的写法
//int main()
//{
//	int i = 0;//i表示年份
//	int count = 0;//count表示出现闰年的个数
//	for ( i = 0; i <= 2000; i++)
//	{
//		//if (0 == i%4)
//		//{
//		//	if (0 != i%100)
//		//	{
//		//		printf("%d ", i);
//		//		count++;
//		//	}
//		//}
//		//else if (0 == i%400)
//		//{
//		//	printf("%d ", i);
//		//	count++;//不难发现 这种写法下 满足规则2的闰年其实并没有被打印下来 因为此处的第一二中情况并不是并列关系 换成else也不行
//		//}
//		//if (0 == i%400)//只有这种写法才是并列关系的if 也才能使两条规则同时满足
//		//{
//		//		printf("%d ", i);
//		//	count++;
//		//}
//		//其实这里的两条规则都是 并且 并列 关系的组合 因此我们还可以换种写法 更为简洁
//		if (((0 == i%4)&&(0! = i%100))||(0 == i%400))
//		{
//			printf("%d ", i);
//			count++;
//		}
//	}
//	printf("\ncount=%d\n", count);
//	return 0;
//}
//接下来试试函数的写法
//int ion_leap_year(int year)//leap year是闰年的意思
//{
//	if (((0 == year%4)&&(0 != year%100))||(0 == year%400))
//	{
//		return 1;
//	}
//	else
//	{
//		return 0;
//	}
//	//为什么不在函数内同时完成year的判断和打印？
//	//因为这将导致函数的二功能不够单一
//	//函数的功能越单一 使用时也就越自由 越不用顾虑 在程序封装之后也更好使用
//	//关于函数自定义的一个口诀:高内聚(内部功能完整凝练)	  低耦合(与程序的其他部分关联度要小)
//}
//int main()
//{
//	int i = 0;
//	int count = 0;
//	for ( i = 0; i <= 2000; i++)
//	{
//		if (ion_leap_year(i))
//		{
//			printf("%d ", i);
//			count++;
//		}
//		else
//		{
//			continue;
//		}
//	}
//	printf("\ncount=%d", count);
//	return 0;
//}

//写一个函数 实现整型有序数组的二分查找
//int search(int *arr, int k,int sz)//这里可以直接用指针变量*arr接受 因为数组名就是一个地址(数组的传递是以数组中的首地址来进行传递的)
//{
//	//如果上方采用(int arr[],int k,int sz)的形式其实也是一样的 arr[]看起来是个数组 但里面放的也是指针 因为数组传递过来的就是首地址
//	//但是无论怎样写 sz的值都不能放在函数中进行计算 为什么呢?
//	//这是因为 传递过来的是数组的首地址 那么sizeof(arr)就是arr[]中首位元素所占的内存大小(int 类型占4)也即是sizeof(arr[0])
//	//那么如果sz让这两者相除 结果必然恒为1 left和right也就直接相等了 这显然是不合理的
//	//由此得出/！	我们无法在函数内部去计算一个函数参数部分中数组的大小或者元素个数！
//	int left = 0;
//	int right = sz - 1;
//	while (left <= right)
//	{
//
//		int mid = left + (right - left) / 2;//注意 该语句必须放在循环以内 否则mid就只会赋一次值 后续程序由于arr[mid]不变将陷入死循环
//		if (arr[mid] < k)
//		{
//			left = mid + 1;
//		}
//		else if (arr[mid] > k)
//		{
//			right = mid - 1;
//		}
//		else
//		{
//			return mid;
//			//下面之所以直接接return -1而不是再用一个if(left>right)是因为return优先级远高于break(只能跳出循环)
//			//如果条件满足 那么return在此处就可以直接终止函数(这也是为何此处不用接break)
//		}
//	}
//	return -1;//return -1是因为要做区别 -1绝不可能是返回的下标 但是0却可能是返回的下标
//}
//int main()
//{
//	int arr[] = {1,2,3,4,5,6,7,8,9,10};
//	int k = 0;
//	int sz = sizeof(arr) / sizeof(arr[0]);
//	scanf("%d", &k);//k为欲查找的数 显然k<=10;
//	if (search(arr , k , sz) != -1)//注意 当主体程序传过去数组时 无论哪种传递方式都只能在主程序这边写数组名 不能写arr[]
//	{
//		printf("找到了 下标是：%d\n", search(arr , k , sz));
//	}
//	if (search(arr , k , sz) == -1)
//	{
//		printf("找不到对应下标\n");
//	}
//	return 0;
//}

//有时 真假值的返回也可以采用布尔类型(需引入头文件<stdbool.h>)	例如：
//bool ion_even(int x)//这个函数用于判断是否是偶数(even number)，奇数的英文(odd number)
//{
//	if (0 == x%2)
//	{
//		return true;//也就是 1
//	}
//	return false;//也就是0
//}
////bool类型的返回值只有 true/false两种 这也使得相较于传统的1/0返回值 它显得更美观直接 同时减少了bug出现的可能(有时1/0不好用于返回真假值)
////但是因为它是C99标准之后的产物 同时功用有替代品 所以使用较少 但是若要提升代码可读性 也可以使用bool类型来代替传统的1/0返回真假值
//int main()
//{
//	int i = 0;
//	for ( i = 1; i < 10; i++)
//	{
//		if (ion_even(i))//此处根据布尔类型调用函数的返回值来作为判断依据
//		{
//			printf("%d ", i);
//		}
//	}
//	return 0;
//}

//写一个函数 每调用一次函数 num的值就+1
//第一种写法 传址调用
//int num_(int* p)
//{
//	(*p)++;//注意此处*p必须加括号 否则调用顺序会出错
//}
//int main()
//{
//	int num = 0;
//	num_(&num);//每调用一次 num_ num的值就会直接加一
//	printf("%d\n", num);
//	return 0;
//}
//第二种写法 传值调用
//int num_(int n)
//{
//	return ++n;
//}
//int main()
//{
//	int num = 0;
//	num=num_(num);//这种写法就是通过在函数中来进行++的操作后返回值又放到num中来实现要求的
//	printf("%d\n", num);
//	return 0;
//}

//函数的嵌套调用
//函数是允许互相调用的 但是不允许嵌套定义
//int ad(int x)
//{
//	return ++x;
//}
//int zs(int n)
//{
//	return ad(n);//这便是函数的嵌套调用 每一层函数之间依然是平等关系
//}
//int main()
//{
//	int i = 0;
//	zs(i);
//	printf("%d\n", zs(i));
//	return 0;
//}
//int add(int x, int y)
//{
//	return x + y;
//}
//int sub(int x, int y)
//{
//	return x - y;
//}
//接下来来看一种错误写法
//int add(int x, int y)
//{
//	return x + y;
//	int sub(int x, int y)//这种写法就是错误的了 因为函数不可以嵌套定义:一个函数中不能再去定义另外一个函数
//	{
//		return x - y;
//	}
//	//如果要实现函数的嵌套调用 至少对函数要先定义 再嵌套调用
//}
//int main()
//{
//	int x, y = 0;
//	scanf("%d %d", &x, &y);
//	printf("两数之和是 %d\n", add(x, y));//注意加减乘除的命名 加 addition 减 subtract 乘 multiply 除 divide
//	printf("两数之差是 %d\n", sub(x, y));
//	return 0;
//}

//函数的链式访问 (实现依赖于函数的返回值)
//链式访问 意为用前一个函数的返回值作为后一个函数的参数
//接下来看一个经典的链式访问
//int main()
//{
//	int i = 43;
//	printf("%d", printf("%d", printf("%d", i)));
//	//猜猜打印结果？
//	//为什么打印结果为4321？
//	//需要知道 printf函数的返回值是 打印字符的数目
//	//根据链式访问原理 最内层的printf返回值--打印字符(43)的数目--2 作为中间printf返回值--打印字符(2)的数目--1 又作为最外层printf打印值
//	//由此 得到了43 2 1的数据
//	return 0;
//}
//注意 当函数不写返回类型时 系统默认返回int型 但这是很不规范的代码 
//同样也不要有返回类型的函数结果不返回值(此时大部分编译器会默认返回函数中最后一条指令执行的结果) 这些都是不规范的代码写法
//注意一下的写法
//int main(void)//这里的void写法并没有错 只是想明确说明 main函数不需要参数 以避免有些ide错误地给main放置了参数
//	//事实上 main有三种参数: int argc,char *argv[],char *envp[] 这三种参数都有实际意义 只不过一般情况下编译器默认main是不需要参数的
//	//但是这种被默认的执行程度会稍弱于明确强调void 只是说在大多数情况下我们无需担心这一点 所以可以直接省略void
//{
//	printf("hehe\n");
//}

//函数的声明和定义：
//函数声明就是告诉编译器有一个什么样的函数是长什么样的 但是这个函数是否真的存在 函数声明决定不了(需要函数的定义)
//并且函数的声明一般出现在函数的使用之前 要满足先声明后使用 如果将函数声明放在使用后面 编译器就会报一个警告"函数...未定义..."(能运行但是)
//函数的声明和函数的主体可以分开
//比如 可以先在主函数之前写 int ion_prime(int x) 但是函数主体可以放在主函数之后写
//函数的声明一般要放在头文件中的
//函数的定义是指函数的具体实现，交代函数的功能实现
//我们知道
//int ion_prime(int x);//这是函数的声明
//接下来这一块是函数体 函数体和函数所声明的部分的组合才是函数的完整定义
//{
//	for (int i = 2; i < sqrt(x); i+=2)
//	{
//		if (0 == x%i)
//		{
//			return 1;
//		}
//	}
//	return 0;
//}
//接下来具体阐述为什么说函数的声明一般要放在头文件中
//总结起来就是：
//1_为了模块化和可维护性： 
//将函数声明放在头文件中可以帮助代码模块化，使代码更易于维护。通过在头文件中声明函数，可以清晰地了解库或模块提供了哪些功能，以及如何使用它们。
//2_为了避免重复定义：
//如果不使用头文件，当在多个源文件中引用相同的函数时，每个文件都会包含相同的函数声明，这可能导致重复定义错误。使用头文件可避免这种情况，因为源文件只需要包含一次头文件即可。
//3_为了便于扩展： 
//如果要更新函数原型，只需更新一次头文件，所有引用该函数的源文件都会受益于更新，而无需逐个修改。
//事实上 当我们进行真正的程序开发时
//为了更好地进行团队协作以及实现模块化开发 我们往往是将一个程序分为多个源文件同时进行开发的 在最后才实现程序的整体封装
//而这时如果我们要自定义一个函数 我们常常将这个函数的声明放到一个头文件中去 然后再将函数的定义部分放到另外一个源文件中去
//只要我们需要调用这个函数 我们就只需要写下	例如#include"ion_prime.h"	这个程序就会根据这个引用头文件中的声明找到对应函数的定义
//然后对这个函数进行实现
//意义?
//这里简单介绍一种情况下将自定义函数的声明和定义分开放在不同文件的意义
//当程序员A写了一个APP时 他想将该APP卖给B公司赚钱 但是他又不能直接将源码一股脑都交给B公司(可能代码被对方骗到手后就翻脸不认人了)
//于是他可以选择将自定义函数的声明放在一个头文件中 再将定义放在另一个源文件中 含有主体程序的源文件就不涉及到该函数定义部分了
//然后将含有函数定义的项目fun(含fun.h)编译成静态库fun-->fun.lib 静态库中都是二进制编码 很难轻易被反编码为原先的代码
//这时他再将该静态库和对应的fun.h以及主体源文件一同卖给B公司即可 B公司通过fun.h(函数声明)就可以了解到该函数是如何使用的
//然后B公司再在主源文件中导入静态库: #pragma comment(lib,"fun.lib")  后就可以正常使用该程序中的函数了(虽然他无法得知函数具体是如何实现的)
//可以看到这种处理方法 极大地保护了代码的安全 同时满足了代码对于迁移使用的需要


//！！！ 函数的递归
//递归是程序调用自身的编程技巧 只需要少量的代码就能描述出多次重复的计算 递归的主要思考方式就是：大事化小
//实现递归的两个条件
//1_存在限制条件 当满足限制条件后 递归函数就不再继续
//2_每一次递归调用之后都会越来越接近这个限制条件
//引入... 请写出一段代码 使得它能接受一个整型值(无符号),并按照顺序打印它的每一位 如输入1234 打印 1 2 3 4
//int main()
//{
//	//unsigned int a1,a2,a3,a4= 0;
//	//scanf("%1u %1u %1u %1u", &a1, &a2, &a3, &a4);//输入 1234		//%1u表示每次只读入一位数据并依次存储到对应的变量中去
//	//printf("%u %u %u %u\n", a1, a2, a3, a4);//打印1 2 3 4
//	//这是由前面的关于打印格式的知识所知的 但很显然 当输入123时这段代码便不能正常运行了 
//	//于是我们想到了取模运算
//	unsigned int a = 0;
//	scanf("%u", &a);
//	while (a)//通过a的值来作为判断依据 最后a=0则跳出循环
//	{
//		printf("%d ", a % 10);//通过取模运算 得到每个数的尾数
//		a = a / 10;//再通过除法运算(整数除法 最后得到的数必是0) 将每次除后的整数部分赋给a(其实也就是a的前几位)
//	}//但是这样打印的结果是倒过来的:< 咋办捏
//	//简单粗暴的思路:把每次取模得到的值放到另一个创建的数组中去 然后再从末尾往前用一个for打印(每次i--)即可
//}

//下面这种对于取模的妙用也是可以实现的 别称 首位剥离法 而上面的思路是末尾剥离法 这两种是常见的对于取模的化用 合成首尾剥离法
//int main()
//{
//	unsigned int num = 0;
//	scanf("%u", &num);
//	int temp = num; //temp用于保存原始值
//	int count = 0; //count用于计算数字的位数
//	while (temp > 0) 
//	{
//		temp = temp / 10;
//		count++;
//	}
//	temp = num;
//	for (int i = count - 1; i >= 0; i--)
//	{
//		int j = pow(10, i);//调用pow需要包含<math.h> pow(a,x)的返回值是a^x次幂
//		printf("%d ", temp / j);//首位剥离法<打印的是除法结果 末尾剥离法却是取模结果> 依次是--> 1 (234) ->2 (34) -> 3 4 ->4
//		temp = temp % j;// temp-->以1234为例 temp=1234->234->34->4
//	}
//	return 0;
//}//不过如果我们还是想要让思路和代码呈现更简洁的话 那接下来就要请出今天的主角--递归函数了

//！！！递归函数的中心思想-->大事化小 一个递归函数的实现代码往往不会超过6行！
//void print_order1(unsigned int n)
//{
//	if (n>9)//规则一 递归函数需要有限制条件<这个条件是为了当n的位数减小到个位时及时停下 不至于停下过早 也不至于过晚>
//		//每次调用函数都会在栈区申请空间 如果没有这个限制条件递归函数就会一直递进深入 最后出现Stack overflow(栈溢出) 最终程序崩溃!
//	{
//		print_order1(n / 10);//规则二 每一次递归调用都会更接近这个限制
//	}
//	//捋捋思路：
//	//递归要将大事化小 前面我们采用末尾剥离法时 发现该思路是可行的就是顺序有误
//	//如果我们可以让数据从小到大<1 12 123 1234>的顺序挨个取模<1 2 3 4>的顺序就出来了
//	//而递归函数的作用就是将数据由大化小(通过不断调用函数本身 但是执行不同n值的整数除法来实现 直到个位数为止)
//	//此时数据已经按照由小到大的层级排好了<1位 12位 123位...>然后我们再让其每一层都取模并且打印一次然后一层层回归到外层函数即可
//	//其中规则一是当n是个位数时就不再继续递归<限制> 规则二是每一次递归都会让这个数的位数减少一 该数也会不断逼近个位数
//	//这 就是递归函数！！！ 
//	//递归递归 其实就是两个部分 -->先递进深入 再回归向上
//	printf("%d ", n % 10);
//}
//int main()
//{
//	unsigned int num = 0;
//	scanf("%u", &num);
//	print_order1(num);//这里命名为print_order1意为 这个函数的功能就是print 但要按照order 每次打印 1 个 即print_order1
//	return 0;
//}

//接下来 我们来试着实现以下 strlen 函数 即计算字符长度
//int my_strlen(char* p)//这里用数组形式作为形参也行 即 char brr[]也可以
//{
//	int count = 0;
//	while((*p) != '\0')//这里之所以能够直接比较字符而没有调用strcmp是因为根据指向地址直接用字符本身<'a'...>来比较了(本质ASCII码值)
//			//而之前比较字符数组和 "abc123"是否相等 因为涉及到调用数组内所有字符这么一个过程 才需要用到strcmp函数
//			//事实上 普通的字符(串)都可以直接进行比较的！
//	{
//		count++;
//		p++;
//		//这里的指针p++与常规++不同的是 原本p中存放的是arr[0]的地址 p++后就直接将其中的地址更换为arr[1]的地址了
//		//也就是说p++对应的其实是arr[0]->arr[1]  p指针指向的对象也就成了数组中第二个字符了
//		//注意！无论这个指针指向的对象是什么类型 或者说这个数组是什么类型 p++的效果都是如此 这是语法规定的！
//	}
//	return count;
//}
//int main()
//{
//	char arr[] = "abc";
//	int c = my_strlen(arr);
//	printf("%d\n",c);
//	return 0;
//}

//如果这个题目 是 在不创建临时变量的情况下 模拟实现strlen函数
//注意 以上方法的my_strlen函数中实际上创建了 count这个用于计数的临时变量 如何在不创建临时变量的情况下实现？
//int my_strlen(char* arr)
//{
//	if (*arr != '\0')//递归的限制
//	{
//		return 1 + my_strlen(arr+1);//每一次递归都会更接近该限制 这是递归的必备条件！！！
//		//注意 这里千万不能用arr++;arr++会陷入死递归！ 推荐写为arr+1 因为++arr改变了arr的值 arr+1只是改变了函数识别到的地址
//		//递归 如果首元素不是'\0';就返回1 并且进入下一个递归函数中 如果该递归到下一层仍然不是'\0'开头就再+1 反之+0
//		//再注意！ 递归调用的过程中往往是单向完成任务的 此处在递进深入的过程中 my...函数一直都没有+1! 直到回归向上时才开始+0 +1..
//	}
//	else
//	{
//		return 0;//注意！这里的返回0 并不是整个函数的返回值 而是递归每一层加减值的区别 思路是 用1+my...再1+1+my...直到首元素为'\0'
//	}
//}
//int main()
//{
//	char arr[] = "abc";
//	printf("%d\n", my_strlen(arr));
//	return 0;
//}
//这就满足了不创建临时变量的条件

//递归与迭代...
//迭代就是重复 循环就是一种迭代  来看看两者区别
//还是欲求 n的阶乘
//int ite(int m)//迭代的英文描述 iteration
//{
//	int i = 0;
//	int j = 1;//j用于存放阶乘值
//	for (i = 1; i <= m; i++)
//	{
//		j = j * i;
//	}
//	return j;//j初始化为1 这很重要 因为要包含 m=0时阶乘要返回1
//	//这里和递归一样 采用数学思维 将阶乘看作 i<=1;i>2两部分 只不过这里的for循环能将两者都包含其中
//}

//int rec(int n)//recursive function是递归函数的英文 这里取rec为递归函数的代表
//{
//	if (n <= 1)
//	{
//		return 1;
//	}
//	else
//	{
//		return n * rec(n - 1);
//	}
//}
//int main()
//{
//	int n = 0;
//	scanf("%d", &n);
//	//int ret = rec(n);
//	int ret = ite(n);
//	printf("%d\n", ret);
//	return 0;
//}//在这种情况下 似乎递归更加地小巧实用 但是也并不是所有情况都如此！

//求斐波那契数列输入为n的值 不考虑溢出
//斐波那契数列：1 1 2 3 5 8 13 21 44
//即 当n>2时 n=(n-1)+(n-2);
//用递归来描述依然思路简洁：
//int rec(int i)
//{
//	if (i > 2)
//	{
//		return rec(i - 1) + rec(i - 2);//但是这里却出现了问题 当输入n=50时 程序计算了很长时间 以至于半天加载不出来 这是为什么?
//		//当存在多递归模型时 函数很容易存在大量重复的计算量
//		//此处双递归 当输入 n=50时 对应：
//		//return rec(49)+rec(48)... 49+48 48+47... 48+47 47+46 47+46 46+45... 以此类推 越到递进深处 重复的计算量越大(千万级以上)
//	}
//	else
//	{
//		return 1;
//	}
//}

//对应迭代写法则不会如此复杂地计算 但是代码量也随之增加了
//int ite(int n)
//{
//	/*int a = 1;
//	int b = 1;
//	int c = 0;
//	if (n>2)
//	{
//		for (int i = 3; i <= n; i++)
//		{
//		c = a + b;
//		a = b;
//		b = c;
//		}
//		return c;
//	}
//	return 1;*/
//	//或者 while: --类
//	int a = 1;
//	int b = 1;
//	int c = 1;//c赋值为1是为了将n=0，1时包含其中---直接返回c=1即可
//	while (n >= 3)
//	{
//		c = a + b;
//		a = b;
//		b = c;
//		n--;
//	}
//	return c;
//}
//int main()
//{
//	int n = 0;
//	scanf("%d", &n);
//	//int ret = rec(n);
//	int ret = ite(n);
//	printf("%d\n", ret);
//	return 0;
//}

//由此引出一个问题 何时采用递归 何时又采用迭代？
//当可能要调用多递归模型时 请谨慎使用递归函数以避免大量重复计算;
//很多时候我们只是运用递归的思路来解释问题 以使思路更清晰 但是这些问题的迭代实现往往效率更高 只是可读性稍差
//当一个问题相当复杂 难以用迭代实现时 此时递归实现的简洁性可以来弥补它运行时产生的开销
//但其实 哪怕不进入死递归 递归函数仍然可能导致栈溢出！ 如何解决？
//1_简单粗暴 尽量使用非递归函数替换递归函数
//2_使用static对象替代局部变量 
//这不仅可以减少每次递进和返回时产生局部变量对栈区的消耗 而且静态常量还可以保存递归调用的中间状态 便利地为各个调用层所访问


//用代码将三个整数按从大到小来输出(不使用含数组的排序手法)
//void exch(int* px, int* py)//这里传址调用是为了直接对 a b c进行修改 使其分别按大小对应一二三顺位
//{
//	int ord = *px;//注意 如果想交换两个数的值 一定要有第三个数来放置其中一个数值 否则两者交换后其实是相同值
//	*px = *py;
//	*py = ord;
//}
//int main()
//{
//	int a,b,c= 0;
//	scanf("%d %d %d", &a, &b, &c);
//	if (a<b)
//	{
//		exch(&a, &b);
//	}
//	if (a<c)
//	{
//		exch(&a, &c);
//	}
//	if (b<c)
//	{
//		exch(&b, &c);
//	}
//	//为什么只有a<b;a<c;b<c三种？因为a>b;a>c;b>c;这三种情况是符合最后打印的大小次序的 不需要互相交换数值 也就无需列出！
//	printf("%d %d %d", a, b, c);
//	return 0;
//}


//给定两个数，求这两个数的最大公约数？
//思路：从两数的较小数开始递减 直到一个数可以同时整除两个数 则该数就是最大公约数
//1_从较小数开始 因为能同时整除两个数的必然要小于最小数 否则对于最小数而言连1倍都达不到
//2_采用递减而不是递增 也是为了节省时间和内存调用 因为题目要求找到最大公约数 递减得到的第一个公约数必然就是最大的
//int main()
//{
//	int a, b = 0;
//	scanf("%d %d", &a, &b);
//	int min = (a < b ? a: b);//这里使用了三目操作符
//	//注意 求两数之中的较大或较小数 都可以使用三目操作符来快捷地实现 如果求max就写作a>b 反之min就写作a<b
//	int m = min;
//	while (1)
//	{
//		if (a%m == 0 && b%m == 0)
//		{
//			break;
//		}
//		m--;
//	}
//	printf("最大公约数是：%d\n", m);
//	return 0;
//}//这样的实现方法简单粗暴 但是计算冗余 思考一下是否有更优算法？

//接下来介绍辗转相除法：
//辗转相除法，又称欧几里得算法，适用于计算最大公约数
//(a,b)->(b,r)->(b',r')->(b",r")->...0	（a,b）表示a模b，设结果为r，然后继续以b为被除数计算(b,r)...直到(b^n,r^n)==0为止
//这时得到的r^n就是最大公约数
//原理 a==q*b+r 则r==a-q*b 设a==m*u b==n*u 则u即为a,b公约数 r==a-q*b==u*(m-n*q)==u*v 易得v必为整数 所以u也就是[a,b,r]的公约数
//也就是说[a,b] [b,r] 的公约数是完全一致的 当一直取模运算到r^n时,[b^n,r^n]的公约数u^n就是r^n 因为r^n能同时整除b^n和它本身
//又因为公约数不能大于两数任一一个 所以r^n就是[b^n,r^n]的最大公约数 又因为[a,b],[b,r] 的公约数是完全一致的所以后者的最大公约数也是前者的最大公约数
//得证！
//程序实现：

//int main()
//{
//	int a, b = 0;
//	int r = 0;//r用于计算模 同时将数值赋给下一次计算模时的b
//	scanf("%d %d", &a, &b);
//	while (r=a%b)//r在此处还用作判断条件 当r==0时退出循环并打印b（也就是r^n）的值
//	{
//		a = b;
//		b = r;
//	}
//	printf("最大公约数是：%d\n", b);
//	return 0;
//}
//这种算法肉眼可见的简洁:> 事实上这种涉及到数论的算法还有很多 比如如何求最小公倍数? 后面在数据结构与算法分析的学习中便会涉及到

//求十个数中的最大数？（非排序问题）
//思路 打擂台 ---用到了冒泡排序的一些思想
//假定第一个数据最大 将其放入到一个变量后让其与后续数据遍历比较 若后者大 则更新变量值 当循环结束 即可得到最大值
//int main()
//{
//	int arr[10] = { 0 };
//	//注意 如果写作arr[] 那么数组向内存申请的大小就取决于{}中的数据数 此时的{0}会被处理为存放一个数据(0)而不是对数组的初始化
//	//此时对于arr[2...10]都是越界访问了 栈区中的数组存放结构就会被破坏 程序报错
//	int i = 0;
//	for (i = 0; i < 10; i++)
//	{
//		scanf("%d", &arr[i]);
//		//此处若不采用数组来循环读入数据 则代码量冗余了 所以采用数组+循环是更方便的做法
//		//还需注意 当涉及到数组中具体的元素时 arr[i]就不是地址了 而是对应下标的元素 那么此时就需要用取地址符
//	}
//	int max = arr[0];//max为最大值 此处假定为第一个数据的值
//	for (int n = 1; n < 10; n++)
//	{
//		if (arr[n]>max)
//		{
//			max = arr[n];
//		}
//	}
//	printf("最大数是：%d\n", max);
//	return 0;
//}

//打印9*9乘法表
//首先 观察9*9乘法表
//1*1=1
//2*1=2 2*2=4
//3*1=3 3*2=6 3*3=9
//4*1=4 4*2=8 4*3=12 4*4=16
//...
//可见乘法表主体是两个变量：
//i		*j [j<=i]
//1		*1
//2		*1 *2
//3		*1 *2 *3
//...
//故函数的实现可以是
//int main()
//{
//	int i = 0;//i是左边的第一个数，也是行数
//	for ( i = 1; i < 10; i++)
//	{
//		for (int j = 1; j <= i; j++)//这里j必须是<=i(i为几则j乘到几)而不能是<=10 否则1~9每个数都会自乘1~9 就会产生大量重复
//		{
//			printf("%d*%d=%2d ", i, j,i*j);
//			//用%2d是为了让前面乘出的一位数和后面的两位数对齐 2是数据在打印时至少要占的宽度 +2表示右对齐2宽度 -2表示左对齐2宽度
//			//这里的%2d后面必须要留有空格 否则单数位和双数位对齐后 前面的结果会和后面的乘数粘连 影响观感
//			//此外 这里必须要用一个变量来对应这个%2d所占的位置 否则传参不够，导致打印时原本对应的乘积全部打印错误
//		}
//		printf("\n");
//		//如果在内层for的printf中加入\n 将导致每打印一个i*j(如2*1=2)后立刻换行 但我们所需要的是每打印完一行i*1 2...i之后再换行
//	}
//	return 0;
//}
//补充：打印一个由输入值决定打印行数的9*9乘法表
//其实只需要让第一层函数的i<=n即可 n为输入的值


//一道重要的回顾题：
//把函数处理结果的两个数据都返回给主调函数，下列做法不正确的是？
//1_return这两个值	 2_形参用数组	3_形参用两个指针	4_用两个全局变量
//答案为1 下面分别举例进行分析

//1_return:
//int func()
//{
//	return 3, 4;//return (3, 4);
//	//这两种写法编译器都不报错并且由于都是逗号操作符 返回值都是4！
//}
//int main()
//{
//	int ret = func();
//	printf("%d\n",ret);//只打印了4 因为return 3,4时 由于逗号操作符是将表达式从左到右依次计算后取最后的结果 所以取4作为返回值
//	return 0;
//}//由此可见 return 两个值 这种写法并没错 但是编译器只会返回一个值 换句话说return 只能返回一个值;

//2_形参用数组:
//void func(int arr[])//这里的arr[]其实就是指针
//{
//	arr[0] = 3;//这里的arr[0]其实是*(arr+0)
//	arr[1] = 4;//arr[1]即*(arr+1) 注意arr是数组首元素的地址 +1是直接指向数组中下一个元素地址的
//	//可见 当函数参数是数组时 其实就是传址调用 因此函数中对arr[0]和arr[1]赋值就是对arr数组本身的元素进行赋值
//}
//int main()
//{
//	int arr[2] = { 0 };
//	func(arr);
//	printf("%d %d\n",arr[0],arr[1]);//3 4 
//	return 0;
//}

//3_形参用两个指针
//void run(int* px,int* py)
//{
//	*px = 3;
//	*py = 4;
//}
//int main()
//{
//	int a, b=0;
//	run(&a, &b);
//	printf("%d %d\n", a, b);
//	return 0;
//}//这更简单明了了 直接就是传址调用

//4_用两个全局变量
//int a, b = 0;//这里的a,b的定义在dun main函数之前 是为全局变量
//void dun()
//{
//	a = 3;
//	b = 4;//这里分别对a,b进行赋值
//}
//int main()
//{
//	dun();//由于全局变量的作用域是整个程序 所以调用dun函数后 dun函数中对于a,b的赋值在整个程序中都是可以生效的
//	printf("%d %d\n", a, b);//3 4
//	return 0;
//}


//数组
//数组的概念
//数组是一组相同类型元素的集合，数组的产生便于我们去存放一组数据
//数组中存放的是1个或者多个数据 但是不能是零个！
//随着数组下标的由小到大 地址由低到高
//数组分一维数组和多维数组 二维数组是最常见的多维数组

//一维数组的创建和初始化
//创建的基本语法： type arr_name[常量值] type为数组类型 也是数组中存储的元素的类型
//注意 在C99标准之前是不允许[]中放置变量的 但是在C99标准后[]中允许放置变量 也就是说支持了变长数组：数组的长度(大小)由变量大小来决定
//而数组中的元素也是在确定变量值后再输入或者给定的
//不过VS编译器是不支持变长数组的，而别的一些编译器如linux环境下的GCC编译器是支持的
//还需要提醒 变长数组的变量值未确定前 是不能初始化的 只能进行声明:	int arr[n];
//因为n不给定之前数组是不会向内存申请空间的 也就无法初始化
//数组的初始化指，在创建数组的同时给数组的内容一些合理初始值
//区分不完全和完全初始化！
//int arr[10] = {1,2,3}; 这就是不完全初始化，剩余的元素默认初始化为0
//区分{}和""
//char ch1[10] = ={'a','b','c'}; 补齐七个默认初始化为0的元素
//char ch2[10] = "abc";补齐默认六个初始化为0的元素 因为存在\0
//int main()
//{
//	char arr[4] = "abc";//注意这和下面的写法效果是一样的 不要因为"abc"写在一起而理解搞混 实际上arr[0]就是a arr[1]就是b...
//	char brr[3] = { 'a','b','c' };
//	printf("%c %c %c\n", arr[0], arr[1], arr[2]);
//	printf("%c %c %c", brr[0], brr[1], brr[2]);
//	return 0;
//}
//数组的大小是可以计算出的 int sz=sizeof(arr)/sizeof(arr[0]) 同样的 使用sz可以用于循环打印arr[0]到arr[sz-1]..即数组内所有的元素

//一维数组在内存中的存储
//%p可以打印地址（16进制形式） 如下
//int main()
//{
//	int arr[] = { 1,2,3,4,5 };
//	int i = 0;
//	int sz = sizeof(arr) / sizeof(arr[0]);
//	for ( i = 0; i < sz; i++)//<sz也就是 <=sz-1;
//	{
//		printf("&arr[%d]=%p\n", i, &arr[i]);//%p打印地址 这里对应地用&来打印arr[i]的地址
//	}
//	return 0;
//}
//结果分析:
//&arr[0] = 000000EA616FF568
//&arr[1] = 000000EA616FF56C
//&arr[2] = 000000EA616FF570
//&arr[3] = 000000EA616FF574
//&arr[4] = 000000EA616FF578
//每个地址大小相差四 因为该数组为整型数组 一个整型占4个字节 而该地址是4个字节中占首字节空间的地址
//结论：数组在内存中是连续存放的; 随着下标的增长，地址是由小到大，由低到高的顺序变化的

//二维数组
//总结：二维数组其实就是一维数组的数组，二维数组的每一行都是一个一维数组 而这一行一维数组又是二维数组的元素！！！
//定义：
//type arr_name[常量值1][常量值2]; 其中常量值1代表行 常量值2代表列
//int main()
//{
//	//完全初始化：
//	int arr[3][5] = { 1,2,3,4,5,2,3,4,5,6,3,4,5,6,7 };//联想三行五列矩阵
//	//该二维数组其实就长这样：可以用调试监视窗口查看对应值
//	/*	0 1 2 3 4
//	0	1 2 3 4 5
//	1	2 3 4 5 6
//	2	3 4 5 6 7*/
//	//每一行编译器会自动找5个数据填充为1行 它也就等价于 int arr[3][5] = {{1,2,3,4,5},{2,3,4,5,6},{3,4,5,6,7}};
//	//也可以不填充满，也就是不完全初始化，如
//	int brr[3][5] = {{1,2},{3,4},{5,6}};//编译器会自动填充每行的剩余数据为0！即:{{1,2,0,0,0},{3,4,0,0,0},{5,6,0,0,0}}
//	//同时通过监视窗口我们可以看到brr中存放的就是{1,2,0,0,0}的地址 也就是说二维数组对应的地址依然是首元素的地址
//	//这里可以类比于集合的概念 {{},{}...} 第一个{}整体是首元素
//	//还要注意！二维数组等多维数组都只能省略掉行（第一维） 不能省略掉后面的部分
//	//因为编译器可以在没有第一维的情况下根据后面维度的需求填充好完整的多维数组 但是没有第二维 第三维..则不行！
//	//以arr[2][]={1,2,3,4,5,6}为例 它有无穷多种可能情况
//	/*	0 1...n
//	0	
//  1	
//	n>4时第二行为全零行*/
//	int crr[][4] = { {1,2,3,4},{5,6} };//编译器会自动将其补齐为：
//	/*	0 1 2 3
//	0	1 2 3 4
//	1	5 6 0 0*/
//	return 0;
//}


//二维数组的访问:
//int main()
//{
//	int arr[3][3] = { {1,2,3},{4,5,6},{7,8,9} };//注意 定义为[3][3]但是下标访问范围依然是0~2;0~2！！！
//	printf("%d\n", arr[0][2]);//打印第一行第三列的数据
//	for (int i = 0; i < 3; i++)//需要注意这里的i和下面的j的边界值 三行三列所以<3 因为下标引用是从零开始的
//	{
//		int j = 0;//j每次都要从零开始 故每次i循环都必须要初始化一次j=0;
//		for ( j = 0; j < 3; j++)
//		{
//			printf("%d ", arr[i][j]);
//		}
//		printf("\n");//类比于9*9乘法表那里的外层换行操作 借以实现每循环完一次i就换行
//	}//这个嵌套循环是访问二维数组最常见的方法
//	return 0;
//}

//二维数组在内存中的存储
//因为二维数组是一维数组的数组 每一行都是一个一维数组 而且一个一维数组又都是二维数组中的一个元素 数组在内存中的存储又都是连续的
//由此可得 二维数组在内存中的存储也都是连续的并且是以一维数组的存储长度为单位的 第一行接着第二行...第一个一维数组接着第二个...
//int main()
//{
//	int arr1[6] = { 1,2,3,4,5,6 };
//	int arr2[3][2] = { {1,2},{3,4},{5,6} };
//	//由监视窗口可知 这两者在内存中的存储其实是一样的 arr的地址都是首元素地址 而每个元素都对应一个地址
//	//只是arr1地址是arr[0]的地址 而arr2地址是arr[0][0~1](->即第一个一维数组)的地址 同时每个元素又都对应一个一维数组的地址罢了
//	return 0;
//}

//数组越界
//数组的下标是有范围限制的 假定有n个元素 则范围：0~n-1
//超出这个范围都属于越界访问 这里需要注意的是：C语言和编译器不会做数组下标的越界检查 但是不报错不意味着程序就是正确的
//所以程序员在写代码时最好自己做越界的检查
//特别注意一下多维数组的越界访问
//以二维数组为例 行越界和列越界是不同的 行越界时是直接越界访问到随机值 但是列越界时会正常访问前面的数据 直到数组中数据访问完才访问随机值
//这是因为二维数组在内存中的的存储是arr[0][0~n]紧接着arr[1][0~n].. 因此当列越界时数据访问会继续访问到下一个一维数组中的数据
//当且仅当数组访问完整个二维数组的数据后才会越界访问随机值直到结束 


//数组的一些常见用例
//1_数组作为函数参数: void func(int arr[]) 这里的数组arr[]就是作为函数参数的用法 实际上这和int* arr是一样的 都是指针
//只不过用数组作参更利于理解 毕竟实参是数组 形参也用数组表示更利于理解
//接下来我们用数组作参来写一个貌似常见的函数...>>>以实现冒泡排序
//冒泡排序算法核心：用相邻的两个元素进行比较！  因为数的上浮过程类似于汽水饮料的冒泡 因此得名
//现有：9 8 7 6 5 4 3 2 1 0 请将其改为升序
//升序冒泡思路：
//9>8 则9和8交换位置..9>7则9和7交换位置..直到换位置到末尾 也就是最大数对应的位置后这一趟冒泡才结束
//紧接着这时第一个元素就是8了 8重复9的操作..交换到倒数第二位后即可停止第二趟冒泡(因为它不是最大数,这是第一趟冒泡后的结论)
//然后是7...1 当1这一趟冒泡结束后整个冒泡排序就结束了 因为最后一个元素是被其他元素筛选了的 必然是最小的
//所以得出结论:n个元素的冒泡排序趟数=n-1趟 ！
//补充结论:在一趟冒泡排序中若有n个元素需要排序 则比较数=n-1 因为第一个数不需要和它本身进行比较 所以比较数会减一！
//而升序排序每一趟由于最后面的数据会相继确定(从后往前) 导致每一趟冒泡中需要比较的元素数目也是递减的 即n-1-1-1...
//有了上面的理论知识 我们来实现一下冒泡排序吧！
//int main()
//{
//	int arr[10] = { 9,8,7,6,5,4,3,2,1,0 };
//	int sz = sizeof(arr) / sizeof(arr[0]);
//	for (int i = 0; i < sz-1; i++)//i<sz-1?
//	{
//		int flag = 0;
//		for (int j = 0; j < sz-1-i; j++)//j<sz-1-i?
//		{
//			int c = 0;
//			if (arr[j]>arr[j+1])
//			{
//				c = arr[j];
//				arr[j] = arr[j+1];
//				arr[j+1] = c;
//				flag = 1;
//			}
//		}
//		if (0==flag)//flag?
//		{
//			break;
//		}
//	}
//	for (int n = 0; n < sz; n++)
//	{
//		printf("%d ", arr[n]);
//	}
//	return 0;
//}
//上面有三个问题 接下来一一解答：
//1-->>	i<sz-1?
//这里的i是冒泡排序的趟数 由前面的结论可知i的范围是[1,n-1] 因为i从0开始 所以还需要减一 即i[0,n-2];
//又因为<=n-2 和<n-1是等效的 所以写作i<n-1 注意 这种替换非常常见 因为在编程规范中我们会尽量少用<=这种写法
//2-->> j<sz-1-i?
//j用于表示一趟冒泡排序中的比较次数 在升序排序中 数据是从后往前一个个确定的 所以j每次都要从零开始 但是j的上限递减直到0
//由上面的补充结论 一趟冒泡排序有n个元素时 比较数是n-1 而且随着冒泡的趟数增加 比较数是递减的
//所以这里j<sz-1(等效于j<=sz-2，因为j也是从0开始) j的上限sz-2就是第一趟时的比较数 但是如何表示出j随冒泡趟数增加的递减特性?
//我们注意到 i的上下限=j的上下限 只是前者递增后者后者递减 那么我们就可以试着用上限-i来表示j的递减
//当i加1时j=上限-i也对应减一 当i到达上限时j也到达下限 同时因为i表示趟数 也完美契合了j随冒泡趟数增加而递减的特性
//所以我们用i来实现j每一趟冒泡时的递减 也就是j<sz-1-i 这样就不用再设置一个变量了
//3-->> flag?
//这里由于9,8,7..是完全逆序的 所以冒泡会一直进行到最后一个数 但有时一堆数据中只有部分数据是逆序的
//所以我们使用flag作一个标志变量 当数据中最后一个逆序的数被纠正时 下一趟冒泡就不会进入交换的if语句中 flag也就不会被赋值为1
//那么此时我们就可以用if(flag==0)..break;来跳出循环 避免后续继续无效循环浪费运行时间和内存空间
//事实上 我们常常将冒泡排序写作函数(名Bubble_sort:冒泡排序翻译)的形式独立于主函数之外 这样可以随时调用冒泡排序
//但是千万注意！当传递数组到函数中去时 函数不能进行数组大小以及数组元素个数(sz)的计算 前面已经解释过：函数中的sz恒等于1(x86)或2(x64)

//数组名
//我们常说：数组名就是首元素地址 事实上这并不完全正确
//存在两个特例：
//1_sizeof(数组名) 此时数组名代表的是整个数组的地址 而sizeof计算的也就是整个数组地址的大小;
//2_&数组名，这里取数组地址表示的是取出整个数组的地址 单位是字节

//int main()
//{
//	int arr[10] = { 0 };
//	printf("%zu\n", sizeof(arr));//40=10*4 这就是第一个特例 
//	return 0;
//}

//int main()
//{
//	int arr[10] = { 0 };
//	printf("%p\n", arr);//结尾08
//	printf("%p\n", &arr[0]);//结尾08
//	printf("%p\n", &arr);//结尾08
//	printf("----------------\n");
//	//这三个打印出来结果完全一致？ 一二相同容易理解 因为数组在非特例情况下就是首元素地址 但是为何第三个也是相同的？
//	//这是因为取出整个数组的地址时 这个"整个数组的地址"仍然是用首元素地址来代表的 但是这不意味着它就和前两者是一样的 理由：
//	printf("%p\n", arr + 1);//结尾0C
//	printf("%p\n", &arr[0] + 1);//结尾0C
//	printf("%p\n", &arr + 1);//结尾30
//	//按16进制计算 0C的十进制是12 08的十进制就是8 前者比后者多4个字节 说明arr+1和&arr[0]+1都是从数组的首元素地址跳到下一个元素地址
//	//但是30的十进制是48 而48-8=40 40/4=10(个整型数据的内存大小)也就是说&arr+1是直接跳到了整个数组后面的下一个内存地址
//	//从这儿就可以看出来 虽然打印&arr时仍然打印的是首元素地址 但是本质上和前二者是完全不同的	这就是特例二
//	return 0;
//}

//由此也再次印证了不能在函数里计算数组大小和元素个数 因为非特例情况下数组名就是首元素地址
//也就是说数组传参时传的是首元素地址-->>即一个指针 
//那么sizeof(arr)就恒等于8(x64中一个指针占据8字节大小) 而不是整个数组的大小 所以不能在...

//二维数组名的理解
//int main()
//{
//	int arr[3][4] = { 0 };//总共12个整型数据
//	int c = sizeof(arr);
//	printf("%d\n", c);//48=12*4 可见arr的大小就是整个二维数组的元素所占的大小
//	printf("%p\n", arr);
//	//非两个特例下二维数组的数组名也表示首元素的地址名 并且由前面知识点可知 二维数组的首元素是第一行的一维数组
//	//虽然打印一维数组地址时又用首元素arr[0][0]的地址来代表 但是注意分清楚本质
//	//在一维数组中 我们需要计算元素个数时采用的数组大小/首元素大小的做法
//	//那么在二维数组中 我们就可以用二维数组大小/首个元素(一维数组)大小来计算
//	int d = sizeof(arr) / sizeof(arr[0]);//这里是第一个特例 sizeof(数组名)计算整个数组大小 arr[0]代表第一行对应一维数组的大小
//	printf("%d\n", d);//3
//	//同理 我们还可以计算二维数组的列数=二维数组中中一维数组的的元素个数
//	int e = sizeof(arr[0]) / sizeof(arr[0][0]);//这里其实就是一维数组元素个数的计算方式 只是arr变成了arr[0] arr[0]变成了arr[0][0]
//	printf("%d\n", e);
//	//sizeof返回类型是size_t(无符号整型) 打印时应该使用%zu来打印 但是如果用一个int(有符号位)变量来接收 编译器是不会报警告的 
//	return 0;
//}


//2_三子棋的实现
//思路:
//1_先打印一个菜单 询问是否游戏-->0/1/错误
//2_游戏-->打印棋盘 并让玩家和电脑一起下棋 不游戏-->回到菜单
//棋盘大概长相：
//	 |	 |
//___|___|___
//	 |	 |
//___|___|___
//   |   |   
//	 |	 |
//3_玩家下棋/电脑下棋 并实时判断是否有胜者 是否平局
//4_回到菜单 是否继续？
//我们来实现一下：
//#define Row 3
//#define Col 3
//int flag = 0;
//void menu()
//{
//	char arr1[] = "            ";
//	char arr2[] = "Play or Not?";
//	char arr3[] = "                           ";
//	char arr4[] = "Play: input 1 exit: input 2";
//	int left1 = 0, left2 = 0;
//	size_t right1 = strlen(arr1 - 1);
//	size_t right2 = strlen(arr3 - 1);
//	while (left1<=right1)
//	{
//		arr1[left1] = arr2[left1];
//		arr1[right1] = arr2[right1];
//		printf("%s\n", arr1);
//		Sleep(300);
//		system("cls");
//		left1++;
//		right1--;
//	}
//	while (left2<=right2)
//	{
//		arr3[left2] = arr4[left2];
//		arr3[right2] = arr4[right2];
//		printf("%s\n", arr3);
//		Sleep(150);
//		system("cls");
//		left2++;
//		right2--;
//	}
//	printf("%s\n%s\n", arr1,arr3);
//}
//void initboard(char chessboard[Row][Col], int row, int col)
//{
//	int i=0, j = 0;
//	for ( i = 0; i < row; i++)
//	{
//		for ( j = 0; j < col; j++)
//		{
//			chessboard[i][j] = ' ';
//		}
//	}
//}
//void printboard(char chessboard[Row][Col],int row,int col)
//{
//	int i = 0;
//	for (int i = 0; i < row; i++)
//	{
//		int j = 0;
//		for (j = 0; j < col; j++)
//		{
//			if (j < col - 1)
//			{
//				printf(" %c |", chessboard[i][j]);
//				
//			}
//			else
//				printf(" %c \n", chessboard[i][j]);
//		}
//		if (i<row-1)
//		{
//			for (int j = 0; j < col; j++)
//			{
//				if (j < col - 1)
//			{
//					printf("---|");
//			}
//				else
//					printf("---\n");
//			}
//		}
//	}
//}
//void playermove(char chessboard[Row][Col], int row, int col)
//{
//	int x, y = 0;
//	printf("Player Chess-->input n,n \n");
//	scanf("%d,%d", &x, &y);
//	while (true)
//	{
//		if (x > 0 && x <= row && y > 0 && y <= col)
//		{
//			if (chessboard[x - 1][y - 1] == ' ')
//			{
//				chessboard[x - 1][y - 1] = '*';
//				flag = 0;
//				break;
//			}
//			else
//			{
//				printf("This coordinate is already occupied,please re-enter it.\n");
//				Sleep(2500);
//				flag = 1;
//				break;
//			}
//		}
//		else
//		{
//			printf("The coordinates entered are illegal.\nPlease try again.\n");
//			Sleep(2500);
//			flag = 1;
//			break;
//		}
//	}
//}
//void computermove(char chessboard[Row][Col], int row, int col)
//{
//	printf("Computer chess...\n");
//	Sleep(2000);
//	int x, y = 0;
//	while (1)
//	{
//		x = rand() % row;
//		y = rand() % col;
//		if (chessboard[x][y] == ' ')
//		{
//			chessboard[x][y] = '#';
//			break;
//		}
//	}
//}
//char ionwin(char chessboard[Row][Col])
//{
//	int i, j = 0;
//	for ( i = 0; i < Row; i++)//行等
//	{
//		int countp=0,countc = 0;
//		for ( j = 0; j < Col; j++)
//		{
//			if (chessboard[i][j]=='*')
//			{
//				countp++;
//			}
//			if (chessboard[i][j]=='#')
//			{
//				countc++;
//			}
//		}
//		if (countp==3)
//		{
//			return 'y';
//		}
//		if (countc==3)
//		{
//			return 'n';
//		}
//	}
//	for ( j = 0; j < Col; j++)//列等
//	{
//		int countp = 0, countc = 0;
//		for ( i = 0; i < Row; i++)
//		{
//			if (chessboard[i][j] == '*')
//			{
//				countp++;
//			}
//			if (chessboard[i][j] == '#')
//			{
//				countc++;
//			}
//		}
//		if (countp == 3)
//		{
//			return 'y';
//		}
//		if (countc == 3)
//		{
//			return 'n';
//		}
//	}
//	if (1)//交叉等
//	{
//		int countp1 = 0, countc1 = 0;
//		int countp2 = 0, countc2 = 0;
//		for (i = 0, j = 0; i < Row && j < Col; i++ && j++)
//		{
//			if (chessboard[i][j] == '*')
//				countp1++;
//			else if (chessboard[i][j] == '#')
//				countc1++;
//			else
//				break;
//		}
//		for (i = 2, j = 0; i >= 0 && j < Col; i-- && j++)
//		{
//			if (chessboard[i][j] == '*')
//				countp2++;
//			else if (chessboard[i][j] == '#')
//				countc2++;
//			else
//				break;
//		}
//		if (countp1==3||countp2==3)
//		{
//			return 'y';
//		}
//		if (countc1==3||countc2==3)
//		{
//			return 'n';
//		}
//	}
//	int flag = 1;//判断平局
//	for (int i = 0; i < Row; i++)
//	{
//		for (int j = 0; j < Col; j++)
//		{
//			if (chessboard[i][j]==' ')
//			{
//				flag = 0;
//			}
//		}
//	}
//	if (flag)
//	{
//		return 't';
//	}
//}
//void game()
//{
//	char chessboard[Row][Col] = { 0 };
//	initboard(chessboard, Row, Col);
//	printboard(chessboard,Row,Col);
//	while (1)
//	{
//		char judge = 0;
//		playermove(chessboard, Row, Col);
//		printboard(chessboard, Row, Col);
//		judge=ionwin(chessboard);
//		if (judge=='y')
//		{
//			printf("YOU WIN!\n");
//			Sleep(1500);
//			break;
//		}
//		else if (judge=='t')
//		{
//			printf("STALEMATE!\n");
//			Sleep(1500);
//			break;
//		}
//		if (flag==0)
//		{
//			computermove(chessboard, Row, Col);
//			printboard(chessboard, Row, Col);
//		}
//		judge = ionwin(chessboard);
//		if (judge == 'n')
//		{
//			printf("YOU LOSE!\n");
//			Sleep(1500);
//			break;
//		}
//		else if (judge == 't')
//		{
//			printf("STALEMATE!\n");
//			Sleep(1500);
//			break;
//		}
//	}
//}
//
//int main()
//{
//	int input = 0;
//	srand((unsigned int)time(NULL));
//	do
//	{
//		menu();
//		scanf("%d", &input);
//		switch (input)
//		{
//		case 1:
//			printf("Enter the game...\n");
//			Sleep(1000);
//			game();
//			break;
//		case 2:
//			printf("Exit the game...\n");
//			Sleep(1000);
//			exit(0);//退出
//			break;
//		default:
//			printf("Wrong choice! Please re-select-->\n");
//			Sleep(1500);
//			break;
//		}
//	} while (input);
//	return 0;
//}


//递归实现一个reverse_string 将字符串逆序--不只是逆序打印！
//思路：
//元素下标 0 1 2 3 4 5 
//我们只需要让0和5，4和1，2和3对应交换即可 那么我们可以设置一个函数用来交换传递过来的参数所对应的数组中的字符
//而当第一次交换完0和5之后让它继续递归调用 左参数+1，右参数-1，即可交换1，4和2，3，直到左参数>=右参数时停止递归并返回主函数
//总结就是，限制条件：左参数<右参数		逼近方式：每次递归调用左参数-1，右参数+1；
//非递归实现：
//static reverse_string(char arr[], size_t left, size_t right)
//{
//	char temp = 0;
//	while (left<right)
//	{
//		temp = arr[left];
//		arr[left] = arr[right];
//		arr[right] = temp;
//		left++;
//		right--;
//	}
//}
//错误的递归实现：	先交换 再判断是否递归
//static reverse_string(char arr[], size_t left, size_t right)
//{
//	char temp = 0;
//	temp = arr[left];
//	arr[left] = arr[right];
//	arr[right] = temp;
//	if (left < right)
//	{
//		reverse_string(arr, left + 1, right - 1);//fecdba 为什么会出错呢？其实错误之处就在于先交换再判断 导致程序不具有普适性
//	}
//	//当字符串长度为偶数时 这样的递归会导致原本进行到递归底层时由于left<right从而再次进入递归调用后进行了一次额外的交换
//	//然后再回归向上 所以此时中间那两个字符就会呈现出未交换的顺序 实则已经交换了两次
//	//而当字符串长度为奇数时 多一次递归调用也不会出错 因为那时的left+1已经等于right-1了 自己和自己交换并不会改变顺序
//}
//正确的递归实现:	先判断 再交换和递归
//static reverse_string(char arr[],size_t left,size_t right)
//{
//	if (left<right)
//	{
//		char temp = 0;
//		temp = arr[left];
//		arr[left] = arr[right];
//		arr[right] = temp;
//		reverse_string(arr,left+1,right-1);//fedcba
//	}
//}
//int main()
//{
//	char arr[] = "abcdef";
//	size_t sz = sizeof(arr) / sizeof(arr[0]);//勿忘:sizeof不能放函数中计算
//	//这里用strlen也可，但是换成strlen-1，因为\0不计入字长
//	reverse_string(arr, 0, sz - 2);
//	for (int i = 0; i < sz-1; i++)
//	{
//		printf("%c", arr[i]);
//	}
//	return 0;
//}
//补充：size_t
//size_t是无符号整型的一种 它能够以字节为单位表示任何对象的大小(自适应性) 它可以是 unsigned char,int,long,long long等等
//它的优点是可以提高代码移植时的兼容性 还可以分配最合适的内存空间，避免浪费 这在嵌入式系统开发中是比较在意的一点
//它对应的标准占位符是%zu 但是也兼容%u毕竟说到底也是无符号整型 

//写一个递归函数 DigitSum 使其能计算数位之和
//例如: 输入非负整数 1234 计算出 1+2+3+4=11并输出在控制台
//思路：
//非负整数-->unsigned int 所以可以用size_t来定义变量
//1+2+3+4即是4+3+2+1 容易知道 取末尾数字采用%10即可 所以容易发现
// x	   x%10
//1234		4
//123		3
//12		2
//1			1
//0			0
//显然x并不需要递归深入到0 只是到个位数就可以了 所以限制条件可设置为x>9 逼近方式自然是x/10
//而后向上回归 每次回归都加上x%10(底层回归时返回x本身即可)作为整体返回值 这就实现了1+2+3+4并且最后到达顶层时又返回了主函数
//注意 哪怕x就是个位数也无所谓 直接作底层回归 返回本身到主函数
//size_t DigitSum(size_t x)
//{
//	if (x>9)
//	{
//		return DigitSum(x / 10)+x%10;
//	}
//	return x;//这个return x只有在底层回归时才会执行 后面每次回归由于x都>9所以会一直在if语句中 到顶层时直接返回主函数
//}
//int main()
//{
//	size_t x= 0;
//	scanf("%zu", &x);
//	size_t ret =DigitSum(x);
//	printf("%zu", ret);
//	return 0;
//}


//递归实现n的k次方
//思路类似于上题 关键：大事化小！//补充 其实库函数中本身就含有计算次方的函数 pow(n,k) 即是计算n的k次方
//double power(int x,int y)//power:幂，指数
//{
//	//对y进行判断
//	if (y>0)
//	{
//		return power(x, y - 1) * x;
//	}
//	else if(y<0)
//	{
//		return 1/power(x,-y);//因为x^y(y<0)=1/x^-y(-y>0) 所以分母部分可以直接传参-y进行递归调用 计算出次方值后返回到此处即可
//	}
//	//递归深入到底层时对x进行判断
//	if (x!=0)
//	{
//		return 1;
//	}
//	return 0;
//}
//int main()
//{
//	int n,k = 0;
//	scanf("%d %d", &n,&k);
//	double ret = power(n,k);
//	printf("%d^%d=%.4lf\n", n, k, ret);//注意打印ret时要用%lf
//	return 0;
//}


//数组习题：
//1_请问这两个数组的长度关系？
//char acX[] = "abcd";
//char acY[] = { 'a','b','c','d' };
//注意这里很容易误以为两者长度相等 但是！！！这里是数组长度！
//数组长度的计算是要算入'\0'的！ 而字符串的长度计算以'\0'为结束标志所以不计入'\0'
//ans: 数组acX的长度大于数组acY的长度

//2_请问这种初始化正确吗?
//int a[][3] = { {0,,2},{},{3,4,5} };
//这里犯了两个错误：
//1..{0,,2} 两个逗号之间不能为空 {,,}不会被算作初始化为空 编译器也不会自动补全成0 所以这样写是非法的；
//2..{} 初始化为{}编译器也是无法解释的 如果解释为三行 那么这里面不能为空 如果解释为两行 那么数组中就不该存在{}这个初始值设定项
//所以这种初始化是错误的


//扫雷游戏:




//操作符详解
//操作符分类：
//算术操作符;移位操作符;位操作符;赋值操作符;单目操作符;关系操作符;逻辑操作符;条件操作符;逗号表达式;下标引用,函数调用,结构成员等等

//1_算术操作符：
//关于取整(trunc) 取模(mod) 取余(rem)
//事实上 关于取整有四个函数 代表了四种取法：
//trunc:->0方向取整		ceil:->+∞方向取整		floor:->-∞方向取整		round:->四舍五入取整
//在不同的语言中 采取的取整方式是不同的 向0取整系:c,c++,java,c#...		向-∞取整:python
//-10/3的C语言解释 ： - 10 = (-3) * 3 + (-1)
//因为c语言是对于商的计算是往0方向取整 在数轴上-3离0更近 所以取商为-3 那么余数就是-1
//-10/3的python解释： - 10 = (-4) * 3 + 2
//因为python的取整是往-∞方向 -4离-∞更近 所以取商为-4 余数也就是2
//也就是说出现-3.333..在python和c语言中有着不同的理解 这里的不同就是取整方向不同
//还要补充：在数学语言中余数是大于0的 但是在编程语言中 余数r的定义范围是 0<=|r|<|d| d:除数
//取模与取余的区别：以a=b*q+r为例
//取模是为了让商q往-∞方向取整 而取余是为了让q向0方向取整 
//当%两边操作数同号时取模和取余等效 ； 操作数异号时则两者不相等
//所以 C,C++,Java..中的%取模符号其实本质上是取余 而python中的%才是真正的取模运算
//---------------------------------------------------------------------------------------->>>>>
//为避免混淆 我们此后在C语言中起一个约定 统称%为取余操作符
//关于余数的符号 -->0系取整的编程语言体系中 余数的符号与被除数相同
//而对-->-∞系的python而言余数的符号取决于除数 除数为正，则余数符号和被除数相同；如果除数为负，则余数符号与被除数相反

//2_移位操作符（与位操作符一起常用于嵌入式开发中对硬件底层的直接操作）
//左移位:<<		右移位:>>
//移位操作符的操作数必须是整数 不能对小数进行移位操作！
//注意这里的移位移的是二进制  这里先介绍：原码 反码 补码
//我们知道 数据在计算机中是用二进制存储的 当一个数据在内存中开辟了空间之后 计算机还需要用二进制的形式来存储该数据
//例如一个整型数据占据四个字节的内存空间 也就意味着可以用32个二进制数来表示该数据 而数据的二进制表示有原码 反码 补码三种
//原码：首位为符号位 0表示这是个正数 1表示这是负数 而后面的31位用二进制表示该整数即可 如7的原码:0000..0111
//反码：在原码的基础上 首位不变 其他位取反
//补码：在原码的基础上+1
//注意：只有负数才有原码 反码 补码的区别 正数的原码反码补码都是同一个二进制序列
//而整型数据在内存中统一采用的是补码！因为原码反码在进行减法时无法正确处理符号位 也就是说原码反码在进行加法和减法运算时需要进行转换
//而采用补码可以简化硬件设计 因为补码能同时进行加法和减法运算而不需要转换即可正确输出结果
//此外 补码还解决了0的符号位问题 避免了像原码补码那样对+0,-0的分开处理 实现了通用一套硬件电路进行正负数的加减法运算
//！！！一个容易出错的问题：
//已知x86(32位)环境下整型数据的补码是32位 那x64环境中呢 这个补码会是64位吗？
//--答案是 不会！！！ 因为补码是计算机内部对于数据的存储方式 但是补码的位数是根据数据的类型来的->准确来说是数据所占的字节
//存储过程:数据输入->确定数据类型->以对应类型开辟空间->计算机采用补码形式翻译数据并存储在这个空间中
//这里的空间单位是字节 一个字节又是8个二进制位(bit) 数据占多少个字节 补码就相应地用二进制数来补全(填充)这些字节内的空间
//正因为如此 补码和数据开辟的空间是完全匹配的 可以认为是<数据开辟空间 计算机将该数据翻译为补码形式再完全贴合地放入这个空间中>
//也正因为如此 补码位数和数据所占的字节数呈现8：1的比例关系
//回到最开始的问题 由于x86和x64中整型数据都占4个字节的内存空间 所以两种环境下整型数据的补码都是32位
//但是如果是长整型或者指针类型数据 那么x64中两者的补码就是64位的 而x86中则是32位的------<<
//因为x64中这两类数据均占8个字节 但是在x86中则占4个字节 由于所占的内存空间不同 所以补码也就不同了
//而-------->移位操作符 就是在数据对应补码的基础上进行移位操作  移位操作就是将整个补码序列进行左右移动
//注意移动后要保持32位序列 所以左移就丢弃左边的二进制数 在右边通过补0进行补全；右移操作符分为逻辑移位和算术移位两种 
//但是！移位操作符不会改变操作数本身的二进制序列和十进制的数值 只是我们可以通过移位操作来获取该操作数移位后的数值和二进制序列
//这种关系类似于 int b=a-1;将a-1的值赋给b并不会改变a本身的值
//int main()
//{
//	int a1 = 7;
//	int a2 = -7;//注意这里是负数 要用补码进行移位操作：11111..001
//	int b1 = a1 << 1;//11111..0010(末尾0是补的)->转换为反码:1111..0001->转换为原码:10000..1110->转换为十进制:-14
//	int b2 = a2 << 1;
//	printf("%d\n%d", b1,b2);
//	return 0;
//}
//总结：
//无论正数还是负数 左移操作符移动n位则操作数*2^n
//int main()
//{
//	int a1 = 7;
//	int a2 = -7;
//	int b1 = a1 >> 1;//3
//	int b2 = a2 >> 1;//-4
//	printf("%d\n%d\n", b1,b2);
//	return 0;
//}
//右移其实分为 算术右移和逻辑右移：
//算术右移：右边丢弃 左边补原符号位；逻辑右移：右边丢弃 左边补0
//大部分编译器都支持的是算术右移 VS也不例外
//补充：
//int main()
//{
//	int a = 2147483647;//请记住这个数的二进制序列：01111111...111(32位)
//	int b = a << 1;
//	printf("%d\n", b);//-2
//	return 0;
//}
//这说明 当操作数足够大的时候 左移操作符移位后并不是一直等于原数的2^n倍 这个倍数关系是有限制的
//一旦左移到移动符号位时 移位就将逆转操作数的正负和大小<正->负> <极大->极小> 
//这也说明 左移操作其实是一种强制性的移位操作 是会改变符号位的 这一点与算术右移明显不同！
//额外提醒：移位操作符移动的位数不能是负数！所有C语言标准中都未定义这种操作 也就是说 编译器是不能解释的 这是一个error

//3_位操作符
//位操作符有：
// &	按位与
// |	按位或
// ^	按位异或
// ~	按位非
//注意 位操作符的操作数必须都是整数！此外注意 打印有负数的整型时要采用%d占位符
//位指的是 二进制位 这里操作的二进制序列指的仍然是补码！
//按位与指的是将两数的补码进行与运算 遵循:同真则真(1为真 0为假) 有假则假 从而得到一套新的二进制序列(同真则对应位为1 同假则对应位为0)
//而按位或指将两数的补码进行或运算 遵循:同假则假 有真则真
//按位异或指..进行异或运算 遵循相同则真 相异则真（异或这个命名都像是在问你：是否相异 那么如果相异就是真的 反之就是假的）
//按位非指..进行非运算 有真则假 有假则真（非运算的操作数只有一个哦）
//int main()
//{
//	int a=3,b=-5;
//	int c = a & b;
//	int d = a | b;
//	int e = a ^ b;
//	int f = ~a;
//	printf("%d\n", c);//3
//	//3的补码：				0000..011
//	//-5的补码：			1111..011
//	//按照有假则假 同真则真 0000..011 转换为原码对应十进制数就是3
//	printf("%d\n", d);//-5
//	//按照同假则假 有真则真 1111..011->原码：1000..101->十进制对应的就是-5
//	printf("%d\n", e);//-8
//	//按照相同则假 相异则真 1111..000->原码：1000..1000->对应-8
//	printf("%d\n", f);//-4
//	//按照有真就假 有假则真 1111..100->原码：1000..100->对应-4
//	return 0;
//}
//...一道变态的面试题：
//交换两个整数 不能创建第三个变量:<
//int main()
//{
//	int a = 3, b = 5;
//	/*int c = a;
//	a = b;
//	b = c;
//	这是我们常见的交换思路：即利用第三个变量来存放其中一个数交换前的数据*/
//	/*a = a + b;
//	b = a - b;
//	a = a - b;
//	这种算术交换的方式也是可以的 类比于此 我们还可以将+换成* -换成/ 也是同样可以实现的
//	但是这类方式有潜在威胁：当a,b很大时 a+b或者a*b可能会存在栈溢出 因为a,b的+和*很可能就会超出int类型的大小上限*/
//	a = a ^ b;
//	b = a ^ b;
//	a = a ^ b;
//	//这就完成了--->hh 懵逼了吧 接下来我们来讲解一下
//	//首先 我们需要深入了解一下 异或这种运算
//	//提问：3^3=? 答案是0 因为这两数是完全相同的 那么0^3=? 答案是3；0^8=? 答案是8 因为0和0相同还是为0 0和1相异还是为1
//	//所以我们能得出一下结论：
//	//a^a=0 0^a=a
//	//那么计算一下 a^a^b=? 显然结果是b 那么a^b^a呢？答案仍然是b 这说明异或操作符是满足交换律的！
//	//那么 我们将a^b赋给a 再将新a^b赋给b就等价于将a^b^b赋给b 那么这显然已经完成了将b赋值给a的任务
//	//接下来 将新a^新b赋给a就等价于将a^b^a赋给a 这又完成了将a赋给b的任务 所以这里就是通过对异或的妙用来解决了这道问题
//	//当然 其实仔细思考会发现这里异或的思路和前面的算术交换思路是一样的 但是这种方式不会留下栈溢出的隐患！
//	return 0;
//}

//4_赋值操作符
//赋值操作符是一种自由的操作符 并且它是可以连续使用的 
//如：a=a+1=a+2;从右往左赋值 但是不建议这种写法降低了可读性
//注意区分赋值和初始化的区别 int a=1;这是初始化 a=1这是赋值
//复合赋值符：
//+= -= *= /= %= >>= <<= &= |= ^= 类比于前面的+= -=即可知道它们的作用

//5_单目操作符
//！逻辑反操作符;- 负值 +正值; & 取地址符; sizeof 操作数的类型长度(Byte); ~ 按位取反; -- ++(前后置之分);* 解引用操作符;(类型)强制类型转换
//注意 sizeof是操作符！！ 计算的是变量/类型所占内存空间的大小
//~按位取反操作符 是将所有位均取反 包括符号位！
//关于 ^ & | ~ >> << ^这几个位相关操作符的组合应用
//int main()
//{
//	int a = 13;
//	//a的补码: 00000000000000000000000000001101
//	//请问如何将a通过二进制位操作得到15？
//	//15的补码:00000000000000000000000000001111 显然对比之后发现我们只需要让2^1位的0变为1即可 那么如何实现呢?
//	//显然 只需要通过按位或|将a的补码与000000000000000000000010进行按位或操作即可
//	//问题又来了 如何表示出0000..0010呢? 答案是1<<1 通过移位操作符 将1的补码进行左移一位的操作即可
//	a |= (1 << 1);
//	//事实上 将二进制码由0->1的操作只通过按位或操作符即可 而为了使按位操作符精准地实现替换 还需要通过移位操作符来提供对应的1
//	//请问又如何将a通过二进制操作得返回到13？对应补码：00000000000000000000000000001101 显然我们只需要将2^1位的1->0即可
//	//如何实现替换？ 类比0->1可知只需要通过按位与&将a的补码与0000000000000000000000000001101进行按位与操作即可
//	//问题又又又来了 如何表示出 这个0000000000000000000000000001101？ 1101似乎不太好实现 但是有一个与其等效的一个补码：
//	//111111111111111111111111111111111101 这个就很好实现了-->首先对1的补码进行移位(<<1) 然后进行按位取反操作 再进行&操作即可
//	a &= (~(1 << 1));
//	printf("%d\n", a);
//	//由此发现我们借此几乎可以操作出所有我们需要的数据 这种对计算机硬件底层数据直接操作的手段在硬件相关(嵌入式..)的方面用处极大
//	return 0;
//}
//前后置++ -- 一句话！！！ 前置先使用 后置后使用 这在几乎所有条件下都是适用的
//一个小小的疑惑
//那为什么我们for(i=0;i<10;i++)时没有先使用(做下一次循环是否进行的判断)再加加呢 这是因为当程序运行到判断部分时i早就完成自加了
//所以这里用i++和++i并没有什么区别事实上 但是注意这里的i是内置类型 在以后学习到C++时我们可以利用C++中的class(类)自定义类型
//如果这里的i是自定义类型 那么两者就是有差异的 ++i会比i++更快 运行效率会高一点 所以在C语言中我们采用两种写法都是可以的
//但是在C++中我们最好就写作++i 如果你想为自己确定一个i=i+1的固定写法 那么不妨从现在就将其统一写为++i;

//(类型)强制类型转换
//int main()
//{
//	//int a = 3.14;
//	//报错 因为3.14是double型数据 采用int型接受会丢失数据
//	//这时我们可以使用强制类型转换：
//	int a = (int)3.14;
//	//这样便可以将double型的3.14转换为int型的3 编译器也就不会报错了
//	//可以看到 强制类型转换一定是放在需要转换的类型前的 而不是放在转换后的类型前：(int)int a=3.14;...
//	printf("%d\n", a);
//	return 0;
//}

//关于sizeof
//int main()
//{
//	int a = 0;
//	int b = sizeof a;//sizeof int也可
//	printf("%d\n", b);//4
//	//这再次说明了 sizeof 是操作符而不是库函数 因为如果调用了函数 那就必须要加括号
//	return 0;
//}
//一道易错题：
//void test1(int arr[])
//{
//	printf("%zu\n", sizeof(arr));//?----------->8
//}
//void test2(char ch[])
//{
//	printf("%zu\n", sizeof(ch));//?------------>8
//}
////为何两者打印出来都是8
////虽然我们说sizeof(array)时 计算的是整个数组的大小 但是请注意 这里的函数中的arr[]是从主函数中数组传过来的
////而数组传参时传递的是数组中首元素的地址 也就是说 这里的int arr[]=int* arr 那么sizeof(arr)=计算一个指针变量的大小
////64位操作系统中一个指针变量占8个字节 所以结果是8 字符数组ch同理 因为地址都是64位的
//int main()
//{
//	int arr[10] = { 0 };
//	char ch[10] = { 0 };
//	test1(arr);
//	test2(ch);
//	return 0;
//}

//6_关系操作符：> >= < <= != ==		其中尤为注意==和=！！！千万不要搞混了
//此外 ==并不能用来进行各种数据的比较 比如字符串和字符串之间 还有浮点数和浮点数之间等等
//以字符串之间的比较为例：
//如果我们采用"abc"=="abcdef" 那么我们实际上是在比较两个字符串的地址是否相等 而不是比较两个字符串的内容是否相等
//虽然说C++是支持这种用法的 但是C语言并不支持 不过随着编译器的更新 这种用法大部分时候都是可以正常用的 只是比较的含义不同

//7_逻辑操作符：&&(逻辑与)  ||(逻辑或)
//注意与按位与(&)和按位或(|)分开 按位与/或是在两个操作数的二进制位上进行0/1的的与运算/或运算
//而&&和||则只在意逻辑上的真假(0为假 非0为真)
//int main()
//{
//	//int i=0,a=0,b=2,d=3;
//	//注意！以下的i被赋的值是逻辑运算的结果 所以只有1/0两种结果！！！
//	//i = a++ && ++b && d++;//实际运算次序为：((a++&&++b)&&d++)-->>i=((a++&&++b)&&d++) 因为赋值操作符的优先级最低
//	//printf("a=%d b=%d d=%d\n", a, b, d);//1 2 3   为什么只有a自加了？
//	//当a=0时 a++先使用再加加 所以第一个逻辑与操作符左侧已经为0(假)了 那么后面的"连续逻辑与"运算也就不会进行了
//	//这种关系有点类似于串联电路中某个灯泡断路了 那么后面的灯泡都不会有电流流过了 所以最后的结果只有a+1了 而其它变量并没有+1
//	//int i = 0, a = 1, b = 2, d = 3;//a换成1试试？
//	//i = a++ && ++b && d++;
//	//printf("a=%d b=%d d=%d\n", a, b, d);//2 3 4		此时a,b,d就都自加了 因为逻辑与操作符那里执行充分了
//	int i = 0, a = 1, b = 2, d = 3;
//	i = a++ || ++b || d++;//&&换成||试试？
//	printf("a=%d b=%d d=%d\n", a, b, d);//2 2 3		此时这里b,d又一次没有+1 为什么呢？
//	//原因很简单 因为原式的运算次序是:((a++||++b)||d++)-->> i=((a++||++b)||d++) 而当第一式a++(先使用a a为1)为真时
//	//后面的"连续逻辑或"运算都不需要进行了 整个式子已经被判定为真了 
//	//类似于三条并联电路中第一条路a(无灯泡)走通了 那么第二条电路中的灯泡b和第三条电路中的灯泡d就被短路了 所以最后只有a自加了
//	//同理可知 如果使a=0 b!=-1那么d++也不会执行；如果使a=0 b=-1 那么i = a++ || ++b || d++整体就会被充分执行
//	return 0;
//}

//8_条件操作符(三目操作符)
//exp1? exp2: exp3  1true->2  1false->3
//使用三目操作符常常有两种写法：
//int main()
//{
//	int a = 5;
//	int b = 0;
//	(a > 4) ? (b = 3) : (b = -3);//第一种
//	b = (a > 4 ? 3 : -3);//第二种
//	//两种写法本质上实现的效果都是一样的 但是从代码简洁性和易读性来看 第二种写法明显更好 我们也更推荐使用第二种
//	printf("%d\n", b);
//	return 0;
//}

//9_逗号表达式
//逗号表达式其实是指 用逗号隔开的一系列表达式 其中逗号是操作符
//逗号表达式遵循从左到右依次执行的顺序特点 整个表达式的结果是最后一个表达式的执行结果
//示例一：
//int main()
//{
//	int a = 1;
//	int b = 1;
//	int c = (a > b, b+1, a = b + 1, b);
//	printf("%d %d\n", a, c);//2 1
//	//注意这里对C初始化的括号中 a>b b+1 a=b+1都是被依次执行了的 所以最后a=2 但是这些都不影响整个逗号表达式的结果是最后一个表达式的结果
//	//所以最后 c=1 (这里还有个误区就是 b+1这里 虽然b+1被执行了 但是它并没有被重新赋给b 所以并不会产生实质性的影响！)
//	return 0;
//}
//示例二：
//if (a = b + 1, c = a / 2, d > 0); 这个if语句中的条件判断项取决于什么？
//-------->>哪怕表达式从左到右都会执行 但是真正的判断条件取决于最后的d>0(true/false)
//示例三：
//int func1(int a);
//void func2(int a);
//int main()
//{
//	int a = 1;
//	do
//	{
//		a = func1(a);
//		func2(a);
//		//...
//	} while (a>0);
//	return 0;
//}
//  //不难发现 我们的目的就是 当a执行完一趟函数的调用后 判断a是否还>0 大于0则继续循环 但是这样写有些冗余不是吗？
//  //看看这种
//int main()
//{
//	int a = 1;
//	while (a=func1(a),func2(a),a>0)
//	{
//		//...
//	}
//	return 0;
//}
//  //这就是对逗号表达式恰到好处的使用范例之一

//10_下标引用 函数调用和结构成员
//下标引用操作符：
//下标引用操作符的操作数有两个 数组名和索引值 下标引用操作符的操作数是满足交换律的 下面举例来说明一下
//int main()
//{
//	int arr1[10] = { 0 };
//	int arr2[10] = { 0 };
//	arr1[7] = 8;
//	7[arr2] = 8;
//	printf("%d %d %d\n", arr1[7],arr2[7],7[arr2]);//8 8 8
//	//由于[]的操作数满足交换律 所以 arr[i] 和 i[arr]是完全一致的 本质上都是对数组对应元素的索引调用
//	//知其然 也要知其所以然 为什么下标引用操作符的操作数满足交换律呢？
//	//我们知道 array name本质上(在非两个特例情况下)是代表的数组中首元素的地址  而：arr[i]本质上就是*(arr+i)
//  //因为数组存储时下标是从0开始的 arr+i就是跳过i个元素 指向第i+1个元素  arr[i]也是指向第i+1个元素 所以两者相等同
//	//也就可以推出arr+i == &arr[i] 又因为 arr+i是满足加法交换律的 所以arr+i==i+arr 进而*(arr+i)==*(i+arr) 因此arr[i]==i[arr]
//  //这种等价关系在访问数组成员时都是成立的(例如对数组成员的赋值 打印对应成员的值等等) ---->
//  //----->>但是在数组进行初始化的时候是不能按照第二种方式来写的！只有访问(引用)成员时才可以等价使用
//	//当然 虽然这么写不违反规定 但是我们仍然建议写成常见形式以提升可读性 （如果只是出于炫技，当我没说）
//}
//函数调用操作符：
//int test(a)
//{
//	//...
//}
//int main()
//{
//	int a = 1;
//	int b = test(a);
//	//这里的()就是函数调用操作符 它有一个或多个操作数 但至少要有一个操作数--->也就是函数名 剩余的操作数取决于()中参数的多少
//	printf("%d\n", b);
//	return 0;
//}
//结构成员访问操作符：.以及->
//下面是一种直觉性错误的案例：
//struct stu
//{
//	char name[10];
//	int age;
//	int score;
//};//分号必须加 这个整体类似于函数的声明部分 只是告诉了编译器这里有一个什么样的结构类型 但是并没有在内存中开辟空间
//void set_stu(struct stu a)
//{
//	//a.name = "zhang san";
//	//这里我们发现编译器报了个错误 说表达式必须要有可修改的左值 为什么会出现这样的错误呢？因为我们已经知道：
//	//数组名本质上是个地址 地址是计算机分配好了就不可以修改的 我们这里的写法想要将"zhang san"赋给一个地址 这显然是不合理的
//	//这里还有一种不报错的写法：strcopy(a.name,"zhang san");即利用strcopy函数将字符串拷贝进去
//	strcpy(a.name, "zhang san");
//	a.age = 18;
//	a.score = 123; 
//}
//void print_stu(struct stu a)
//{
//	printf("%s\n%d\n%d\n", a.name, a.age, a.score);
//}
//int main()
//{
//	struct stu a = { 0 };
//	set_stu(a);
//	print_stu(a);
//	//打印结果：NULL 0 0 ? 这是为什么 我们不是已经对其进行赋值和拷贝了吗？
//	//原因很简单：因为这里是传值调用！！！形参只是实参的一份临时拷贝
//	//如果我们要实现对结构体类型中声明的变量进行赋值等操作 就必须采用传址调用才行 也就是需要用到指针
//	return 0;
//}
//正确示例：
//struct stu
//{
//	char name[10];
//	int age;
//	int score;
//};
//void set_stu(struct stu* pa)
//{
//	///strcpy((*pa).name ,"zhang san");
//	//(*pa).age = 18;
//	//(*pa).score = 123;
//	//这里我们也可以采用第二种方式进行结构体成员的访问 因为(*a)这种写法显得过于冗余了 而->的写法则显得很简洁：
//	strcpy(pa->name, "zhang san");
//	pa->age = 18;
//	pa->score = 123;
//}
//void print_stu(struct stu* pa)
//{
//	//printf("%s\n%d\n%d\n", (*pa).name, (*pa).age, (*pa).score);
//	printf("%s\n%d\n%d\n", pa->name, pa->age, pa->score);//此处同理 也采用第二种访问方式也是成立的 而且代码也变得更简洁,可读了
//}
//int main()
//{
//	struct stu a = { 0 };//结构体类型的实体初始化都要采用{0}这种初始化方式 因为结构体本身的定义部分就是以{}括起来的整体
//	set_stu(&a);
//	print_stu(&a);
//	//zhang san 
//	//18
//	//123		AC!
//	return 0;
//}
//总结起来 两种操作符的区别：
//.的使用形式是:结构体对象.成员
//->的使用形式:指向结构体的指针->成员
//前者是以结构体对象为操作数,在对象基础上找到成员 而后者则是以指向结构体的指针为操作数,通过对象地址找成员地址进而访问成员
//事实上 对于编译器底层而言 两者的实现逻辑是一样的 也就是说: (*ps).name = ps->name
//但是 如果涉及到函数传参 我们一般建议使用后者 因为前者需要创建形参s来拷贝实参 再在形参基础上进行操作 这是很浪费空间的做法
//而后者则可以直接使用指向结构体的指针ps来接收 然后在原结构体上进行操作 既避免了空间浪费 又提升了操作速度


//操作符最实际的应用：表达式求值
//表达式求值的顺序一部分是由操作符的优先级和结合性决定的 同时有些表达式的操作数在求值的过程中可能会需要类型转换
//int main()
//{
//	int a = 0;
//	int b = 1 + 2 + 3;
//	//请问这里的1 2 3之间的+ + 操作符优先级相同吗-显然相同 那么1 2 3的执行顺序是怎样的？ 这里就需要结合性来判断了
//	//由于+的结合性是从左到右 所以1 2 3的执行顺序是 先1+2 再 1+2 +3
//	return 0;
//}
//从这里就可以看出来 优先级和结合性是同时在影响表达式的执行顺序的 附录------>操作符的优先级,结合性一览表 <见微信收藏..>
//只不过我们并不需要将这个表背下来 只是说当作偶尔查询的工具即可

//类型转换
//1_隐式类型转换
//C语言的整型算术运算总是至少以缺省（默认）整型类型的精度来进行的
//当表达式中存在精度小于整型精度的操作数(char;short int)存在时 为了维持这个精度 会将该操作数在使用前转换为普通整型
//这种转换被称为：整型提升
//例如：
//int main()
//{
//	char a = 51;
//	char b = 58;
//	char c = a + b;//这里的+操作符两端的操作数a，b就都只是char类型 明显精度小于整型精度 所以a,b在相加前会被转换为一般整型
//	printf("%d\n", c);//这里以整型打印字符型变量c 也需要将c转换为一般整型
//	return 0;
//}
//整型提升的意义？
//表达式的整型运算要在CPU的相应运算器件(整型运算器ALU)中执行 而ALU的操作数的字节长度一般默认为int类型的字节长度 同时也是CPU通用寄存器的长度
//换句话说就是 int类型的字节长度是ALU最小的精度单位！
//因为 两个精度低于int类型操作数相加 在CPU上执行时就需要将其转换为整型运算器ALU执行运算的默认长度
//总结 通用CPU是难以实现两个长度小于int类型长度的操作数直接相加运算的(虽然机器指令中可能有这种字节相加指令)
//所以 表达式中各种长度可能小于int类型长度的整型值 都必须要先转换为int/unsigned int 然后才能送入CPU中执行运算
//此外 当以%d(整型)来打印一个char类型变量时 也需要进行整型提升！！！
//如何进行整型提升呢？(详细)
//整型提升是按照变量的数据类型的符号位来提升的
//以两个例子来说明-->
//正数的整型提升:
//int main()
//{
//	char a = 1;
//	//1的补码：00000001(只有8位 因为char类型)
//	char b = 0;
//	//0的补码：00000000
//	char c = a + b;
//	//a+b的补码： 因为a,b的字长均小于32位(int 类型) 所以需要进行整型提升 然后再进行相加运算
//	//a的符号位(8位中的第一位)为0 所以整型提升时在其前面补全0即可：00000000000000000000000000000001
//	//同理b整型提升结果：00000000000000000000000000000000
//	//再进行相加=00000000000000000000000000000001
//	//再截断->00000001 即c变量中存储的数据就是00000001
//	printf("%d\n", c);//1
//  //这里需要打印一个整型 但是c是字符型 字节长度小于整型 故需要进行整型提升->00000000000000000000000000000001->打印1
//	return 0;
//}
//负数的整型提升:
//int main()
//{
//	char a = -1;
//  //a的补码：11111111
//	char b = 0;
//  //b的补码：00000000
//	char c = a + b;
//  //同理我们还是先进行整型提升 a(符号位为1)的整型提升11111111111111111111111111111111
//  //再用补码进行加法运算：11111111111111111111111111111111
//  //截断->11111111 这就是c中存储的数据
//	printf("%d\n", c);//-1
//  //这里依然需要进行整型提升 11111111111111111111111111111111 再打印->-1
//	return 0;
//}
//补充：无符号类型数据整型提升默认补0

//截断？
//当数据类型超过存储类型的大小时 编译器会自动进行截断操作(截断的是补码！) 以确保这个存储空间至少有数据存储<哪怕不完整>
//比如  十进制的256->
//int main()
//{
//	char a = 256;
//  char b=0;
//  char c=a+b;
//	printf("%d\n", c);//0 因为256的补码是 100000000 因为截断从后向前取<从2^n地位向高位取> 所以第九位的1被截断了 所以补码为八个0
//	return 0;
//}
//再比如：
//int main()
//{
//  char z=0;
//	char a = 255;
//  char b=a+z;
//  //a的补码 11111111 整型提升后:11111111111111111111111111111111 加0再截断:11111111
//	//因为符号位为1 所以需要转换为原码:10000001->-1
//	char c = 511;
//  char d=c+z;
//  //c的补码 111111111 整型提升后:11111111111111111111111111111111 加0再截断:11111111
//	//同理 转换为原码后对应十进制 同样是-1
//	printf("%d\n%d", b, d);//-1 -1 这里同样要分别进行整型提升
//  //但是这里的-1本质上是因为char类型表示范围有限 导致数据每相差256存入的补码就相同
//	return 0;
//}
//由此可见 截断会导致数据存储的错误和丢失 
//int main()
//{
//	//再次提醒 一个八位的二进制补码表示法能表示的数的范围是-128到127 也就是说char类型能表示的数的范围就是-128到127
//	//因为127的补码加1即01111111+1=10000000 因为符号位变成1了 所以需要-1->01111111 再取反->10000000 仍然是这个数本身
//	//但是补码中是没有-0的 所以这个数：10000000被规定为-128
//	//所以如果用一个字节来存储数据(例如char类型) 那么数据每相差256时存储的补码(8位)就都是一样的 即对于计算机而言这两个数据也就都是一样的了
//	char  a = 128;
//	printf("%d\n", a);//-128
//	return 0;
//	//同理(unsigned)int类型能表示的数据范围是-2^31~2^31-1 //long int范围则是-2^64~2^64-1
//}int main()
//{
//	//再次提醒 一个八位的二进制补码表示法能表示的数的范围是-128到127 也就是说char类型能表示的数的范围就是-128到127
//	//因为127的补码加1即01111111+1=10000000 因为符号位变成1了 所以需要-1->01111111 再取反->10000000 仍然是这个数本身
//	//但是补码中是没有-0的 所以这个数：10000000被规定为-128
//	//所以如果用一个字节来存储数据(例如char类型) 那么数据每相差256时存储的补码(8位)就都是一样的 即对于计算机而言这两个数据也就都是一样的了
//	char  a = 128;
//	printf("%d\n", a);//-128
//	return 0;
//	//同理(unsigned)int类型能表示的数据范围是-2^31~2^31-1 //long int范围则是-2^64~2^64-1
//}

//整型提升->进阶示例:
//int main()
//{
//	char a = 5;
//	//原码/补码:00000101 
//	char b = 126;
//	//原码/补码:
//	char c = a + b;
//	//a的整型提升:00000000000000000000000000000101 b的整型提升:00000000000000000000000001111110
//	//相加：00000000000000000000000010000011 截断->10000011 这也就是计算机中变量c真正存储的数据
//	printf("%d\n", c);
//	//此处要以整型打印c c为字符型 所以又一次需要进行整型提升
//	//10000011->11111111111111111111111110000011(补码)->10000000000000000000000001111101(原码)->-125 所以最终打印-125
//	return 0;
//}

//改错：
//int main()
//{
//	char a = 0xb6;
//	short b = 0xb600;
//	int c = 0xb6000000;
//	if (a==0xb6)
//	{
//		printf("a");
//	}
//	if (b== 0xb600)
//	{
//		printf("b");
//	}
//	if (c== 0xb6000000)
//	{
//		printf("c");
//	}
//	return 0;
//}
//最后只打印了c 这是为什么
//对a进行分析:
//1_a是一个字符型变量 0xb6=182>127 超出了字符型数据存储的范围 二进制10110110 首位的1被默认为符号位 也即存储的实际数据为-110110
//2_在用a来进行判断语句时 也会默认对其进行整型提升 a的整型提升11111111111111111111111110110110
//而0xb6的二进制序列:00000000000000000000000010110110 显然 经过整型提升后的两者不等 所以不打印
//若要修改 可将a定义为无符号整型 
//同理 b的二进制：1011011000000000(16位) 也是如此 
//而c因为本身就是整型 所以哪怕数据溢出了(首位为1) 但是无需进行整型提升 所以不影响判断语句

//int main()
//{
//	char a = 1;
//	printf("%zu\n", sizeof(a));//1
//	printf("%zu\n", sizeof(+a));//4
//	printf("%zu\n", sizeof(-a));//4
//	//为何后两者打印出来是4？ 因为+ -均为操作符 一旦需要操作不足整型的数据 就会进行整型提升 所以最后计算出的大小是4个字节
//	return 0;
//}

//算术转换 
//前面我们讲的都是字节长度小于int类型的数据 在进行操作时 这类数据会发生整型提升 那么字节长度>=整型的呢？
//这里就要讲到算术转换 同属于隐式类型转换的一种
//当操作符的各个操作数属于不同类型时 为了正常进行操作 必须要将各个操作数化为同一类型数据 下面的转换体系称作->寻常算术转换
//long double
//double
//float
//unsigned long int
//long int
//unsigned int
//int
//在这个体系中 算术转换是从下往上进行转换的 如果类型排名低 则转换为上面的类型后再执行操作

//但是算术转换必须要合理 否则就会出错
//int main()
//{
//	double a = 3.14;
//	int num = a;//此处赋值操作符这里发生的转换其实是double->int 违背了算术转换的顺序 所以产生了精度丢失
//	printf("%d\n", num);//3
//	return 0;
//}

//表达式求值 ->三个考虑因素:
//1_操作符的优先级 ()>[]>.= -> >后置++=-->!>~>单目+ - >前置++ -->*=&>sizeof>(类型)>*=/>%>双目+->移位>判断>逻辑>各种赋值>,
//2_操作符的结合性<优先级相同时再考虑结合性>
//3_是否控制求值顺序
//注意 优先级只影响相邻操作符 不相邻操作符之间的执行顺序是不受优先级影响的
//第3点 控制求值顺序的操作符又称“聪明的操作符” 一般只有四个：&& || ?: , 
//这是因为 以&&为例 当&&操作符执行过程中 一旦有0存在 则立即停止后续执行 ||操作符也是当有1存在则不必再进行后续表达式的执行
//条件操作符 ? : 条件满足则只执行表达式二 不满足则只执行表达式三 还有,操作符 从左到右依次执行 但是最终结果只取最后的执行结果
//这类操作符会随着表达式的变化改变执行情况 或者说控制求值顺序 所以需要额外注意！

//一些问题表达式：
//即 不能通过三个考虑因素来确定的表达式执行 例如：
//a*b+a*c+a*d=? 我们可以确定*在+之前 但是第三个*在第一个+之前还是之后就无法确定了 因为两者是不相邻的
//1 3 2 5 4 这是第一种顺序
//1 4 2 5 3 这是第二种顺序
//两种顺序都不违背优先级和结合性 但是就是无法确定 这就是问题表达式
//再比如：
//c + --c;  
// 2 1 这是从优先级的角度分析的结果 似乎并没有错 但是问题在于->第一个c到底是自减之后的c还是自减之前的c呢？
//这取决于第一个c究竟是什么时候从存储空间中取出进入预备队列的 可能是一开始就取出了c 也可能是等到自减后轮到加法运算的时候再取出c
//这属于时间逻辑上的不确定 导致整个表达式变成了问题表达式 
//但是/！！！需要知道的是绝大部分编译器中这里的c都默认是进行加法运算时才调用 也就是后调用法则
//非法表达式：
//int main()
//{
//	int i = 10;
//	i = i-- - --i * (i = -3) * i++ + ++i;
//	printf("i=%d\n", i);
//}
//你可能想不到 这个表达式在不同的编译器中几乎都是不同的结果 因为这里汇集了前面两种问题表达式的全部问题:
//即 不相邻操作符的执行次序不确定 以及  操作符和操作数之间时间逻辑的不确定 所以这种代码写法是极其的错误示范
//比较隐蔽的问题表达式:
//int fun()
//{
//	static int count = 1;
//	return ++count;
//}
//int main()
//{
//	int ans = 0;
//	ans = fun() - fun() * fun();
//	printf("answer=%d\n", ans);//-10
//	return 0;
//}
//在大多数编译器上 这段代码是没有问题的 都是-10 但是不代表它就是对的 事实上这段代码也是问题代码
//由于static修饰的局部变量变为了静态变量 而静态变量无法被二次创建(至少同一个源文件中不行) 所以每调用一次fun函数 count就会+1
//那么问题来了 我们知道的是 *肯定在-之前 但是具体到函数的调用次序呢？ 很遗憾 这又是无法确定的
//可能的调用次序下运算结果有 
//2-3*4=-10		4-2*3=-2	 2-4*3  4-3*2  3-2*4  3-4*2等等 这些次序下又会导致不同的运算结果
//注意！此处2-3*4与2-4*3看似是相同结果 但那是因为这里的3/4都是数据而非需要执行的表达式 如果是执行表达式 那么顺序不同就会导致结果不同
//所以两者只要执行次序不同 那就是不同的表达式 
//因此 这段代码仍然是问题代码<函数的调用次序/优先级是无法确定的!>

//最后一个----也是很容易错的一个问题表达式：
//int main()
//{
//	int a = 1;
//	int b = (++a) + (++a) + (++a);
//	printf("b=%d\n", b);
//	return 0;
//}
//可能的结果1:=9 显然这是2+3+4得出来的 因为认为第一个++a之后a=2 然后左边的值就调用了 不变了 这里理解的是先调用法则
//可能的结果2:=12 这也是VS跑出来的结果 默认的是后调用法则 同时先进行的++运算 当a=4之后再进行两个加法运算
//可能的结果3:=10 这是linux环境下运行的结果 同样是后调用法则 但是在前两个++执行完后立即进行了第一个加法 然后a进行第三个++ 再是第二个加法
//...
//这段代码的误区主要在两点:1 ++a之后a这里的值是确定了吗 还是随着后面一个++a继续加1?-->调用法则问题
//2 第一个加法执行的顺序在第三个++a之前还是之后?-->不相邻操作符的执行顺序?
//值得注意的是 这种问题常拿来做考题 哪怕它本身是不准确的 但是我们仍然要知道其在主流编译器/环境中执行的结果 比如上面的12..10..

//总结 上述的问题表达式 本质上都是因为在C语言中存在这些未定义的操作规则
//如果通过三个考虑因素:操作符的优先级，结合性，是否控制求值顺序；都无法确定表达式的执行路径 那么这个表达式就是问题表达式！


//习题：走台阶问题
//假定有一个人在走n阶台阶(n>=1&&n<=30) 每次可能走一阶或者两阶 求总共的走法数:
//int fib(int n)//用于计算台阶数n时可能的走法数
//{
//	if (n > 2)
//	{
//		int count = fib(n - 1) + fib(n - 2);
//		//人一步走一个/两个台阶(共n个台阶)->那么一步之后就剩n-1/n-2个台阶 而n-1/n-2个台阶又对应着fib(n-1)/fib(n-2)种走法
//		//由分类加法原理可知 fib(n)=fib(n-1)+fib(n-2).. 可见这就是类似于斐波那契数列的一个递归表达式
//		//而由于n最小为1 所以欲使fib(n-2)存在 那么满足该递归的n必须要>2  所以限制条件就是n>2 而逼近手段则是n-1和n-2
//		return count;//返回总数
//	}
//	else
//		return n;//递进深入的最底层就是fib(1)=1和fib(2)=2 回归向上时必须要返回这两者的确定值
//}
//int main()
//{
//	int n = 1;
//	scanf("%d", &n);
//	int c=fib(n);//计算台阶数n时可能的走法数
//	printf("%d\n", c);
//	return 0;
//}


//习题：删除指定序列中指定数据 (均为整型)
//思路一:采用循环覆盖 如果查找到指定数据则以该数据为基准从后面的数据开始往前依次覆盖 反之继续向后遍历
//int del(int *arr, int x)
//{
//	int count = 0;
//	for (int i = 0; i < 50; i++)
//	{
//		if (arr[i]==x)
//		{
//			for (int j = i; j < 49; j++)//49设为上限是为了避免出现数组的溢出
//			{
//				arr[j] = arr[j+1];//j从i开始是为了减少计算量
//			}
//			count++;
//			if (arr[i] == x)//这一步也十分重要!  作为自查的一步 可以确保在出现连续需要删除的数时将这些数都给覆盖掉
//			{
//				i--;
//			}
//		}
//	}
//	return count;//count指代这一组数据中删除数的数目
//}
//int main()
//{
//	int n ,x= 0;
//	int arr[50] = { 0 };
//	for (int i = 0; i < 50; i++)
//	{
//		scanf("%d", &n);
//		arr[i] = n;
//	}
//	scanf("%d", &x);
//	int c=del(arr, x);//传址调用
//	for (int i = 0; i < 50-c; i++)//为了实现删除的效果 有多少个删除数就少打印多少次！
//	{
//		printf("%d ", arr[i]);
//	}
//	return 0;
//}

//法二:采用跳跃覆盖 若数据不是指定数据 则随着遍历进行自我覆盖 反之 遍历继续但不覆盖<均在一个数组上进行操作>
//int del(int* arr, int x)
//{
//	int j = 0;
//	for (int i = 0; i < 50; i++)
//	{
//		if (arr[i]!=x)
//		{
//			arr[j++] = arr[i];//arr[j++]=arr[j]---->j++
//			//这种方式就好像:
//			//i-->
//			//0 1 2 3 4(下标) 当遇到指定数据时 i继续走 但是j停下 直到下一个非指定数据时 j再往前 这样就实现了删除的效果
//			//j-->
//		}
//	}
//	return j;//经历一次遍历后 此时j的值已经是删除指定数据后数组下标的最大值了(因为j随着跳跃覆盖在自加) 所以返回j的值作为打印数组时的上界
//}
//int main()
//{
//	int arr[50] = { 0 };
//	for (int i = 0; i < 50; i++)
//	{
//		scanf("%d", &arr[i]);
//	}
//	int x = 0;
//	scanf("%d", x);
//	int c=del(arr, x);
//	for (int i = 0; i <c+1; i++)
//	{
//		printf("%d ", arr[i]);
//	}
//	return 0;
//}

//但是！！！不知你是否发现 上面两种方式都有一个统一的问题 就是数组的长度固定 但是真正输入数组的元素个数并不确定 这将导致程序运行出错
//例如输入五个数据 删除一个数据 数组长度为10 这时程序会认为欲删除的数据也是数组元素的一部分 并且不做出别的反应 直到输满10个数据
//如果这个问题出现在OJ中 往往很好解决--->直接采用变长数组 根据输入元素数来决定数组长度
//如果不是在OJ中 那这个问题就有点麻烦了 我们知道 虽然VS极大程度兼容C99 但是就是不支持变长数组 
//如果我们要实现类似的效果 就需要用到动态数组 这个以后再谈..综上 至少不要随便将数组长度固定 否则程序会出bug


//习题：输入数组数据及数据个数 求最大<100>最小值<0>之差? 
//常见思路：---由于这道题也需要用到变长数组 所以此处只是给出思路 不写代码
//1-定义数组arr[n] 输入数据个数<n> 确定数组长度 然后再循环输入数据到数组中 然后同时定义max,min 假设为arr[0] 
//采用打擂台方式<一轮循环即可 无需二次遍历> 决出最大最小值 然后输出差值
//2- 因为给定最大最小的极限值 所以可以在输入数据到数组前 定义max=0;min=100 然后在输入数据到数组时 每输入一个数据就打一次擂台
//同时比较最大和最小 然后输入完也就决出了最大最小 最后输出差值！
//这种方式精妙之处就在于只用一个循环就解决了输入和比大小 --->注意max设定为0而不是100 否则任意一个数都<=max min同理


//习题：字母大小写转换<如果是大写则转换为小写 反之亦然> 多行输入 一行一字母 同时多行对应输出
//int main()
//{
//	char ch = 0;
//	while (1)
//	{
//		scanf("%c", &ch);
//		if (ch>='a'&&ch<='z')
//		{
//			printf("%c\n", ch - 32);
//		}
//		else
//		{
//			printf("%c\n", ch + 32);
//		}
//	}
//	return 0;
//}
//问题一就出现了：多行输入时计算机并不知道何时输入结束 这里我们就要用到EOF了
//我们已经知道 EOF(End Of File)是一个int类型的宏定义 扩展为负数常量表达式(通常为-1) 常被一些函数(如scanf)作为返回值使用 
//表示已到达文件的末尾 或输入流的末尾  而在输入操作中 EOF常被用于判断何时终止读取操作 
//scanf返回值的几种情况: scanf("%d %d",&a,&b)
//因为scanf每次只读取一个数据 如果成功读取了所有指定格式的参数 则返回值和参数数量相等-->1..2..3..
//如果输入数据的格式不符合指定格式 或者无法成功解析为指定的参数类型 则返回值为0 !!如果第一个数据格式出错 则无论后者如何均返回0
//如果遇到文件结束符EOF 则返回EOF 表示到达了文件的末尾或者输入流的末尾
//综上所述 我们可以通过scanf的返回值来判定是否达到了输入结束的状态
//int main()
//{
//	char ch = 0;
//	while (scanf("%c",&ch)==1)//或者scanf("%c",&ch)!=EOF
//	{
//		if (ch>='a'&&ch<='z')
//		{
//			printf("%c\n", ch - 32);
//		}
//		else
//		{
//			printf("%c\n", ch + 32);
//		}
//	}
//	return 0;
//}
//第二个问题又出现了！ 为什么打印到后面几个就出现了*..之类的字符?
//这是因为scanf不能读取空白(例如此处的换行符:\n) 每当遇到空白时 scanf默认只读取到空白前面的数据就结束了 不会继续读取 
//而按照前面的知识:这些空白又会保留在缓冲区中 因为本身就是字符 而此处的占位符也是%c 所以并不会出现格式不匹配的问题->
//补充 如果此处是%d 当我们输入非数字字符 这个字符就会被保留在缓冲区 并且由于格式不匹配 会导致scanf一直返回0 程序陷入死循环 
//->所以会正常返回1 然后进入else分支 然后空白(如\n)+32自然会打印出别的字符 所以我们还需要进行一点点修改:
//这里我们就需要用到getchar()来清空缓存区 这是最常见的做法 事实上我们也可以在%c前面加上一个空格来跳过缓冲区中的空白(\n)：
//int main()
//{
//	char ch = 0;
//	while (scanf("%c", &ch) == 1)//或者scanf("%c",&ch)!=EOF
//	{
//		if (ch >= 'a' && ch <= 'z')
//		{
//			printf("%c\n", ch - 32);
//		}
//		/*else if (ch>='A'&&ch<="Z")
//		{
//			printf("%c\n", ch + 32);
//		}用else if替换else也可以 因为哪怕存在\n 但是\n不满足判断条件 也就不会进入else if分支 也就不会出现错误打印*/
//		else
//		{
//			printf("%c\n", ch + 32);
//		}
//		getchar();//清空缓存区
//	}
//	return 0;
//}

//补充：事实上 判断是否是大小写/大小写的转换 均存在相应的函数:
//islower:判断是否是小写字母---isupper:判断是否是大写字母 tolower:转换为小写字母---toupper:转换为大写字母
//所以上面的代码片段可以转换为:
//注意 这段函数需要调用<ctype.h>的头文件！！！
//int main()
//{
//	char ch = 0;
//	while (scanf("%c", &ch) != EOF)
//	{
//		if (islower(ch))
//		{
//			printf("%c\n", toupper(ch));
//		}
//		else if(isupper(ch))
//		{
//			printf("%c\n", tolower(ch));
//		}
//	}
//	return 0;
//}

//综上所述:以后在处理多行输入问题时常需要用到scanf的返回值来作为判定依据 勿忘！


//习题：判断是否是字符 多行输入 每行一个
//int main()
//{
//	char ch = 0;
//	while (scanf(" %c",&ch)!=EOF)
//		//事实上 前面我们提到 除了用getchar以外 我们还可以在%c前面加空格来跳过下一个格式匹配的非空白字符前所有的空白字符
//	{
//		if (ch>='A'&&ch<='Z'||ch>='a'&&ch<='z')
//		{
//			printf("%c is an alphabet.\n", ch);
//		}
//		else
//		{
//			printf("%c is not an alphabet.\n", ch);
//		}
//		//getchar();//清空\n 只不过我们此处用%c前加空格来跳过下一个非空白字符前所有空白字符 自然也就跳过了\n
//	}
//	return 0;
//}

//同上 这里也有一个库函数可以用于判断是否是字母:isalpha----alphabet:字母(表)
//int main()
//{
//	char ch = 0;
//	while (scanf(" %c",&ch)!=EOF)
//	{
//		if (isalpha(ch))
//		{
//			printf("%c is an alphabet.\n", ch);
//		}
//		else
//		{
//			printf("%c is not an alphabet.\n", ch);
//		}
//		//getchar();
//	}
//	return 0;
//}


//习题：变种水仙花问题： 任意数字 如果该数字拆分之后的乘积之和等于它本身 则称该数据为一个"幸运数" 如：
//1461 可以拆分成三组：1和461;14和61;146和1 每组乘积之和相加=1461 故1461是一个"幸运数" ----->那么 请求出五位数中所有的"幸运数"
//思路：先考虑如何将其拆分 毕竟乘积之和很好表示
//1461->1(1461/10^3) 461(1461%10^3)
//		14(1461/10^2) 61(1461%10^2)
//		146(1461/10) 1(1461%10)
//我们发现 所谓的拆分其实就是对该数据的整除操作和取余操作 并且是以倒序的10的次方为拆分顺序
//那么：
//int main()
//{
//	for (int i = 10000; i <=99999; i++)
//	{
//		int k, sum = 0;
//		for (int j = 4; j > 0; j--)
//		{
//			k = (int)pow(10, j);//pow用于计算幂(次方) 但是返回值类型是double 这里我们要用整数除法 所以必须对其进行类型转换
//			sum += (i / k) * (i % k);
//		}
//		if (sum==i)
//		{
//			printf("%d ", i);
//		}
//	}
//	return 0;
//}


//指针！！！ 又开始啦------>>
//回顾 指针是什么呢?
//指针就是地址 ---->>口语中的指针指的是指针变量 是用来存放地址的变量
//而一个地址编号对应的是内存中一个最小单元->字节 注意!!!地址不占用内存空间 地址是硬件在设计时就已经规定好了的 但是存储地址是要占用空间的
//前面已经讲过 32位计算机中 最多能有2^32个地址 也就说明地址最多管理2^32个字节=4GB的内存空间 而64位计算机中地址最多管理16EB的内存空间
//同时32位计算机中一个指针(变量)应该占4个字节大小 64位计算机中一个指针(变量)就应该占8个字节的大小
//指针类型？
//指针类型的意义？
//前面我们讲到 指针有int* char* long*等等各种类型 但是我们又知道 所有指针在一个环境下的大小都是一样的 那么区分指针类型的意义是什么？
//事实上 指针在存放地址这件事上确实没有差异 我们也可以用 char*来存放int 类型的a的地址 如果报警告也可以强制类型转换 这并不出错
//但是 指针类型的区分 更重要的意义是决定指针在被解引用时能被访问/操作多少个字节
//如果是int*类型的指针 在解引用时访问的是4个字节 
//如果是char*类型的指针 在解引用时则访问的是1个字节 
//当我们用char*类型的指针来存放整型变量的地址时 能存放 但不能正常访问 因为解引用该指针时只能访问到第一个字节
//整型变量占4个字节 而后面的3个字节都无法正常访问到 就会导致出错其他类型同理..
//那么 访问权限大小相同的指针可以混用吗？  答案是否定的 因为指针类型是视角 视角不同 那么对内存的访问方式就不同<着重理解！>
//int main()
//{
//	int a = 0;
//	int* pa = &a;
//	float* pf = (float*)&a;
//	//float*和int*的指针有着相同的大小和步长 如果两者可以混用 那么下面对其的赋值操作应该是等效的
//	*pa = 100.0;//0x64 00 00 00
//	*pf = 100.0;//0x00 00 c8 42
//	//然而我们发现 两者赋值后 a的值并不相同  这是因为视角不同！
//	//解引用float*的指针时编译器以为它指向的是浮点型数据 于是用存储浮点数的方式在相应的内存空间中对其进行存储操作 
//	//但是浮点数的存储和整数是不同的 所以float* 和int*两者的指针解引用再赋值后得到的a是完全不同的结果 因此两者是不可以混用的！
//	//另外 *pa=100.0 但是最后却赋了整型的100 也是因为指针pa解引用时是按照指向整型数据来理解的
//	//所以以整型的存储方式来存储100.0 自然也就只取了整数形式的100来存储
//	return 0;
//}

//指针类型决定了指针的步长--即指针+/-1操作时跳过的字节数
//int*类型pa+1--->地址+4 直接跳过了4个字节
//char*类型pc+1--->地址+1 只跳过了1个字节  由此观之 指针类型决定了指针前进/后退时的步长
//int main()
//{
//	int a = 0;
//	char* pa = (char*)&a;
//	//强制类型转换->a变量原本是int类型 但是我们用char*类型的指针来存储其地址 这时编译器会报错 而在&a前+(char*)则不会报警告
//	int* pc = &a;
//	printf("%p\n", pa);//0000002B718FF854
//	printf("%p\n", pa + 1);//0000002B718FF855 用char*类型的指针来存储整型变量的a的地址 步长只取决于指针类型-->1
//	printf("%p\n", pc);//0000002B718FF854 和pa一样 因为这两个指针里放的地址都是a的地址
//	printf("%p\n", pc + 1);//0000002B718FF858 因为int*类型的指针的步长是4 所以pc+1时地址+4
//	return 0;
//}//如果我们要访问一个整型所占的第二 三 四个字节 就可以通过转换指针类型(char*)+1(然后解引用)来实现

//内存可以看作是一片空间 而指针的类型就是访问这片空间的不同方式 例如int*以四个字节为单位进行访问 char*则以1个字节为单位访问
//本质上所谓的类型其实就是视角 是编译器对于所指向内存空间的解读方式
//如果是float*的指针 那么解引用时编译器就会认为指向的内存空间中存放的是float型数据 也就会按照处理float类型数据的方式对该空间进行处理


//野指针：指针指向的位置是不可知的(随机的 不正确的 没有明确限制的)
//例如：1_指针未初始化
//int main()
//{
//	int* p;//这并不是初始化 只能说声明了一个int*类型的指针 其中放的是随机地址 0xcccccccc
//	*p = 10;//由于p没有初始化 所以p也就没有明确的指向 是完全随机的 所以它是一个野指针 而*p则是非法访问内存 编译器报错！
//	return 0;
//}

//2_指针越界访问
//int main()
//{
//	int arr[10] = { 0 };
//	int* p = arr;
//	for (int i = 0; i <=10; i++)
//	{
//		*p++ = i;//其实这里还有一种写法: *(p+i)=i; 因为i从0开始++ 所以用p+i可以代替p++
//		//当第十一次进入循环时 p已经前进到超过了整个数组长度 那么p所指向的位置就不确定了 p可能+1/2/4/8..
//		//p就成了一个野指针 此时再解引用p就是在非法访问内存
//	}
//	return 0;
//}

//3_指针指向的空间被释放
//int* test()
//{
//	int a = 0;
//	return &a;
//}
//int main()
//{
//	int* p = test();//我们知道 函数中的局部变量的作用域仅限于函数本身 一旦程序走出函数范围则变量销毁 其空间也返还给操作系统
//	//而p中存放的是函数返回的变量地址 但是返回到主函数时这个地址对应的空间已经被释放掉了 虽然目前为止仍没有什么实质性错误
//	//但是由于p的指向空间被释放掉了 那么p所指向的到底是什么就不确定了 p也就成了一个野指针
//	//一旦后面对p进行解引用访问 这种情况就也是在非法访问内存---->
//  //但如果这个地址还没有被使用 那么*p仍然能访问到原来存放的数据 只是这块空间不属于程序员能支配的了 而是属于系统来分配的
//  //可能这时哪怕再加一个打印hehe的语句 就会导致*p的结果变化
//	return 0;
//}


//如何安全使用指针?
//1_指针一定要初始化
//2_小心指针的越界
//3_指针指向空间被释放/当前不使用该指针/当前不知道要指向哪个空间--->初始化为空指针NULL(c语言中NULL即(void*)0)
//int main()
//{
//	int* p = NULL;//假定一个指针p 当我们目前不确定要它指向哪个空间时既可以赋NULL 即放置一个空指针给它
//	//注意！！空指针存放的是零地址 没有指向的空间 所以*空指针是非法的 会导致程序崩溃 因为没有写入权限
//	if (p!=NULL)//所以光放置空指针还不够 我们还需要设置这样一个判断语句 才能避免以后解引用时操作到空指针
//	{
//		*p=10;
//	}
//	return 0;
//}//上面就是一套经常使用的技巧来放置空指针
//4_避免返回局部变量的地址
//5_使用指针前检查其有效性


//指针运算
//1_指针+-整数
//2_指针-指针
//3_指针的关系运算
//示例：
//#define NVL 5
//int main()
//{
//	int arr[NVL] = { 0 };//下标上限是4
//	int* p ;//未初始化 此时为一野指针
//	for ( p = &arr[0]; p <&arr[NVL]; p++)//这里的p++其实就是指针+-整数的示例 指针加/减整数就是地址前进/后退相应的步长
//	{//此外 这里的p<&arr[NVL]就是指针的关系运算之一-->判断其存储的地址和另一个地址的大小 而数组地址由小到大 所以p会自加直到>=&arr[NVL]
//		*p = 0;//注意区分*p++和(*p)++ 前者是 *p然后地址++ 等于此处的*p然后p++；后者是 *p然后在指向的对象上++
//	}
//	//一个问题难道此处的p++到&arr[5] 超过数组地址范围 不属于指针的越界访问?------------->不属于
//	//因为我们并没有操作这个地址 这个地址是真实存在的 我们只是将其与arr[5]的地址进行比较 只是看了一眼 或者说:越界了 但是没有访问
//	//同理 arr[5]也数组越界了 但是我们并没有访问 只是看了一眼它的地址<也就是&arr[4]+4  +4是为了跨过arr[4]所占的4个字节>
//	return 0;
//}

//int main()
//{
//	int arr[10] = { 0 };
//	printf("%zd\n", &arr[9] - &arr[0]);//9
//	printf("%zd\n", &arr[0] - &arr[9]);//-9 说明指针减指针结果可能是负数
//	//可见 |指针-指针|=两指针之间元素的个数 而不是地址的差
//	//此外这里用%d作为占位符是会报警告的 因为类型不匹配 而用%zd可以自动匹配对应类型:)
//	return 0;
//}
//指针-指针的前提>> 两指针指向的对象必须要在同一大空间内 例如:指向的对象都在同一个数组中
//如果两对象各自在一个整型数组中 也是不满足相减条件的 哪怕此时两指针类型相同 指向的对象类型也相同 但是由于不在一个大空间中 就不可以相减


//补充：NULL和void*
//在C语言中 NULL表示空指针 不指向任何一个内存空间
//事实上 NULL是一个宏常量定义 在stdio.h中被定义为 (void*)0 但是NULL并不是一定等同于0
//因为NULL仅为了代表空值 也就是指向一个不被使用的地址 而大多数系统中不被使用的地址就是0地址 所以才有这样的定义
//而(void*)强制类型转换则是为了让其成为一个无类型指针(便于后续赋值) 这样 NULL就代表了空指针的含义
//而在C++中 NULL则仅表示整数0

//void* 表示该指针的类型是无类型 无类型指针是一种通用指针 可以指向任意类型的数据对象 其具体使用有以下几点:
//1_任何类型的指针都可以给void*类型的指针进行赋值 编译器会自动进行隐式类型转换
//2_而若要void*类型的指针给其他指针进行赋值 则需要进行显示类型转换
//3_void*指针可以直接与其他指针进行比较其中存放的地址是否相同
//4_void*类型的指针本身并不能直接操作(访问) 因为它具体指向的什么类型的对象并不确定 只有当它进行类型转换后才具有操作意义
//此外 void*类型的指针也不能+/-整数   也就是说它不具有步长这一概念
//5_void*类型指针一样可以通过NULL<c语言>/nullptr<c++>来初始化为一个空指针
//6_当void指针作为函数的输入和输出时 表示可以接受任意类型的输入指针和输出任意类型的指针 因为编译器会自动进行类型转换 这非常好用


//指针-指针的应用:模拟strlen函数
//int my_strlen(char* st)
//{
//	char* s = st;//st里面存放的是传过来的首字符的地址 也就是'a'的地址
//	while (*st!='\0')
//	{
//		st++;
//	}
//	return (int)(st - s);//指针-指针的返回类型一般为_64int 下面用int接受会报警告 所以这里再强制类型转换一下
//}
//int main()
//{
//	int len = my_strlen("abcdef");
//	printf("strlen= %d\n", len);
//	return 0;
//}

//指针的关系运算
//最常见的就是上面示例中的比较地址大小的运算 但是注意 这里有一条规则：
//就是C语言标准规定 允许指针向后越界进行比较 但是不允许向前越界比较
//例如:数组长度为5  p为指针
//for (p = &arr[4]; p >=&arr[0]; p--)
//{
//	*p = 0;
//} 在这种写法中 就会出现&arr[-1]和&arr[0]的比较 向前越界了 虽然编译器不会报错 但是标准是不允许的
//如果要向前比较可以采取这种写法:
//for ( p = &arr[5]; p >&arr[0];)
//{
//	*--p = 0;
//} 这种写法下 就不会出现&arr[-1]了 也就不存在向前越界比较了


//指针和数组:
//数组和指针最常见的联系?----------->数组名非两个特例下就是首元素的地址 而数组中元素的地址差值又是相等的 p++可以依次访问
//printf("%d\n",*(p+i));
//printf("%d\n",*(arr+i));//数组名就是地址的话 我们也完全可以解引用数组名(+i) 这其实就是arr[i]的原理 当然 和解引用指针的效果自然也是一样的


//二级指针(双指针)：
//int main()
//{
//	int a = 0;
//	int* pa = &a;//*表明这是一个指针 int说明其指向的对象是int类型的
//	//前面说过 指针是变量 会占用内存空间 也就有内存中相应的地址 而二级指针就是用来存放一级指针(pa)的地址的
//	int** ppa = &pa;//X64中pa占8个字节 &pa则取出了首字节的地址 而后又作为ppa中存放的地址
//	//第二个*表明这是一个指针 而int*是说明指向的对象是int*类型的
//	**ppa = 10;//一级指针只需要一次解引用即可访问对象 而二级指针需要两次解引用 先访问一级指针 再访问一级指针指向的对象
//	printf("%d\n", a);//10
//	return 0;
//}


//指针数组：(核心是数组)
//存放指针的数组就是指针数组
//int main()
//{
//	int a=10,b=20,c=30;
//	int* parr[3] = { &a,&b,&c };//parr[]就是一个指针数组 其中元素的类型是int*的指针 也就是说其中存放的是整型对象的地址
//	for (int i = 0; i < 3; i++)
//	{
//		printf("%p ", &parr[i]);//彼此相差8 因为&parr[0]实际上是& &a 取的是一级指针的地址 X64一个指针占8个字节 所以地址相差8
//		printf("%d", *parr[i]);//10 20 30 *parr[0]就是* &a-->访问对象a..
//		printf("%p\n", *parr[i]);//彼此相差32？按理来说这个地址分别就是变量a b c的地址 为什么我们同时初始化abc但是地址不连续?
//		//这是因为这里存在一个概念叫做内存对齐！
//	}
//	return 0;
//}


//内存对齐：
//现代计算机中内存空间都是按照字节(byte)进行划分的 所以从理论上讲对于任何类型的变量访问都可以从任意地址开始
//但是在实际情况中 在访问特定类型变量的时候经常在特定的内存地址访问 所以这就需要把各种类型数据按照一定的规则在空间上排列
//而不是按照顺序一个接一个的排放 这种就称为内存对齐 内存对齐是指首地址对齐 而不是说每个变量大小对齐
//内存对齐的意义：
//1_提高代码的可移植性:
//有些CPU可以访问任意地址上的任意数据 而有些CPU只能在特定地址访问数据 因此不同硬件平台具有差异性
//这样的代码就不具有移植性 如果在编译时 将分配的内存进行对齐 这就具有平台可移植性了
//2_提高CPU对于内存访问的效率:
//CPU每次寻址都是要消费时间的 并且CPU访问内存时并不是逐个字节访问 而是以字长为单位访问 所以数据结构应该尽可能地在自然边界上对齐
//如果访问未对齐的内存 处理器需要做两次内存访问 而对齐的内存访问仅需要一次访问 内存对齐后可以大大提升内存访问的效率
//为什么相差32？
//不同的系统,硬件平台,编译器下 内存对齐的方式是不同的
//可以知道的是X64环境下VS编译后相邻两个变量(类型不定)的地址之差是32<递增> 而X86环境下VS编译后则是12<递减>
//还需要知道:C语言中支持自定义对齐系数 比如可以设置为不采用对齐的相邻字节布局 (似乎只有gcc编译器支持)
//int main()
//{
//	int a = 10, b = 20, c = 30;
//	printf("%p ", &a);
//	printf("%p ", &b);
//	printf("%p\n", &c);//彼此之间地址相差32 因为abc是自行定义的相邻变量 所以存在内存对齐规则
//	int arr[3] = { 10,20,30 };
//	for (int i = 0; i < 3; i++)
//	{
//		printf("%p ", &arr[i]);//彼此之间地址相差4<整型> 因为这三个整型都是定义在同一个数组中的相邻元素 所以不存在内存对齐规则 
//	}
//	return 0;
//}


//用指针数组来模拟二维数组：
//int main()
//{
//	int arr1[3] = { 1,2,3 };
//	int arr2[3] = { 2,3,4 };
//	int arr3[3] = { 3,4,5 };
//	int* parr[3] = { arr1,arr2,arr3 };//定义指针数组parr[3] 数组元素均为指针 存放的地址是一维数组的数组名->也就是首元素地址
//	for (int i = 0; i < 3; i++)
//	{
//		for (int j = 0; j < 3; j++)
//		{
//			printf("%d ", parr[i][j]);//[]的本意是访问 如果对象是地址 那么[]的作用和*其实是一样的:
//			//----->>parr[i][j]=*(parr+i+j) parr是指针数组数组名也就是其首元素arr1的地址
//			//i=0:*(parr+0+j)=*(arr1+j)=arr1[j]		i=1..
//			//通过这样的方式我们就可以模拟出二维数组 本质上是利用指针在数组元素之间灵活地跳跃
//		}
//		printf("\n");
//	}
//	return 0;
//}
//这种方式模拟出来的二维数组和真实二维数组的异同?
//异:模拟二维数组的两个数组之间就有内存对齐规则导致并不连贯 真实二维数组中所有元素都是连贯的 元素在一个统一开辟的内存空间中 
//同:真实二维数组本质上还是将其视为三个一维数组 访问时和模拟二维数组的访问原理相同-->>arr[i][j] 假定为一个二维数组
//i=0:arr[i][j]=*(arr+0+j)=arr1[j] i=1:arr[i][j]=*(arr+1+j)=arr2[j] 注意！！这里不是=arr1[1+j] 这证明访问原理是相同的


//结构体：
//结构的基础知识:
//结构是值的集合 这些值称为成员变量 结构的每个成员可以是不同类型的变量
//如何理解值的集合? 在C语言中变量有多种类型 这些内置类型的描述范围往往是单个对象 而为了描述复杂对象我们就需要用到结构体了
//例如：描述一个学生的体检结果:需要描述到姓名(char)身高体重(double)年龄(int)..生活中需要描述的对象往往是复杂的 这就需要要结构体了

//结构体的声明：
//struct tag//struct声明一个结构体类型 tag是结构体类型的标签
//{
//	member_list;//成员变量列表 成员可以是标量 指针 数组 甚至是其他结构体！
//}variable_list;//变量列表 这里的变量指的是用该结构体类型创建的变量------>
//可以不写在这里 但是后面的;一定要加 因为声明创建一个结构体类型(的变量)相当于是一条语句
//结构体可以视作内置类型的集合 声明一个结构体类型相当于是创建了一种新的类型 然后就可以直接用这个类型去创建这个新的类型的变量
//如:
//struct Peo//这个结构体类型用于描述一个人
//{
//	char name[20];
//	char tele[12];
//	char sex[5];//性别一般最多用两个字(保密)描述 占4个字节 但是因为是字符串 所以'\0'多占一个字节 所以至少要五个元素的空间
//	int high;
//}p1,p2;//p1,p2是用该结构体类型创建的两个全局变量 或者说是用该结构体类型描述的两个人
//也可以单独创建全局变量:
//struct Peo p3= { 0 };//这里的p3就是单独创建的全局变量
//int main()
//{
//	struct Peo p1= { 0 };//结构体还可以看作是一个大号的数组 所以结构体的初始化和数组的初始化方式相同
//	struct Peo p2= { 0 };//p1 p2是用结构体类型创建的局部变量 注意 如果结构体的声明放在main函数中 那么该结构体就只能在main函数中使用
//	return 0;//结构体类型的创建是不占用内存空间的！
//}
//如果结构体内嵌结构体 那么用这个复合结构体创建的变量的初始化就需要用{{},...}嵌套大括号的形式来初始化 访问时s.p.name双重访问

//结构体成员的访问：
//1_ (.)操作符 .操作符的操作数是结构体变量和结构体成员
//2_ (->)操作符 ->操作符的操作数是结构体指针和结构体成员 stu->a等同于(*stu).a 但是这里解引用必须要括起来 因为*的优先级低于.操作符
//如果要通过结构体变量访问成员 不管这个变量是实参还是形参..都直接用.操作符访问成员即可
//如果要通过结构体指针访问成员 最好直接用->操作符

//结构体传参
//两种形式：直接传结构体变量或者传结构体指针 更推荐使用后者 因为前者传递过去后形参进行拷贝 会占用很多额外的空间和时间


//习题1：
//a=1,b=0,c=3
//求b=++c,c++,a++,++a?
//这里一定要注意一点：赋值操作符的优先级高于逗号操作符！！！
//所以这个表达式的运算次序是:先++c 然后将c赋给b 然后c++ 然后a++ 最后++a 再三强调!赋值操作符的优先级高于逗号操作符

//习题2：
//求一个整数(+/-)的二进制补码中1的个数?
//按照算法效率由低到高 依次给出以下三种算法:(由于主函数内容一致 故统一使用)
//int binsum_1(unsigned int a); 此为算法2的声明
//int binsum_1(int a);//此为算法1 3的声明
//int main()
//{
//	int a = 0;
//	scanf("%d",&a);
//	int count = binsum_1(a);
//	printf("binsum_1=%d\n", count);
//	return 0;
//}
//1_ 移位-按位与算法
//通过右移操作符 每次移1后&1 如果结果是1则count++ 反之则继续右移 这样就可是使得每一位都和1进行按位与操作来判断是否是1
//int binsum_1(int a)
//{
//	int count = 0;
//	for (int i = 0; i < 32; i++)
//	{
//		if ((a>>i)&1)//注意这里的右移操作后必须紧跟着按位与1的操作 因为移位操作符只提供移位结果 而不是真的改变了数据
//		{
//			count++;
//		}
//	}
//	return count;
//}
//总结：这种算法思路简单 但是效率很低 因为任意一个数都重复运算了32次

//2_取余求二进制算法
//我们知道 十进制整数转二进制 可以通过除2求余 直到商为0为止 而余数从近0位到远0位排列开就是该数据的二进制
//而通过计算除2过程中余数为1的次数即可求出该数据二进制补码中1的个数
//int binsum_1(unsigned int a)//这里必须用unsigned int原因：
////在下面的算法中 本质上是计算的参数的原码中1的个数 如果a是负数 那么传过来的补码就会被转换为原码再计算 这显然错误
////这时如果我们用un..int来接收 就可以将传过来的补码直接当作原码来计算了(因为不存在符号位) 这样就能求负数的binsum_1了
//{
//	int count = 0;
//	while (a)//这里不用a/2的原因:
//	//1_ 如果a=1 那么a/2=0 a就不会进入循环 直接返回0了 这显然错误
//	//2_ 如果除到a=1 本来1还要再除一次 商0余1 然后count+1 但是判断条件是a/2的话 商0就不会进入循环了 导致count少1
//	{
//		if (a%2)
//		{
//			count++;
//		}
//		a /= 2;
//	}
//	return count;
//}
//总结：这种算法比较容易想到 效率中等 主要是重复的取余 取商操作拖慢了时间

//3_按位与极简算法
//int binsum_1(int a)
//{
//	int count = 0;
//	while (a)
//	{
//		a &= a - 1;
//		count++;
//	}
//	return count;
//}
//这个算法的核心就在于理解 a&a-1的结果是什么 首先 由于-的优先级比&高 所以实际上这里的a-1不用加括号 表示a按位与a-1
//以a=11为例 二进制是1011 11-1的二进制是1010 两者按位与的结果是1010 再-1按位与的结果是1000 再-1按位与得到的是0000
//三次a减一按位与a对应消去三个1 这是为什么?
//这是因为 a-1会将a从右往左数的第一个的1减为0 而又将其右侧的所有0变为1 这就导致a-1&a的结果是 左边不变 原来的1及其右边全变成0
//这实现了每次a&a-1都会消掉一个最右边的1 直到a=0退出循环 此时计算循环的次数即可求出a的二进制中1的个数
//记住了！！！a &= a-1可以用来计算a的二进制中1的个数

//习题3：
//计算两数的二进制不同位有多少
//int main()
//{
//	int a = 0, b = 0,c=0;
//	scanf("%d %d", &a, &b);
//	c = a ^ b;//a^b的结果是 两者二进制位相异则该c的二进制位结果为1 反之为0
//	int count = 0;//那么我们只需要计算c的二进制中1的个数 就能求出两数二进制中不同的位有多少
//	while (c)
//	{
//		c &= c - 1;//那么这里我们又用到了c&=c-1来计算c的二进制中1的个数
//		count++;
//	}
//	printf("bitdiffer=%d\n", count);//最后打印count即可
//	return 0;
//}
//a&=a-1计算二进制中1的个数真的是太好用啦！！！

//习题4：
//给定一个整数 分别打印出该整数二进制的奇数位和偶数位
//这里默认最左边是32位 最右边是第1位
//int main()
//{
//	int num = 0;
//	scanf("%d", &num);
//	printf("oddbit= ");//odd 奇数的
//	for (int i = 30; i >= 0; i-=2)//为什么i=30? 因为num右移30位后第一位就变成了原本的第31位 也就是最后一个奇数位了
//	{
//		printf("%d ", (num >> i) & 1);//按位或0也可以
//	}
//	printf("\n");
//	printf("evenbit=");//even 偶数的
//	for (int i = 31; i >=1; i-=2)//为什么i>=1? 因为右移1位时最右边的一位变成了原本的第2位 也就是第一个偶数位了
//	{
//		printf("%d ", (num >> i) & 1);
//	}
//	return 0;
//}

//习题5：
//int i;//全局变量 静态变量都是放在静态区 这两者不初始化时会被默认初始化为0
//而局部变量放在栈区 不初始化时会被随机指向一个垃圾值<栈区中随机找的一个值> 并且这个局部变量是会占用内存空间的
//int main()
//{
//	i--;//0-1=-1
//	if (i>sizeof(i))//注意 sizeof返回值4是size_t类型即无符号类型 而i是有符号整型 两者同时参与运算时有符号整型会发生算术转换！
//	{
//		printf(">\n");//i算术转换为无符号整型 int->unsigned int -1就变成了2^32-1 所以i显然>4 最后打印'>'符号！
//		//-1补码是111..11 第一位原本是符号位 算术转换后将其视为无符号位 那么这个补码就成了其原码 -1就变成了2^32-1
//	}
//	else
//	{
//		printf("<\n"); 
//	}
//	return 0;
//}
//警示！尤其要注意那些隐式类型转换！整型提升 算术转换...这类成因的bug往往难以发现:(

//习题6：
//输入值 打印对应'x'型 例如输入5 打印:
//*       *
//  *   *
//    *
//  *   *
//*	      *
//类似于这类图形打印问题 一句话：观察特征！ 例如此处我们观察发现这些打印*的位置具有的特征:行=列(左对角线)/行+列=n(右对角线)
//所以我们就可以这么来实现：
//int main()
//{
//	int n = 0;
//	while (scanf("%d", &n) == 1)//这里用while是为了可以多次输入 调试 而判断语句用scanf返回值 而不是固定1--->>
//	//是为了确保scanf成功正确读取才进入循环主体 因为循环本身没有终止语句 如果scanf在while主体中 当输入字符时 程序会陷入死循环!
//	{
//		for (int i = 0; i < n; i++)
//		{
//			for (int j = 0; j < n; j++)
//			{
//				if (i==j||i+j==n-1)//注意 这里必须是n-1 因为i,j从0开始且最大为n-1 即最大与最小之和为n-1 所以要打印右对角线
//								  //就必须要让i+j==n-1才行
//				{
//					printf("*");
//				}
//				else
//				{
//					printf(" ");
//				}
//			}
//			printf("\n");
//		}
//	}
//	return 0;
//}

//习题7：
//获取某年某月的天数
//思路 用变量y读取年 m读取月 再创建一个数组来放天数<二月天数固定28> 因为每年各个月份的天数都一样 只是闰年2月29天 平年2月28天
//然后写一个判断闰年的函数ion_leap_year 如果是闰年并且输入的m是2月份 那么访问该数组的结果++即可
//如果是其他时间直接访问数组对应下标即可

//补充：在c语言中 一般规定0为假 非0即为真 但是在逻辑操作符中(&& || !..)规定0为假 同时有且仅有1为真！！！


//调试：debug
//“一位优秀的程序员往往也是一名出色的侦探，每一次调试都是破案的过程。”
//可以说 会调试是作为一位程序员的基本素养

//调试的基本步骤：
//发现错误
//定位错误
//确定错误出现的原因
//给出解决方案
//修改代码 重新测试

//debug和release版本区别：
//debug版本 又称调试版本 包含各种调试信息 不作任何优化 便于程序员进行调试
//release版本 又称发布版本 往往是进行了各种优化 使得程序在代码量大小和执行速度上都是最优的 便于用户使用<没有调试信息>

//常用的几个快捷键：
//F5 完全调试 会直接执行到断点/结束 有的时候F5调试会导致终端窗口一闪而逝 其实F5更多是和F9搭配使用的
//	 但是需要知道的是 F5不会跳过程序片段中必须有外部操作的部分 例如scanf输入等等
//F9 设置/取消断点 断点常用于程序调试执行时需要中断的地方 如果程序有两个循环 我们认为错误出现在第二个循环
//	 那么我们就可以在第二个循环那一行按F9设置断点 然后按F5快速执行到第二个循环那里 避免了一行行循环调试耽误调试时间
//F10 逐过程 通常用来处理一个过程 这个过程可以是一个函数 也可以是一条语句
//F11 逐语句 这是最常用的一个操作 与F10不同 F11可以进入函数内部观察执行逻辑而不是跳过函数
//Ctrl+F5 直接执行不调试
//Shift+F5 停止调试
//Ctrl+Shift+F9 删除所有断点


//补充关于 断点
//如果一个断点在循环中 那么使用该断点+F5时 F5会在第一次循环到该断点时停下 再按F5会执行到下一次循环中同样的位置
//这是因为断点的执行逻辑认为循环中的断点应该随着每一次的循环在该断点处生效 所以不会跳过该循环直接到下一段代码
//此外 如果在一个循环中 我们认为前几次循环是没有问题的 问题出在后面几次循环 我们可以按F9设置断点 然后指向该断点
//这时会跳出更多选项 我们选择条件 在其中可以设置条件选项 例如将断点设置在x==5时 这样前几次循环就会快速跳过
//此外 我们还可以在左侧行数的更左侧直接右键 创建条件断点


//Fn的意义？ 随着个人计算机的普及 原本F1 2..的意义(多与系统操作有关)被调音量 亮度 快进 倒退等等娱乐操作给覆盖了
//而这时为了确保原先的功能能使用 就推出了Fn+F1..的操作 其作用就是使用F系列操作键原先常用的操作
//所以如果电脑直接按F系列操作键不生效 可能是需要和Fn一起按 当然有些电脑支持取消Fn的操作 这样就可以恢复其原本的功能


//调试时查看程序当前的信息：
//通过调试-窗口 我们可以看到诸多关于当前程序的信息 如变量值 终端窗口 GPU线程等等 但是注意 这个窗口必须要开始调试后才能看见！
//窗口中最常用的是监视窗口 可以便捷地查看各类变量的值地变化 数组成员 各种地址等等
//此外 如果只是简单查看变量值 可以选择变量窗口 该窗口会自动显示当前所有的变量及其值的变化 哪怕调试程序还未执行到那里
//还有自动窗口 该窗口会显示到调试程序执行之处为止的所有变量及其值和终端窗口(如果有打印)等等
//但是这两个窗口在程序进入函数时都会只展示函数中的变量值 等到退出函数时再显示原先的变量值

//关于如何在函数中查看数组元素的值
//我们知道 在main函数中 我们要查看数组每个元素的值 只需要在监视窗口输入数组名 每个元素的值就都会显现了
//但是在函数中 由于数组传参传递的是首元素地址 所以如果我们再次输入数组名 会发现程序执行到函数中时监视数组只显示了首元素的值
//这是我们可以输入 数组名,n 的方式来查看其余元素 例如arr,3就是监视arr中前三个元素 而malloc开辟的空间也可以通过这种方式监视！
//void test(int* arr)
//{
//	//
//}
//int main()
//{
//	int arr[] = { 1,2,3,4,5 };
//	test(arr);
//	return 0;
//}

//关于如何查看各类值(包括数组元素)在内存中的存储
//通过调试-内存窗口就可以查看了 如果我们要查看某变量的内存存储 但是不知道其地址 可以直接在地址栏输入&a..即可查看
//而数组查看可以直接输入数组名 因为数组名一般代表首元素地址
//需要注意的是 内存中存储显示的一列(两个数 用16进制显示 如2a 30等等)表示一个字节的数据

//关于查看调用堆栈功能
//这个功能常用于在合作写代码的时候或者公司开发的时候 我们常常会调用别的程序员写的函数或者是嵌套调用了自己和别人写的函数
//而如果我们要查看程序是何时何地调用了具体哪个函数 就可以通过这个查看调用堆栈的功能 每调用一个函数 这上面就会显示调用信息
//便于我们快速定位

//关于反汇编功能 可以将我们写的高级语言的代码转换成汇编语言的代码 利于我们查看代码更底层的硬件级执行逻辑以及其汇编实现原理等等

//关于查看寄存器功能 常和反汇编功能一同使用 会显示程序调用的寄存器及其存储的值的变化过程


//一些调试示例：
//1_ 计算1!+2!+3!+4!+..+n! 代码如下：
//int main()
//{
//	int n = 0, ret = 1, sum = 0;//ret用于计算单个的阶乘 sum用于累加阶乘之和
//	scanf("%d", &n);
//	for (int i = 1; i <=n; i++)
//	{
//		//ret = 1;
//		for (int j = 1; j <=i; j++)
//		{
//			ret *= j;
//		}
//		sum += ret;
//	}
//	printf("%d\n", sum);
//	return 0;
//}
//这段代码 我们在输入3时却得到了15 本来1!+2!+3!=9 却输出了15 这是为何?
//先观察 发现代码逻辑很完整 似乎找不到直接错误 于是我们只能通过调试来"破案"
//调试-监视 发现n的输入没问题 i j的自加没问题 1!+2!的sum ret都没问题 只是到3!时 原本应该是2*3=6 现在却变成了4*3=12
//看来问题是出现在计算3!上 那么好端端的2怎么变成4了呢 问题不出现在j上 而是ret上 ret不知为何多乘了个2 再次调试
//我们发现ret原来没有在每次计算完一个阶乘后 都没有重新初始化为1 导致计算3!时ret本身还保留着2!的结果(也就是2)
//所以3!就计算成了2*1*2*3=12 发现问题了 思考解决方案-->似乎只要在计算每个单独的阶乘之前将ret重新赋值为1就行了
//于是我们在4797行加入 ret=1; 这条语句即可 再次测试 多组用例均成功通过！说明我们的调试成功了

//2_ 为什么下面这段代码会陷入死循环? :
//int main()
//{
//	int i = 0;
//	int arr[10] = { 1,2,3,4,5,6,7,8,9,10 };
//	for (int i = 0; i <= 15; i++)
//	{
//		arr[i] = 0;
//		printf("hehe\n");
//	}
//	return 0;
//}
//通过调试我们发现 当i=15进入循环后 i突然=0了 然后自然而然地又会进行下一次循环 这样无限的循环下去导致栈崩溃了
//那么为什么i突然等于0了? 再通过调试发现就是arr[i]=0导致的i=0 也就是说原先对arr[15]的赋值导致了i等于0
//我们知道 哪怕对于数组的元素访问越界了 那也只是按照地址往后继续访问 只不过访问的结果可能是随机的
//而这时 如果我们&arr[15]会发现 它的地址和i的地址是一样的！也就是说数组越界访问访问到了i本身的存储地址
//所以对arr[15]的赋值就成了对i本身的赋值 自然程序会陷入死循环了

//划重点！！！
//那么 为什么会发生这样的事故呢 这里就不得不提到栈区的独特机制了:
//栈区内存的使用习惯是先使用高地址的空间 再使用低地址的空间 所以数组创建时整体的地址是比变量i的地址要小的
//但是数组创建又有一个特点 就是会让下标更大的元素使用高地址 依次往下递减
//所以如果i和arr[Max:最大下标]的内存空间位置相差得当 那么arr数组通过越界访问 那么是可能刚好访问到i的内存空间导致死循环出现的！
//而这个空间的差值是随着编译器和系统环境改变而改变的 例如在X64环境VS编译器中i和arr[Max]的规律是：(数组是int类型)
//i和arr[Max]总是相差6~9个整型大小 例如:Max=6,7,8,9时(对应数组大小是7,8,9,10) &i=&arr[Max+..]:[6+9],[7+8],[8+7],[9+6]
//当Max>9时又对应下一组6~9个整型大小 此外 数组不管多大 这个差值规律会一直存在 所以这个bug只发生在数组越界时
//这是程序设计语言和编译器本身设计的不完善性所导致的结果 其实类似于这种的bug还有很多 参考《C陷阱和缺陷》


//那么 如何写出好的代码呢? 常见的Coding技巧有：
//1_使用assert
//2_尽量使用const
//3_养成良好的编码风格
//4_添加必要注释
//5_避免常见的编码陷阱

//模拟实现一个strcpy
//首先知道strcpy函数的参数是两个char*类型的指针(char* dest,char* src)前者是欲拷贝到的地方 后者是拷贝的源头
//一般的代码实现:
//void my_strcpy(char* dest, char* src)
//{
//	while (*src!='\0')//当src读取到最后一个即'\0'时就退出循环
//	{
//		*dest = *src;
//		dest++;
//		src++;
//	}
//	*dest = *src;//然后单独赋值最后一个'\0'到dest中去 作为字符串结束的标志
//}
//int main()
//{
//	char arr1[20] = { 0 };
//	char arr2[] = "Hello World!";
//	my_strcpy(arr1, arr2);//将arr2中的内容拷贝到arr1中去
//	printf("%s\n", arr1);//Hello world!
//	return 0;
//}
//有技巧的代码实现:
//char* my_strcpy(char* dest,const char* src)//const修饰指针使得后面如果不小心写反了dest和src的赋值关系时 编译器就可以立即察觉出来
////原strcpy函数也是char*类型的 这是为了便于实现链式访问 可以直接返回dest指向空间的起始地址作为其他函数的参数
//{
//	char* ret = dest;//因为后面dest不断++导致其指向位置改变 所以需要另有一个指针来保存dest指针中存放的起始地址
//	assert(src != NULL && dest != NULL);//assert:断言 用于计算表达式 当结果为 FALSE 时 打印诊断消息并中止程序 引用<assert.h>头文件
//	//这里的assert用于判断传过来的指针是否是闲置的空指针 因为空指针是不能解引用的！
//	//如果是 则打印诊断信息 例如:Assertion failed: src != NULL && dest != NULL, file C:\code\Learn_01\add_01.c, line 4875
//	//诊断信息包括了:断言失败的表达式内容及其精确位置
//	while (*dest++=*src++)//当*src把'\0'赋给*dest时 由于'\0'的ASCII码值是0所以表达式结果被判定为0 自动就退出循环了
//	{
//		;//注意该表达式的运算次序:先是*src取出其中的字符 然后src++指针后移 再是*dest 将字符放到其指向空间中去 再是dest指针后移
//	//这是因为*和++是同等优先级的 而赋值操作符的结合性是从右往左的 即先从左到右地执行右边的表达式 再从左到右地赋给左边的表达式
//	}
//	return ret;//返回dest指向空间的起始地址 这时后面的函数再调用函数结果时就可以直接访问已经拷贝过字符串的原字符数组了
//}
//int main()
//{
//	char arr1[20] = { 0 };
//	char arr2[] = "Hello World!";
//	//char* p = NULL;
//	printf("%s\n",my_strcpy(arr1, arr2));//Hello world!
//	return 0;
//}

//const: 前面我们讲到了 const修饰的常变量属于常量的一种 因为修饰后原变量就不能直接改变了 例如:
//const int num=10;
//num=20; 这时候编译器会直接报错 说num是一个不可修改的左值 这就是const的功用
//虽然这并不绝对 我们也可以绕过const的限制 例如&num 然后用解引用指针的形式来修改就可以绕过去了 不过这一般也没有必要
//const修饰指针:-------->>
//1_const放在*左边 如:const int* p=&n; 这表示p指向的对象的值固定了 不能通过*p来改变了 但是p本身放的地址是可以改变的
//2_const放在*右边 如:int* const p=&n; 这表示p指向的指向的对象固定了 p中存放的地址不能改变了 但是*p可以改变对象的值
//简记:const修饰指针遵循从左往右的就近原则 离*近 则表示解引用后对象的值不能修改;离p近 则表示p中存放的地址不能修改

//常见错误类型：
//1_编译型错误 编译期间发现的错误 以E开头 error:本意是各种错误 但是通常用来指代编译型错误
//2_链接型错误 链接期间发现的错误 以LNK开头 link:链接
//3_运行时错误 ...


//一个很重要的快捷键---------> Ctrl+F 快速查找指定内容 F:find 查找后按F3可以跳到相同内容的下一个位置 注意 这非常重要！！！


//习题:判断是否为三角形?
//多组输入 一行三个输入数据 空格分隔 判断是否为等边/等腰/一般三角形/不是三角形
//int main()
//{
//	int a = 0,b=0,c=0;
//	while (scanf("%d %d %d",&a,&b,&c) != EOF)
//	{
//		if ((a+b>c) && (a+c>b) && (b+c>a))
//		{
//			if (a==b && b==c)//再次提醒 判断三个数据是否相等 不能用连等式 两个等式之间要用&&按位与操作符连接
//			{
//				printf("等边三角形\n");
//			}
//			else if ((a!=b) && (b!=c) && (a!=c))
//			{
//				printf("一般三角形\n");
//			}
//			else
//			{
//				printf("等腰三角形\n");
//			}
//		}
//		else
//		{
//			printf("不是三角形\n");
//		}
//	}
//	return 0;
//}

//习题:判断代码的输出结果?
//int main()
//{
//	int arr[] = { 1,2,3,4,5 };
//	short* p = (short*)arr;//将int*类型的arr强制转换为short*类型并赋地址给short*类型的指针p
//	for (int i = 0; i < 4; i++)
//	{
//		*(p + i) = 0;
//	}
//	for (int i = 0; i < 5; i++)
//	{
//		printf("%d ", arr[i]);//0 0 3 4 5 
//	}
//	return 0;
//}
//为什么结果会是0 0 3 4 5呢 这里涉及到大小端存储字节序的问题
//当一个元素存储占用多个字节空间时 假设是一个整型 其值是0xcccccccc 每两个c占据一个字节空间 右边的c为低位 左边的c则为高位
//那么这个时候就有个问题了 该数据的低位和高位谁来占用高地址呢谁又占低地址呢? 这里的存储方式会随着处理器(硬件)的不同而不同
//大端存储: 反着来的 高存低 低存高
//小端存储: 顺着来的 高存高 低存低 大部分处理器如:X86 X64 ARM系列处理器都是用的小端存储方式 两种方式其实并无优劣之分
//回到这里 也就是说数组中每个元素的存储都是小端存储 数据地位位于低地址 高位位于高地址 那么数组的实际存储形式就是:
//(低地址)0x 01 00 00 00--0x 02 00 00 00--0x 03 00 00 00--0x 04 00 00 00--0x 05 00 00 00 (高地址)
//原先的指针变量arr是int*类型的 所以步长是4 arr+1指针指向02 而现在p是short*类型指针 步长是2 所以arr+1指针指向01后面的第二个00
//再+1指向02 再+1指向02后面的第二个00 而每次都将其指向对象赋值为0 所以最后只有前两个元素是0 而后面的元素值都不变

//习题:判断打印结果?
//int main()
//{
//	int arr[] = { 1,2,3,4,5,6 };
//	int* p = arr;
//	*(p + 3) += 3;
//	printf("%d %d\n", *p, *(p + 3));//1 7
//	return 0;
//}
//这个题需要注意两点：
//1_*(p+3)时跳过了12个字节 即访问数组中第四个元素 但并不是真的改变了p中存放的地址(地址仍然是arr) 这一点区别于p+=3！！！
//2_*(p+3)+=3即*(p+3)=*(p+3)+3 先计算*(p+3)-->4 4+3=7 然后赋值给*(p+3)即赋值给(p+3)所指向的对象--->arr[3]=7

//习题:将字符串逆序 再来熟悉一下递归实现?
//static reverse_string(char arr[], int left, int right)
//{
//	if (left<right)
//	{
//		char ex = arr[left];
//		arr[left] = arr[right];
//		arr[right] = ex;
//		reverse_string(arr, left + 1, right - 1);
//	}
//}
//int main()
//{
//	char arr[10001] = { 0 };
//	gets(arr);//gets是读取输入字符串的函数 是ANSI标准规定的 但是由于它不会进行边界检查 所以会存在内存越界风险
//	//所以C11标准将其删除 在VS中提供了gets_s函数替代并且更安全 但是为了接近原始标准 如同我们用scanf而不用scanf_s一样
//	//仍然建议使用gets而不是gets_s 所以哪怕报警告也建议忽略:) 使用时还请注意输入字符时不要越过字符数组的边界！
//	//gets与scanf的区别是 它能读取空格字符 直到\n为止 而是scanf不能读取空格字符 遇到空格字符就停止了
//	int left = 0;
//	int right = (int)strlen(arr) - 1;
//	reverse_string(arr, left, right);
//	puts(arr);
//	return 0;
//}
//补充puts和printf的区别 puts读到\0时会自动换行 而printf不会
//其实不难发现 如果是字符数组而言 无论输入输出 我们都建议使用gets(数组名)和puts(数组名)


//补充:一些常用的Ctrl+快捷键	<多用 多记>
//Ctrl+f :查找指定内容 按F3/Enter跳转到该内容的下一个位置 按ESC退出
//Ctrl+h :替换指定内容 按F3/Enter跳转到该内容的下一个位置 按ESC退出
//Ctrl+d :将光标所在行内容快速粘贴到下一行
//Ctrl+g :跳转到指定行 按ESC退出
//Ctrl+Enter :在光标所在行的上方新加一行 同时光标跳转
//Ctrl+Shift+Enter :在光标所在行的下方新加一行 同时光标跳转
//Ctrl+Del :删除光标右侧的所有内容(限该行)
//Ctrl+l(L):删除这一行 如果是最后一行就只删除这一行的所有内容
//光标+按住Shift+光标 :快速选中两个光标位置之间的所有内容
//Ctrl+Home :跳转第一行
//Ctrl+End  :跳转最后一行
//Ctrl+z	:撤销 很常用:)
//Ctrl+y	:重做 与撤销对应 常用于取消这一步撤销
//Ctrl+c	:常用于终止终端窗口的运行


//习题:求出1~100000中所有的水仙花数 水仙花数:如果一个数据是n位数 而它每个位数的n次方之和等于该数据 那么该数据就称为"水仙花数"
//事实上真正的水仙花数指的是三位数的自幂数 这里仍然是一个变种题
//int main()
//{
//	int i = 0, x = 0; //x是i的替代 避免i的值在操作中改变
//	for ( i = 1; i<=100000 ; i++)
//	{
//		int sum = 0, n =1;//注意：这里的sum(各位幂之和)和n(位数)必须要放在for循环中初始化 每一个数对应一个sum和n 同时n应该>=1
//		x = i;
//		while (x/10)
//		{
//			n++;
//			x /= 10;
//		}
//		x = i;
//		while (x)
//		{
//			sum +=(int)pow(x % 10, n);
//			x /= 10;
//		}
//		if (sum==i)
//		{
//			printf("%d ", i);
//		}
//	}
//	return 0;
//}

//习题:打印菱形 输入对角线长度X<奇数> 打印对印的图形
//实现:由于VS不支持变长数组 所以这里就用X=13来实现 在OJ中可用输入X的值来实现 思路如下:
//例如: X=13时 	数组下标(i)
//      *       	0
//     ***      	1
//    *****     	2
//   *******		3
//  *********   	4
// ***********  	5
//************* mid=6
// *********** 		7
//  *********   	8
//   *******    	9
//    *****     	10
//     ***     		11
//      *     	    12
//0--------->12	:数组下标(j)  显然i、j的对应关系相同 我们以(i,j)来代表’*'
//从(6,0)开始观察出现*的位置 得出以下规律:
//	 上三角形					下三角形
//i=6 	j>=0&&j<=12			i=6		j>=0&&j<=12
//i=5	j>=1&&j<=11			i=6+1	j>=1&&j<=11
//i=4	j>=2&&j<=10			i=6+2	j>=2&&j<=10
//...						...
//i=0	j=6					i=12	j=6
//所以我们可以用两个双重for循环来分别赋'*' 
//上循环外层i=6 i--直到i=0 内层j>=left(0) <=right(12) 外层每循环完一行left就+1 right就-1
//下层同理

//代码实现:
//int main()
//{
//	int x = 13;
//	int mid = (x - 1) / 2;//mid是数组的长/宽的中间位置的下标 x-1是因为数组的最大下标=元素总数-1
//	int left = 0, right = x-1;
//	char arr[13][13] = { 0 };//初始化二维数组
//	for (int i = 0; i < x; i++)//这个循环用于赋空格给该二维数组
//	{
//		for (int j = 0; j < x; j++)
//		{
//			arr[i][j] = ' ';
//		}
//	}
//	for (int i = mid; i >=0 ; i--)//给上三角形赋'*'
//	{
//		for (int j = left; j<=right;j++)
//		{
//			arr[i][j] = '*';
//		}
//			left++;
//			right--;//注意left和right是放在外层循环中的 放内层循环会导致最后只给中间那一行赋了'*' 因为赋完这一行就left=right了
//	}
//	left = 0, right = x - 1;//上一个循环后left,right已经相等 所以需要重新赋值一次
//	for (int i = mid; i <x ; i++)//给下三角形赋'*'
//	{
//		for (int j = left; j <= right; j++)
//		{
//			arr[i][j] = '*';
//		}
//		left++;
//		right--;
//	}
//	for (int i = 0; i < x; i++)//这个循环用于打印
//	{
//		for (int j = 0; j < x; j++)
//		{
//			printf("%c", arr[i][j]);
//		}
//		printf("\n");
//	}
//	return 0;
//}

//当然 这里还有别的思路 例如:不用二维数组 只是单独的用循环来打印 这样的话就不需要用到变长数组:
//实现:我们仍然将该菱形视为上下两个三角形 只不过上三角形以mid为底 下三角形以mid-1为底
//再观察发现 其实我们可以不用打印*右边的空白 只需打印左边即可 观察发现其实左边的空白也就是两个三角形 所以我们就可以用循环来行行打印
//      *       	0
//     ***      	1
//    *****     	2
//   *******		3
//  *********   	4
// ***********  	5
//************* mid=6
// *********** 		7
//  *********   	8
//   *******    	9
//    *****     	10
//     ***     		11
//      *     	    12
//int main()
//{
//	int input = 0;
//	scanf("%d", &input);
//	int mid = input - 1;
//	for (int i = 0; i <= mid; i++)
//	{
//		for (int j = mid-i; j >0 ; j--)//空格数从6减到0 每行-1
//		{
//			printf(" ");//注意 用printf输出字符时要不然用字符串的""输出 要不然就用占位符:"%c",' '  不能直接用''输出！！
//		}
//		for (int k = 0; k < 2*i+1; k++)//*数从1->3->5..i从0开始 那么*数目的规律就是2*i+1 k也从0开始 所以是<
//		{
//			printf("*");
//		}
//		printf("\n");//到此就打印完一行了 所以需要换行
//	}
//	for (int i = mid; i > 0; i--)//下三角形一共6行 所以i从6开始减到1
//	{
//		for (int j = 0; j <= mid-i; j++)//空格数从1开始加到6 每次加1 所以j<=mid-i而不是<
//		{
//			printf(" ");
//		}
//		for (int k = 0; k < 2*i-1; k++)//*数从11->9->7..i从6开始递减 所以*数目的规律应该是2*i-1
//		{
//			printf("*");
//		}
//		printf("\n");
//	}
//	return 0;
//}//这种方式其实更为直接 面向结果式的编程 观察打印结果的规律 判断出循环的条件及参数变化规律即可


//习题:下面哪个是指针数组?
//A int* arr[10]	//yes
//B int* arr[]		//no 因为该数组没有初始化 也没有声明要占用的空间
//C int* *arr;		//二级指针
//D int (*arr)[10]  //(*arr)表明这是一个指针 指向的对象是int类型,10个元素的数组 所以arr是一个数组指针

//习题:关于结构体数组?
//struct stu
//{
//	char name[10];
//	char sex[5];
//	char num[11];
//};
//int main()
//{
//	struct stu student[3] = { {"zhangsan","nan","123"},{"lisi","nan","456"},{"wangwu","nan","789"} };
//	printf("%s %s %s", student[0].name,student[0].sex,student[0].num);//zhangsan nan 123
//	//所谓结构体数组就是相同结构体类型的变量的集合 例如此处的student就是这个stu结构体类型的数组名 数组元素包括三个该结构体变量
//	return 0;
//}

//习题:喝汽水问题:1块钱可以买1瓶汽水 两个空瓶可以换一瓶汽水 现给n元钱 请问一共可以喝多少汽水?
//循环实现:
//int main()
//{
//	int money = 0;
//	scanf("%d", &money);
//	int total = 0, empty = 0;//total表示总共喝的汽水瓶数 empty表示剩余的空瓶的数目
//	total = money, empty = money;
//	while (empty>=2)
//	{
//		total += empty / 2;
//		empty = empty / 2 + empty % 2;
//	}
//	printf("%d\n", total);
//	return 0;
//}

//规律实现:
//其实思考会发现 总共喝到的瓶数总是存在这样的关系:1元->1瓶 2元->3瓶 3元->5瓶 4元->7瓶 ..
//原因就是每次二换一到最后时都会剩下最后喝的那瓶汽水 而这最后一个空瓶不能凑二换一了 所以总体上n元是买到了2n-1瓶
//int main()
//{
//	int money = 0,total=0;
//	scanf("%d", &money);
//	if (money>0)//判断一下 避免出现负数的结果
//	{
//		total = 2 * money - 1;
//	}
//	printf("%d\n", total);
//	return 0;
//}

//习题:计算最小公倍数
//暴力思路:判断出两者之间的较大数赋给另一个变量m 然后m自加 直到第一次m模a模b都等于0(能整除 无余数) 此时m就是两者的最小公倍数
//int main()
//{
//	int a = 0, b = 0;
//	scanf("%d %d", &a, &b);
//	int m = (a > b ? a : b);
//	while (1)
//	{
//		if (m%a==0&&m%b==0)
//		{
//			break;
//		}
//		m++;
//	}
//	printf("%d\n", m);
//	return 0;
//}

//伪暴力思路:让a从1开始乘(1,2,3..) 直到第一次乘的结果模b=0 那么这个结果就是最小公倍数 <刚好能让两者都整除的最小数>
//int main()
//{
//	int a = 0, b = 0;
//	scanf("%d %d", &a, &b);
//	int i = 1;
//	while (a*i%b)//* / %优先级相同 结合性从左向右 所以这里不用加括号
//	{
//		i++;
//	}
//	printf("%d\n", a*i);
//	return 0;
//}
//乘显然比自加来得快 所以这种方式会更快 但是仍然属于暴力方式

//补充一个知识点: 以后在用到传址调用时 都可以用assert判断一下 避免传过来空地址导致访问到空指针！这是良好的编码习惯


//---------------->>>>>>恭喜！你已经到达C语言进阶的内容
//下面开始进入深度的学习了:) 加油！

//深度剖析数据在内存中的存储:
//类型的意义?
//1_决定使用这个类型开辟的内存空间的大小	2_决定了看待这片内存空间的视角

//C语言规定 short int long longlong(C99)默认都是signed:有符号位的 要表示无符号位时需要加上unsigned
//但是C语言并未规定char类型默认是有/无符号位的 这取决于编译器 此外char signed char unsigned char三者的表示范围是完全不同的
//C语言中的数据类型:
//整型家族: char short int long longlong
//浮点数家族:float double long double(C99)
//自定义类型家族: 数组类型 结构体类型 枚举类型(enum) 联合类型(union)
//指针类型家族: int* void* float*..
//空(无)类型:void

//数值有多种表示形式 如2进制 8进制 10进制等等 而整数的二进制又有三种表示形式: 原/反/补码
//整数在内存中存放的是补码序列 这是最优选择 可以将加减法统一成加法运算 此外 补码和原码互相转换的原理相同 无须额外硬件电路

//大小端字节序 --->数据(大于一个字节)在内存中存储时字节的排序问题
//大端存储:数据的低位放在高地址处 数据的高位放在低地址处
//小端存储:数据的低位放在低地址处 数据的高位放在高地址处
//排序方式只取决于处理器类型 也就是硬件基础
//需要注意的是 大小端存储只改变字节的排序 不会改变字节内的数据顺序 例如:
//如果一个数据的16进制表示是0x00 00 00 13 那么该数据按照小端存储的方式存储的话 结果就是:
//(低地址) 0x 13 00 00 00 (高地址) 注意 13是字节内的数据顺序 说白了就是二进制序列00010003 这是字节内的序列 是不改变的!!!

//写一个小程序 判断当前处理器是大端存储还是小端存储
//int	check_sys()//用于判断大小端存储方式
//{
//	int a = 1;//0x 00 00 00 01 
//	return *(char*)&a;//强制类型转换成char*后再解引用时就只访问第一个字节的内容了 如果是大端 则返回0;如果是小端 则返回1
//}
//int main()
//{
//	int ret=check_sys();
//	if (ret)
//	{
//		printf("小端存储\n");
//	}
//	else
//	{
//		printf("大端存储\n");
//	}
//	return 0;
//}

//练习题: 请问以下代码的输出结果?
//int main()
//{
//	char a = -1;//VS中char类型默认为有符号类型的 等同于signed char
//	signed char b = -1;//signed char表示范围:-128到127
//	unsigned char c = -1;//unsigned char 无符号位 表示范围0到255
//	//这里如果我们要计算出结果 就需要考虑截断和整型提升
//	//-1的补码是1111...111 截断后就是11111111 
//	//而后面以整型打印时 又会发生整型提升 对于char signed char而言 提升时高位补1 而unsigned char提升时高位补0
//	//前两者就变成了11111...111 在打印时要转换为原码 于是-1 取反 得到10000..001->-1
//	//后者就成了0000..11111111 在打印时转换为原码->255
//	//所以说这里char的类型会决定：整型提升时前面补1还是0 而后面补码和原码的转换方式又由占位符和char类型共同决定
//	printf("%d %d %d\n", a, b, c);//-1 -1 255
//
//	return 0;
//}
//而为什么signed char类型的补码能表示的最小数是-128呢? 因为当一个负数原码是11111111时 补码10000001 对应的十进制数是-127
//再-1时:补码-1得到10000000 换成原码会发现仍然得到10000000 它的原码补码都是10000000 显然 这个数是一个临界值
//为了不与数学逻辑相冲突 于是取该数(-128)为八位有符号位二进制数能表示的最小数
//同理 signed short类型的表示范围是-2^15(1000000000000000 同样是临界的最小值)到2^15-1 而unsigned short的范围是0到2^16-1

//注意 这里需要提醒一点:考虑截断时不必考虑大小端 因为大小端只作用于在完整存放一个数据(>1字节)到内存中去的时候
//截断时统一都是取的低位数据 这样才能确保数据至少是有效的 哪怕是部分有效

//练习题:
//int main()
//{
//	char a = -128;//刚好能存下 存的补码:10000000
//	printf("%u\n", a);//4294967168--->1111...10000000
//	//打印时要求a至少是个整型 所以发生整型提升 因为char有符号位并且首位为1 所以整型提升时高位补1 然后打印时
//	//因为以无符号类型打印 所以直接将补码视作原码进行打印 如果是%d 则是按照有符号类型打印的 符号位为1 则会将补码转换为原码
//	//由此观之 char是否有符号位决定整型提升时前面的补法 打印时占位符的种类和是否有符号位又共同决定补码和原码的转换方式
//	return 0;
//}

//练习题:
//int main()
//{
//	int a = -20;//111..01100
//	unsigned int b = 10;//000..01010
//	printf("%d\n", a + b);//a+b时a发生算术转换 但是不影响补码具体是多少 因为补码的位数没有发生改变
//	//111..10110
//	//111..10101
//	//100..01010--->-10
//	return 0;
//}

//练习题:
//int main()
//{
//	if (strlen("abc")-strlen("abcdef")>0)
//	{
//		printf(">");//结果是>  ???为什么呢这是
//	}
//	//因为strlen函数的返回值是size_t类型 属于无符号类型之一 两者相减理论上应该等于-3 但是因为是无符号类型的
//	//所以其补码111...101会被视作是原码 也就等于十进制的4,294,967,293 显然大于0 所以最后打印的是">"符号
//	else
//	{
//		printf("<=");
//	}
//	return 0;
//}//事实上 如果我们要用strlen直接比较字符串长度 可以不用相减这种方式 而是直接用来比大小:if(strlen("")>strlen("")) 为真则成立


//浮点数在内存中的存储:
//int main()
//{
//	int a = 9;
//	float* pfloat = (float*)&a;
//	printf("%d\n", a);//9
//	printf("%f\n", *pfloat);//0.000000 这说明以浮点数的方式取整数方式存放的数据是取不出来的
//	*pfloat = 9.0;
//	printf("%d\n", a);//1091567616 这也说明以整数方式取以浮点数方式存放的数据是取不出来的
//	printf("%f\n", *pfloat);//9.000000
//	return 0;
//}//综上说明 浮点数和整数在内存中是完全不同的存储方式

//十进制小数的科学计数法:1E10 E表示10的多少次方 1E10 即1*10^10
//根据IEEE的754文件规定 任意一个浮点二进制数都能用V=(-1)^S*M*2^E来表示
//(-1)^S*M称作尾数 而S称作尾数的数符 M称作尾数的数值部分
//E称作阶码 阶码也分为阶符和阶码的数值部分 阶码类似于科学计数法中的指数 而阶符决定了小数点是向前进还是向后退 数值则决定了位数
//可以说 阶码的位数决定了表示的范围 尾数的位数决定了表示的精度
//例如: 十进制的-5.0 写成二进制就是-101.0 用浮点数表示法表示就是 -1.01*2^2   S=1 M=101 E=(+)2
//但是你会发现 由于二进制的小数点后的权重分别是2^-1  2^-2..所以十进制小数转换二进制难免会存在精度损失
//极可能用这些2^-1 -2...不能准确表示原本的十进制小数 所以必须要接受这一点

//对于float类型数据 总共占32个bit位 其中第一个bit位就是用来存放 S:数符 的(1/0) 然后后面8个bit位是用来存放阶码的 或者说是指数
//最后剩下的23位bit位则是用来存放尾数的数值部分的
//对于double类型数据 占64个bit位 其中第一个bit位仍然用来存放数符 然后用11个bit位存放阶码 再用剩下的52个bit位来存放尾数的数值

//所以 计算机存储浮点数其实只需要存储S M E即可
//而M默认范围是1<=M<2 也就是说M必然是1.多少多少 那么1本身就可以省略 不用存进去(只存小数点后的部分) 当取出使用时再加上即可 
//这样就使得尾数的数值部分实际有了24(f)/58(d)的bit位数 这省下来的一位就使得精度更高了
//而E的存储就比较复杂 因为E本身是一个unsigned int 类型数据 但是事实上我们知道指数可能是负数的 所以这里存在一种额外的处理
//首先8位E能表示的指数范围是0到255 而11位E能表示的指数范围则是0到2047
//当计算机存储E时 会将E加上一个中间值存储 如果是float类型 则是8位指数 中间值就是127 所以真实值会+127存储
//而double类型是11位指数 中间值是1023 所以真实值会+1023存储 并且由于指数位有限 所以真实值+中间值是不可能超过上限的

//补充:当我们在编译器中输入一个小数时 系统默认的是double类型 如果我们用float类型接收的话 默认发生隐式类型转换
//这种类型转换一般不会改变该小数的值 只是有可能会降低其精度
//而如果在输入小数时多输入一个f 则会直接默认为float类型的精度 这时再用float类型接收就不会发生类型转换了

//而在取出内存中存储的E时 分为三种情况:
//1_E不为全0或者全1时:
//用存储的E-中间值得到真实值 然后取出的同时会为M补上1
//2_E全为0:
//这时E的真实值为1-中间值 同时M不再补1 而是还原为0.xxxxx的小数形式 这样做是为了表示趋近于/等于0的小数
//3_E全为1:
//这时E的真实值为255/1023-中间值 此时M同样不补1 而是还原为一个极大数 如果M全为0 则表示这个数无穷大(正负号取决于S)


//习题: 调整数组中数字的顺序 使得所有的奇数位于数组的前半部分 所有的偶数位于数组的后半部分
//思路：1_遍历一遍 遇到奇数就将其按顺序放入原数组中 再遍历第二遍将所有的偶数依次再放到原数组的后半部分
//评析：思路简单 但是会占用过多的内存空间和时间
//更优思路：2_从左向右寻找第一个偶数 再同时从右向左寻找第一个奇数 然后将奇数和偶数进行交换
//如此循环直到left>right了就停止---->>事实上难点就在于设计这个停止以及寻找奇数/偶数时的停止
//评析：看似循环更多了 但事实上不会占用额外的数组空间 同时总共只遍历了整个数组一次 时间费用也比较低


//指针的进阶----->>

//1_字符指针:
//关于char*类型指针的进阶使用:
//int main()
//{
//	const char* p = "abcdefgh";//对地址赋值 将字符串首个字符的地址赋给p
//	//注意：这里并不是将字符串:"abcdefgh"全放到p指针中去 显然p指针只有8个字节 全部放下字符串需要至少9个字节(\0)
//	printf("%s\n", p);//abcdefgh 以字符串格式打印时对应的参数是const修饰的char*类型的指针 所以这里直接用的p
//	//为什么要用const修饰? 因为将字符串首地址赋给p后 可能会有风险->当*p并重新赋予字符时 程序会崩溃的
//	//因为像"ab..gh"这种字符串本身是常量类型 是不可以修改的 但是存在*p修改字符的可能 这时程序因为写入权限不足会直接崩溃
//	//所以我们用const修饰 使得p指向的字符/串不可以修改 确保其安全性
//	return 0;
//}//这里又补充了一种字符指针打印字符串的方法 之前分别学过:直接print"xxx"打印法 以及数组打印法:arr[]="xxx"然后printf("%s",arr)
//总结，打印字符串有哪些方法？ 直接打印法，数组打印法以及字符指针打印法

//一道面试题:
//int main()
//{
//	const char* p1 = "abcdef";
//	const char* p2 = "abcdef";
//	char arr1[] = "abcdef";
//	char arr2[] = "abcdef";
//	if (p1==p1)
//	{
//		printf("p1==p2\n");//结果 ---为什么p1和p2中存放的地址相同呢? 两者不是两个指针吗?
//	}
//	//这是因为像字符串这种只读的数据 其实是放在内存中的只读区域的 那么如果两个只读数据是一样的 也就没有必要额外开辟空间了
//	//所以p1 p2指向的是同一个字符串的首字符地址 也就是"a"的地址
//	else
//	{
//		printf("p1!=p2\n");
//	}
//	if (arr1==arr2)
//	{
//		printf("arr1==arr2\n");
//	}
//	else
//	{
//		printf("arr1!=arr2\n");//结果
//	}
//	//这一点说明arr1和arr2是两个不同的数组 虽然它们放的数据是一样的 但是为了存放这个数据 两者都分别开辟了内存空间
//	return 0;
//}


//指针数组:用来存放指针的数组 例如: int* arr[10] arr是这个数组的名字 而int*说明它的元素类型是int*类型的指针 [10]则说明元素个数是10
//模拟二维数组:用int* parr[3]存放三个一维数组的数组名 也就是三个指针 然后循环打印*(parr[i]+j)/parr[i][j] 理解*(arr+i)=arr[i]
//这里的i是从0到2 因为一共有三个一维数组(3行) j从0到数组下标Max: +0时访问第一个一维数组的第一个元素 +1时则访问...第二个元素
//还有一点：注意打印完一个一维数组后要记得换行

//指针数组的元素还可以是二级指针..


//数组指针 核心在于指针---->
//前面讲过 字符指针-->指向的对象是字符型的
//整型指针->指向的对象是整型的
//那么数组指针--->指向的对象是数组

//思考？一个典型的数组指针:int(*arr)[10] 这个括号将*和arr括在一起 不正是强调了它的指针身份吗 int和[10]则表明它指向的数组的特征
//那么什么叫做指向数组的指针呢？
//前面讲过 数组名在两个特例下不代表首元素地址
//第一是sizeof(arr)时 计算的整个数组的大小
//第二是&arr时 取出的是整个数组的地址 只不过用首元素地址来指代 所以我们打印&arr时会发现打印的仍然是数组首元素地址
//----->但是如果打印&arr+1会发现它的步长是整个数组 这也就印证了&arr取出的是整个数组的地址 只是用首地址来指代了
//那么 既然这里的&arr取出的不是首元素地址而是整个数组的地址 那我们该用什么类型的指针来存放这个&arr呢
//显然 这就是数组指针的意义 用来指向一个数组 那么自然也要存放整个数组的地址-->&arr
//再看int (*arr)[10] 这个数组指针的名称是arr 而*是为了强调arr是个指针(不是解引用！) 它的类型是int (*)[10]

//区分 数组指针和存放数组首元素地址的指针
//前者是存放的整个数组的地址 而后者 例如:
//int main()
//{
//	int arr[] = { 0 };
//	int* p = arr;//这里的指针p并不是存放的整个数组的地址 而是仅仅只存放了arr 也就是数组首元素的地址 这一点要区别于数组指针！
//	return 0;
//}
//此外 数组指针指向的是整个数组 而后者是指向的数组中的首元素

//数组指针的类型必须完整 即指向数组的特征必循明确:
//int (*p)[10] 不能省略[]中的内容 否则相当于是数组都不确定了 指向数组的指针p自然也不能确定了 所以编译器会报错


//数组指针的常见用法:---->多维数组,数据结构
//以二维数组为例:
//前面我们讲过 二维数组本质上是被视为m个一维数组(m是行数)拼接而成的 与模拟二维数组的区别是后者每个一维数组之间地址不连续
//那么二维数组名代表着首元素地址 这里的首元素就是第一行 也就是第一个一维数组的地址 既然是整个数组的地址 那我们就可以用数组指针
//int main()
//{
//	int arr[3][5] = { 1,2,3,4,5,2,3,4,5,6,3,4,5,6,7 };//二维数组的元素就是m个一维数组
//	int(*p)[5] = arr;
//	for (int i = 0; i < 3; i++)
//	{
//		for (int j = 0; j < 5; j++)
//		{
//			printf("%d ", *(*(p + i) + j));//*(p+i)==p[i] 这两个是等价的
//		}
//		printf("\n");//这里的数组指针步长是一整个一维数组
//	}
//	return 0;
//}


//关于：int(*p[10])[5] 这是什么东西?
//首先 这显然不是数组指针 因为它的类型是int(*[10])[5] 多了一个[10] 同时 这又不是指针数组 因为*在()里面
//但是 可以确定这是一个数组 前面讲过 去掉数组名和数组元素个数 就是数组元素的类型！！！
//也就是说这个数组的元素类型是int (*[10]) [10]之所以放在括号之中 显然是为了避免与二维数组指针相混淆
//那么这时我们不妨取出[10] 得到int (*)[10] 这就是数组指针了
//也就是说 int(*p[10])[5]是一个数组指针的数组 其元素是五个数组指针
//所以答案是――――――>>数组指针的数组

//那么这里 我们就用到了拆分法 常用这种方法来判断结构复杂的数组/指针...  使用时要分清楚数组/指针的构成！


//数组参数以及指针参数：

//一维数组传参:
//void test(int arr[10])//这种方式很容易理解 因为直接创建了一个相同的形参数组来接收传过来的实参数组
//void test(int arr[])//当然 这里也可以不写明形参数组元素的个数 等到传参过来时再明确个数也可
//void test(int* arr)//用指针接收也很常用  因为数组传参传过来的是地址 所以可以用指针来存放这个地址
//一维指针数组传参:
//void test(int* arr[]);
//void test(int* arr[10]);//同理
//void test(int** arr);//因为传过来的是首元素(指针)的地址 所以可以用二级指针来接收 用于存放一级指针的地址

//二维数组传参:
//一般常用的只有以下三种
//void test(int arr[10][10]);//同理
//void test(int arr[][10]);//多维数组形参可以省略第一维 也就是行 但是不能省略后面的维度
//void test(int(*arr)[10]);//二维数组传参传的是首元素(第一个一维数组)的地址 既然是整个一维数组的地址 那当然可以用数组指针来接收

//一级指针传参: 用相同类型的形参指针来接收即可
//但是反过来 一级指针传参时 实参可能是什么呢?
//那么实参可能是变量的地址，一级指针，一维数组名，一个二级指针的解引用

//二级指针传参:同理 用二级指针接收即可
//反向思考 如果形参是二级指针 那么实参可能是一个二级指针，一个一级指针的地址 ，指针数组名，三级指针的解引用


//函数指针 <类比数组指针！> :指向函数的指针
//这个定义就让人有点迷糊了 ->难不成函数还有地址?		对的:)
//函数也是有地址的 并且函数名本身就是函数的地址 &函数名取的也是函数的地址 两者含义相同
//printf("%p  %p\n", &Add, Add);---------->>>两者的地址是一样的 两者代表的含义也都是一样的 推荐写&函数名 便于理解

//函数指针的形式:
//int Add(int x, int y); 这里以加法函数Add为例
//int (*p)(int, int) = &Add/Add; 整体上写法仍然类似于数组指针的写法
//(*p)表明p指针的身份 而前面的int说明函数返回的类型 后面(int,int)进一步说明函数的参数类型

//函数指针的一种用法：
//int (*p)(int, int) = &Add;//还是以Add函数为例 这里定义一个函数指针 指向Add函数
//int ret = (*p)(2, 3);//*p:访问函数对象 (2,3):传递参数2,3给函数 int ret:定义一个与函数返回类型相同的变量来接收函数返回值
//注意 这里的*p 外面的()是为了提升解引用的优先级 否则会优先传参 然后解引用返回结果 这会导致编译器报错
//这也说明 也可以不写括号和解引用 如:int ret = p (2, 3); 这两者的效果等同
//事实上 这里的*并不是真的解引用 只是为了方便理解才这样说 它只是一个形式化的符号 可以不写 也可以写 但是如果写上就一定要加括号
//.....也可以写很多个 如(*******p) 并无影响  这也再次说明了这里的*只是一个形式化的符号 可以说是为了便于理解


//关于函数竟然也有地址这件事:
//首先 函数地址是不存在首地址这种说法的 所以&函数名和函数名这两种方式得到的地址与其所代表的含义都是相同的
//此外 当函数声明了但是未定义时 是不会占用内存空间的 也就不会有地址
//而函数定义了之后 无论调用与否 都会占用代码段(又称文本段)中的内存空间 同时分配该区域的地址
//补充：函数在调用时将在栈区上创建新的栈帧 用来存储函数的局部变量和参数 函数执行期间 栈帧一直存在 直到函数返回(从栈中弹出)

//关于&函数名和函数名:
//两者都能代表函数的地址 这一点与数组名不同
//在C语言中 函数名 本质上是函数实体的代表 在表达式中的函数名会被隐式转换为函数地址 然后编译器会自动调用这个地址所指向的函数
//但并非别的语言也是如此  例如：在C++中 非静态成员函数不存在这种隐式转换 若要获得函数地址 就必须要加上&函数名
//这也是为什么我们推荐使用&函数名来获取函数地址

//一段有趣的代码:来自《C陷阱与缺陷》
//int main()
//{
//	(*(void(*)())0)();
//	//最里层: void(*)() 这像啥? 没错 函数指针类型 再套个括号呢 像啥? 强制类型转换！ 没错 这里就是将整型0强制类型转换为函数指针0
//	//也就是说将0转换为一个函数地址了 而且是一个无参 无类型返回的函数的地址 然后再通过这个函数指针0 调用该函数 (外层*加不加均可)
//	//最后再来一个()传参 <这里因为函数无参 所以不传实际参数>			可以说 这段代码真的相当巧妙:)
//	return 0;
//	//再补充一点: 这里第一个*外面的大括号不能省略 我们讲：*一个函数指针时的*号只是一个形式化符号 所以这个*可有可无 并不影响结果
//	//但是外面的大括号将0与后面的传参括号相分隔开 用于告知编译器这里前面的部分是在调用函数 而后面的部分则是在传参
//	//所以这个大括号不能省略！！
//}

//另一段有趣的代码:同样来自《C陷阱与缺陷》
//int main()
//{
//	void(*signal(int, void(*)(int)))(int);//这其实是一个函数的声明 何以见得？
//	//首先 我们需要分析signal是什么 显然它只有可能是函数名或者函数指针名 又因为 如果是函数指针名 那么这里就是在调用函数然后传参
//	//但是我们又说了 如果加了* 就必须要加括号 否则优先级不够 会变成*函数返回的结果 所以这里只能signal只能是函数名
//	//那么也就是说这里是在声明/定义一个函数 signal后面的(int,void(*)(int))就是signal函数两个参数的类型 一个整型 一个函数指针类型
//	//我们知道 去除函数名和函数参数后 剩下的就是函数的返回类型 也就是说 void(*)(int)是signal函数的返回类型-->>一个函数指针类型
//	//总结起来就是 这是一个返回类型为函数指针类型的函数的声明(没有具体定义 所以只是声明)
//	return 0;
//}//这里 我们又运用了拆分法 同样需要我们足够熟悉函数的构造{函数名 参数 返回类型}

//这段代码似乎有点容易混淆 我们可以将它简化一下：
//前面我们讲过 可以用typedef将类型名自定义 例如
//typedef unsigned int uint;//这是将unsigned int类型自定义命名为uint 自定义之后就可以用uint便捷定义无符号整型了
//这里 我们发现 signal函数的返回类型和它的一个参数类型相同 所以我们可以将其自定义简化命名：
//typedef void(*)(int) pf_v;//但是我们会发现 这是错误的 因为函数指针类型的自定义命名方式和其他类型不同 应该采用：
//typedef void(*pf_v)(int);//此处的pf_v就不再是函数指针名了 而是自定义的一个函数指针类型名 然后我们就可以直接用这个类型简化：
//int main()
//{
//	pf_v signal(int, pf_v);
//	return 0;
//}
//这样 我们也就实现了简化的目的 同时让其更加的清晰明了


//函数指针的用处？
//例如：实现一个计算器 可以进行加减乘除
//void menu()
//{
//	printf("*************************\n");
//	printf("******1.add  2.sub*******\n");
//	printf("******3.mul  4.div*******\n");
//	printf("******** 0.exit *********\n");
//	printf("*************************\n");
//}
//int Add(int x, int y)
//{
//	return x + y;
//}
//int Sub(int x, int y)
//{
//	return x - y;
//}
//int Mul(int x, int y)
//{
//	return x * y;
//}
//int Div(int x, int y)
//{
//	return x / y;//整数除法 先将就用着:)  
//}
/*int main()
{
	int input = 0, ret = 0;
	int x = 0, y = 0;
	do
	{
		menu();
		printf("请选择--->\n");
		scanf("%d", &input);
		switch (input)
		{
		case 0:
			printf("已退出\n");
			break;
		case 1:
			printf("请输入两个操作数:\n");
			scanf("%d %d", &x, &y);//注意不要在%d后面多输入空格之类的 否则一旦使用者没有输入那些多余空格会导致程序陷入死循环
			ret = Add(x, y);
			printf("结果是%d\n", ret);
			break;
		case 2:
			printf("请输入两个操作数:\n");
			scanf("%d %d", &x, &y);
			ret = Sub(x, y);
			printf("结果是%d\n", ret);
			
			break;
		case 3:
			printf("请输入两个操作数:\n");
			scanf("%d %d", &x, &y);
			ret = Mul(x, y);
			printf("结果是%d\n", ret);
			break;
		case 4:
			printf("请输入两个操作数:\n");
			scanf("%d %d", &x, &y);
			ret = Div(x, y);
			printf("结果是%d\n", ret);
			break;
		default:
			printf("输入错误\n");
			break;
		}
	} while (input);
	return 0;
}*/
//我们发现 case1 2 3 4的执行代码中绝大部分都是相同的 只是调用的函数不同
//那么我们能不能简化一下这几个case中的代码呢? 运用函数指针示例如下：
//void calc(int (*pf)(int, int))//calculator:计算器 这里的calc函数类似于一个中转站
//函数指针pf用于接收传过来的函数名(地址) 后面在用户输入操作数后 通过pf中接收的地址直接调用函数并传参 然后得到返回值
//{
//	int x, y,ret;
//	printf("请输入两个操作数:\n");
//	scanf("%d %d", &x, &y);
//	ret = pf(x, y);//这一步称为 回调函数 通过函数指针调用函数
//	//当然这里也可以写作(*pf) 但是前面我们说了 这里的*可以不写 因为只是个形式化的符号 但是如果写了 就一定要加括号！再次强调！！
//	printf("结果是%d\n", ret);
//}
//通过这个calc函数 利用函数指针的性质 我们简化了代码量 提高了程序执行的效率 同时还实现了更为细致的函数封装效果
//int main()
//{
//	int input = 0;
//	do
//	{
//		menu();
//		printf("请选择--->\n");
//		scanf("%d", &input);
//		switch (input)
//		{
//		case 0:
//			printf("已退出\n");
//			break;
//		case 1:
//			calc(Add);
//			break;
//		case 2:
//			calc(Sub);
//			break;
//		case 3:
//			calc(Mul);
//			break;
//		case 4:
//			calc(Div);
//			break;
//		default:
//			printf("输入错误\n");
//			break;
//		}
//	} while (input);
//	return 0;
//}

//这就是函数指针的一个方便之处 让我们在一些复杂的情况下可以便捷地调用相应的函数
//事实上 函数指针可以说是C语言中一个很高明的设计 在大型开发中更是常见它的身影！


//函数指针数组：
//显然 核心是数组 数组的元素是函数指针 可见:函数指针数组是指针数组的一种  注意！！！这里的指针都是说的地址 而不是指针变量！！！
//int main()
//{
//	int(*pf)(int, int);//这是我们前面讲到过的 函数指针的形式 那么按照拆分法 这里似乎只差[n]了 我们试着补全函数指针数组的模样：
//	int(*pfa[4])(int, int) ={Add,Sub,Mul,Div};//这就是一个函数指针数组的形式！而[n]最终选在了(*)里面 一是为了强调数组的身份 二是为使结构更紧凑
//	//Add，Sub，Mul，Div都是函数名 函数名会被隐式转换为函数地址(指针) 所以用函数名来初始化数组
//	//再次强调！！！指针数组中的指针都是说的地址 而不是指针变量
//	for (int i = 0; i < 4; i++)
//	{
//		int ret=pfa[i](8, 4);//pfa[i](parameter1,parameter2) 这就是函数指针数组中调用数组元素的方式
//		printf("%d\n", ret);
//	}
//	return 0;
//}

//通过函数指针数组再次实现一个计算器：
//情景：如果我们要让这个计算器功能更加复杂 例如添加浮点数除法 添加按位与/或 异或等等运算时
//如果按照上面的简化方式 用一个额外的calc函数 那么当我们需要添加别的运算功能时 就需要大刀阔斧的进行添加和改动
//而如果我们通过函数指针数组的方式 不再使用case的条件分支语句 就可以再次简化代码量 以及便于以后的改动
//int main()
//{
//	int input, x, y, ret;
//	int(*pfa[5])(int, int) = { 0,Add,Sub,Mul,Div };//加入一个0地址 使得使用者输入的选项和函数指针的下标对齐 便于调用
//	//通过函数指针数组 以后我们再需要修改计算器功能时 只需要改变数组元素个数和加入新的函数指针即可
//	//也正是因为函数指针数组类似于中转站般的功用  所以我们又称函数指针数组为转移表
//		do
//		{
//			menu();
//			printf("请选择--->\n");
//			scanf("%d", &input);
//			if (input==0)
//			{
//				printf("已退出\n");
//			}
//			else if (input!=0&&input<5)
//			{
//				printf("请输入操作数-->\n");
//				scanf("%d %d", &x, &y);
//				ret=pfa[input](x, y);//注意 函数指针数组的元素访问不能通过*操作符了 也就是说不能出现*(arr+i)这种方式了 
//				printf("结果是%d\n", ret);
//			}
//			else
//			{
//				printf("输入错误!\n");
//			}
//		} while (input);
//	return 0;
//}

//指向函数指针数组的指针：
//前面我们讲过 数组指针 是指向数组的指针 这里同理 是指向函数指针数组的指针 例如 ：
//int (*pfa[5])(int, int) = { 0,Add,Sub,Mul,Div }; 这是前面我们讲到的函数指针数组
//int(*(*ppfa)[5])(int,int)=&pfa  这里的ppfa就是指向函数指针数组的指针
//指向函数指针数组的指针和函数指针数组的区别就是 数组将*pfa和[]括起来 强调数组；而指针将ppfa再次括起来并加上* 强调指针


//回调函数：回调函数就是通过函数指针调用的函数
//当我们把函数的指针(地址)传参给另外一个函数 然后用这个指针来调用其指向的函数时 我们就称这是回调函数


//前面我们讲过了冒泡排序：核心是相邻两个元素之间的比较
//Bubble_sort:
//int main()
//{
//	int arr[10] = { 10,9,8,7,6,5,4,3,2,1 };
//	int sz = sizeof(arr) / sizeof(arr[0]);
//	for (int i = 0; i < sz-1 ; i++)//注意：是sz-1 因为i从0开始  如果是<sz 那么会进行sz趟冒泡排序 但事实上只需要sz-1趟
//	{
//		int flag = 1;//flag用作标志 当某一趟冒泡排序后没有任何交换时 说明冒泡可以停止了 这时用flag的值作为判断标志
//		for (int j = 0; j < sz-1-i; j++)//这里sz-1的必要性就出来了 如果j<sz-i i=0 那么j+1就会溢出 导致无法预料的错误 
//		{
//			if (arr[j]>arr[j+1])
//			{
//				arr[j] ^= arr[j + 1];
//				arr[j + 1] ^= arr[j];
//				arr[j] ^= arr[j + 1];
//				flag = 0;
//			}
//		}
//		if (flag==1)
//		{
//			break;
//		}
//	}
//	for (int i = 0; i < sz; i++)
//	{
//		printf("%d ", arr[i]);
//	}
//	return 0;
//}

//但是哪怕我们对这个冒泡排序进行了很多的优化 冒泡排序依然只能进行整数的排序 当我们需要进行含有浮点数的排序时 就可以用到qsort
//qsort是C语言内置的一个库函数<引用stdlib.h>  核心是快排思想(这里后面学习算法时会学到) 可以进行任意类型数据的比较和排序！
//接下来我们来学习一下qsort:下面是库函数中对qsort的声明
//void qsort(void* base,//待排序数据的起始位置
//	size_t num,//待排序数据元素的个数
//	size_t width,//待排序数据元素的大小
//	int(__cdecl *cmp)(const void* e1, const void* e2)//函数指针(变量)-->指向一个比较函数 为什么会需要这个函数指针来指向比较函数?
	//因为不同数据间比较方式是有差异的 而当我们写好了不同的比较函数后 通过这个函数指针 就可以快捷地传参至相应的比较函数
	//事实上 我们日常在使用qsort时 第四个参数往往直接传递的函数名 这是因为在函数指针中 我们一般不区分指针和指针变量
	//这也是为什么函数名(para1,para2)可以直接传递参数 而pf(函数指针变量)也是这么传递参数的
	//而且直接传递函数名往往更符合编程人员的直观感受 所以我们往往直接传函数名！
//		);
//__cdecl ：函数调用约定

//qsort函数是有返回值的 qsort规定 如果：
//elem1>elem2	返回>0的值
//elem1=elem2	返回0
//elem1<elem2	返回<0的值
//注意 qsort函数默认是排升序的 也就是说如果回调函数返回值是<0的值 则两者的位置不变


//int cmp_up(const void* e1, const void* e2)//使用qsort排升序数组
//{
//	return *(int*)e1 - *(int*)e2;//注意 这里一定要进行显式类型转换 因为void*指针是不能直接访问的
//  //哪怕将数据传参时 void*类型会发生隐式类型转换 但是明面上它仍然是void*类型 所以需要进行显式类型转换 然后再解引用访问
//}
//int cmp_down(const void* e1, const void* e2)//使用qsort排降序数组
//{
//	return *(int*)e2 - *(int*)e1;//因为qsort函数默认排升序 所以排降序时只需要让两个参数调换相减的位置即可
//	//return返回时会将后面的表达式执行完再返回  所以这里的整体可以不加括号
//}
//int main()
//{
//	int arr[10] = { 10,23,6,5,34,9,1,2,4,3 };
//	size_t sz = sizeof(arr) / sizeof(arr[0]);
//	qsort(arr, sz, sizeof(arr[0]), cmp_down);
//	for (int i = 0; i < 10; i++)
//	{
//		printf("%d ", arr[i]);
//	}
//	return 0;
//}

//前面我们说了 qsort函数之所以方便 一个重要原因是因为它能排各种类型的数据 接下来用结构体数据来演示：
//struct stu
//{
//	char name[10];
//	int age[5];
//};
//int cmp_by_name(const void* e1, const void* e2)//cmp_by_name就是一个回调函数：在某一时刻下通过函数指针来调用的函数
//{
//	return strcmp(((struct stu*)e1)->name, ((struct stu*)e2)->name);
//	//注意1：这里同样需要进行显式类型转换 
//	//注意2：这里通过->操作符来访问结构体成员时 要把前面的强制类型转换e1/e2整体括起来再用->  这是因为->操作符优先级比()要高
//}
//int main()
//{
//	struct stu s[3] = { {"zhangsan",18},{"lisi",25},{"wangwu",22} };//定义一个结构体数组s
//	int sz = sizeof(s) / sizeof(s[0]);
//	qsort(s, sz, sizeof(s[0]), cmp_by_name);
//	return 0;
//}


//提问：为什么qsort函数需要传递那个函数指针
//因为qsort函数需要调用该函数来确定如何比较数组中的数据 这里的cmp函数就是一个回调函数 qsort函数需要cmp的返回值：
//如果>0 则说明e1>e2 需要交换位置 反之...
//所以重要的其实就是cmp判断何时返回>0的值 何时又返回=/<0的值 然后qsort会根据判断结果来调整顺序


//试着分析qsort函数是如何实现依次访问数组中前后两个元素的？
//我们知道 传参时传的第一个参数是数组的起始位置 也就是base 但是这个参数默认是void*类型的 我们知道 void*类型是不存在步长的
//也就不能通过for循环 base+i这种方式来遍历  但是事实真的是不能吗？========错！
//这里有一种巧妙的处理方法：(char*)base+i*width 
//这里先将base强制类型转换成char*类型 然后+i*元素宽度(单位:Byte)	这就实现了跳跃任意步长 这里的任意取决于width和i
//而强制类型转换为char*类型是因为char*对应的步长(1Byte)是可能出现的最小步长 所以这里将其转换为char*类型
//避免遇到字符数组时 base+i*width一步就跳跃了多个字节 导致中间的字符跳过了


//一些面试题：

//补充知识：
//1_事实上 我们在编译器中看到的地址并不是真正的内存中的物理地址 而是虚拟地址 虚拟地址和真实的物理地址是不同的
//  虚拟地址需要经过硬件和软件的转换后才能对应到具体的物理地址 这也确保了程序员通过"地址"操作的内存空间是安全的 也保护了核心数据
//2_事实上 内存地址中的小地址 如1地址/2地址/234地址等等 这些(虚拟)地址指向的空间都是由内核进行分配的 是不允许程序员进行操作的
//  这也确保了核心数据的稳定和安全


//strlen计算字符串长度的结束标志只有\0 !!!  如果strlen读到的不是字符串 那么它会继续读取下去直到遇到\0(也就是0x00)为止

//理解二维数组：
//int main()
//{
//	int a[3][4] = { 0 };
//	//二维数组本质上就是n个一维数组组成的一个大数组 这个大数组的元素就是那几个一维数组
//	printf("%zu\n", sizeof(a[0]));//a[0]单独作为一个个体时代表的是访问首元素 也就是第一个一维数组 有四个int元素 所以是16
//	printf("%zu\n", sizeof(a[0]+1));//a[0]+1时a[0]不再独立 这时a[0]就代表&a[0][0] 所以a[0]+1就是第一个一维数组中第二个元素的地址 占8个字节
//	printf("%zu\n", sizeof(a+1));//a是首元素地址 a+1时跳到第二个一维数组的地址 所以是8
//	printf("%zu\n", sizeof(&a[0]+1));//&a[0]时a[0]仍然是独立的 所以此时的&a[0]取出的是第一个一维数组整体地址 +1就是第二个..的地址 所以是8
//	printf("%zu\n", sizeof(*(a[0]+1)));//a[0]不再独立 等于&a[0][0] 再+1就是第一个一维数组中第二个元素的地址 解引用后是0(int) 所以是4
//	printf("%zu\n", sizeof(*a));//a是首元素地址 也就是第一个一维数组的地址 *a时访问的是整个一维数组 所以是16
//	printf("%zu\n", sizeof(a[3]));//这里看似a[3]越界了 但是事实上sizeof()括号内部只关注类型 而不是真的去访问
//  例如：sizeof(int)同样等于4 一个道理->>只关注类型 而这里的a[3]对sizeof而言和a[0]/[1]/[2]是一样的(类型) 得到了类型所以编译器不会报警告
//	return 0;
//}
//总结 只有a[0]单独放在sizeof内或者&a[0]单独放在sizeof内时 a[0]才是独立的 代表第一个一维数组
//其他时刻 a[0]都等同于&a[0][0]！！！
//同理 a只有在sizeof内部或者&a时才是独立的 表示整个二维数组 其他时刻都等同于&a[0]

//强调步长：
//struct stu
//{
//	char name[10];
//	char number[11];
//}*p;//*表示p是一个该结构体类型的指针  该结构体类型(stu)占21个字节
//int main()
//{
//	printf("%p\n", p);//0x000000
//	//回忆：%p表示打印地址数据(以16进制形式) 当参数是指针时 打印指针存储的地址；当参数是&指针时 打印该指针的地址
//	printf("%p\n", p + 1);//0x000015 前面讲过 指针+/- 表示指针前进/后退多少步 步长取决于类型
//	//这里stu结构体类型占21个字节 所以结构体指针p的步长是21个字节 p+1跳过21个字节(或者说地址) 所以两者相差21(0x15)
//	return 0;
//}

//强调二维数组的陷阱：
//int main()
//{
	//int a[3][2] = { (0,1),(2,3),(4,5) };//陷阱1_正常二维数组中一维数组的元素在初始化时 会用{}括起来 而这里却是用()括起来的
	//所以这里实际上是一个逗号表达式(取最右边的结果) 实际初始化的结果是：
	//1  3
	//5  0
	//0  0
	//int* p = a[0];//陷阱2_此处的a[0]非两个特例 所以代表首元素地址 但是这个首元素地址是首个一维数组的首元素地址 也就是&a[0][0]
	//注意 a在非特例情况下代表的才是第一行的地址 也就是&a[0] 而&a[0]又用a[0][0]的地址来表示 但意义与&a[0][0]不同
	//printf("%d\n", p[0]);//注意：p[0]本质上就是*(p+0) 所以就是解引用p--->访问a[0][0] 也就是1
	//return 0;
//}
//强调：二维数组本质上是由n个一维数组拼接而成的 ！！！
//a[n-1]就是a中第n个一维数组的数组名 在非特例情况下 数组名代表该数组的首元素地址 所以a[n-1]也就代表了&a[n-1][0] 


//常用的字符函数和内存操作函数：

//1_strlen:计算字符串长度
//范式： size_t strlen(const char* str)
//strlen函数的结束标志只有'\0'! 读取到'\0'则结束计算 如果str中没有'\0' 则会读取出随机值(直到读取到0x00为止)
//strlen函数的经典易错题：
//int main()
//{
//	if (strlen("abc")-strlen("abcdef")>0)//注意strlen函数的返回类型是size_t 属于无符号整型 3-6=-3 无符号整型的-3是一个极大的正数
//	{
//		printf(">\n");//打印  >
//	}
//	else
//	{
//		printf("<=\n");
//	}
//	return 0;
//}

//2_strcpy:字符串拷贝函数
//范式： char* strcpy(char* strdest,const char* strsour)
//int main()
//{
//	char name[10] = { 0 };
//	strcpy(name, "zhangsan");
//	printf("%s\n", name);//zhangsan  字符数组可以直接以 %s+数组名 来打印
//	return 0;
//}
//strcpy函数是会将'\0'也拷贝过去的 这意味着如果提前遇到'\0' 则会被提前判定拷贝结束 后面的内容也就不会被拷贝过去：
//int main()
//{
//	char name[10] = { 0 };
//	strcpy(name, "zhang\0san");
//	printf("%s\n", name);//zhang
//	return 0;
//}
//此外 如果原数据中没有'\0' 那么拷贝也会出错 因为不知道何时停止；同时dest空间还要足够大 以确保放得下 dest指向空间还得是可修改的
//strcpy模拟实现：
//char* my_strcpy(char* dest, const char* sour)
//{
//	assert(dest && sour);
//	char* ret = dest;
//	while (*sour)
//	{
//		*dest++ = *sour++;//也可以讲这句语句直接放在while判断语句中 这样既实现了判断 又实现了赋值
//	}
//	return ret;
//}
//int main()
//{
//	char arr1[10] = "abcdef";
//	char arr2[10] = { 0 };
//	my_strcpy(arr2, arr1);
//	printf("%s\n", arr2);
//	return 0;
//}

//3_strcat:字符串追加 用于在原字符串后面(\0前面)追加字符(串)
//范式： char* strcat(char* dest,const char* sour) 
//和strcpy相似 要求sour字符串必须以'\0'结尾 dest指向空间必须足够大 并且对象可修改
//strcat不能用于自己给自己追加！！！会陷入死循环

//4_strcmp:字符串比较 实际上比较的是字符串的ASCII码值
//范式： int strcmp(const char* str1,const char* str2)
//strcmp是有返回值的 当前小于后 则返回<0的数字 ；前等于后 则返回0 ；前大于后 则返回>0的数字
//但是注意！strcmp函数是将两个字符串挨个比较的 而不是字符串整体
//这意味着 strcmp比较abcdef 和abf 时会判断为小于 因为是挨个比较的(并且Byte by Byte) 到第三个字符时前<后 所以判定为<


//你也许发现了 前面提到的这几个字符串函数都或多或少有些不安全的地方 集中在sour空间长度不受限 导致函数无法确保dest空间一定能放得下
//这就可能导致溢出 或者写入权限冲突 为了提高字符串函数的安全性 C语言又增加了长度受限的字符串函数：

//1'_strncpy:拷贝限定字符数的函数
//范式： char* strncpy(char* dest,const char* sour,size_t num)
//num即拷贝过来的字符数 当num超出sour总字符长度时 会自动补'\0'
//2'_strncat	 同理 但当num超出sour总字符长度时 不会自动补'\0' 同时如果追加的字符串中没有'\0' 会自动补'\0'
//3'_strncmp  同理 但有些细节不同

//如果想查看这些库函数的具体实现 可以用eveything搜索函数名.c 打开路径 找到文件位置后将文件拖到VS中 即可
//当然 这只是VS给出的一个参考实现 并不一定就是VS中使用的实现 VS是使用的其本身已经写好的静态库中的函数、

//5_strstr:在字符串中查找子串的函数 子串：字符串中的一部分字符串
//范式： char* strstr(const char* str1,const char* str2) 后者为子串
//返回：如果查找到了子串 则返回子串的首地址 ；如果没有查找到子串 则返回空指针NULL
//int main()
//{
//	char arr1[7] = "abcdef";
//	char substr[3] = "bc";//substr表示(欲查找)子串
//	char* ret = strstr(arr1, substr);
//	if (ret!=NULL)
//	{
//		printf("%s\n", ret);//打印bcdef 因为是以该指针为起点打印字符串
//	}
//	else
//	{
//		printf("No Findings");//但是strstr函数显然不能跳跃查找 只能查找连续的子串 例如这里str2如果是bd  最后就会打印No Findings
//	}
//	return  0;
//}
//strstr模拟实现：
//char* my_strstr(const char* str1, const char* str2)
//{
//	assert(str1 && str2);
//	const char* s1 = str1;//s1用来和s2对位比较
//	const char* s2 = str2;
//	const char* p = str1;//p用于表示源串指针渐进 额外用指针p来表示源串指针位置前进的意义?
//	//如果只用s1 s2 那当源串中有部分与子串前端相等时 将会导致s1移动 这时再用s1来比较s2时就可能会出错了
//	//例如下面给出的源串子串示例 如果用s1同时实现渐进和比较 就会返回空指针 因为这个子串实际上是需要多次重复对位比较的
//	//而只用s1 s2 的情况适合仅仅只需要一次性对位比较的子串 这就会导致错误 所以这里将两个功能别给两个指针实现
//	while (*p)//p为'\0'时表示已到末尾 自动退出循环
//	{
//		s1 = p;//s1需要同步更新
//		s2 = str2;//s2也需要重新赋初始地址
//		while (*s1!='\0'&&*s2!='\0'&& * s1 == *s2)//这里判断条件要多加上 !='\0'
//		{
//			s1++;
//			s2++;
//		}
//		if (*s2 == '\0')
//		{
//			return (char*)p;//需要对p强制类型转换 否则与返回类型不匹配
//		}
//		p++;
//	}
//	return NULL;//循环完还没有找到匹配项 故返回空指针
//}
//int main()
//{
//	char arr1[] = "abbbcdef";
//	char substr[] = "bbc";
//	char* ret = my_strstr(arr1, substr);
//	if (ret!=NULL)
//	{
//		printf("%s\n", ret);
//	}
//	else
//	{
//		printf("No Findings");
//	}
//	return  0;
//}

//查找子串在数据结构与算法中也有所提及  以后会学到 kmp算法 便是其中较为常用的一种

//6_strtok:切割字符串  一个有点奇怪的函数... token是标志/令牌的意思 strtok就是按照一个个标志分开字符串
//范式： char* strtok(char* str,const char* sep) 
//sep是分隔符的集合 分隔符就是欲切割处的字符 使用方式如下：
//int main()
//{
//	char str1[] = "abc@163.com";
//	char str2[40] = { 0 };
//	//strtok切割的实质：默认起始位置为第一个标记处 然后向后寻找下一个标记 找到后将其替换为\0 strtok函数会记忆这个标记的位置
//	//然后返回第一个标记处 所以strtok切割函数会改变字符串本身的内容 一般为了避免这一点会额外用一个临时字符数组来作为替代
//	strcpy(str2, str1);//这里的str2就是一个临时字符数组
//	const char* sep = "@.";
//	char* strtoken = strtok(str2, sep);//此时str2被分割为abc\0163.com 返回的仍然是第一个标记处 也就是'a'的地址
//	printf("%s\n", strtoken);//abc  事实上strtok一次只能切割一个分隔符 并且打印时只能打印到该分隔符为止
//	//如果要继续分割下一个分隔符 这时就需要重复调用strtok 并且第一个参数要传参NULL空指针
//	//传空指针是为了让strtok从上次记忆的位置开始向后查找下一个分隔符（以该地址的下一个地址为返回地址）
//	strtoken = strtok(NULL, sep);//返回值是'1'的地址
//	printf("%s\n", strtoken);//163
//	strtoken = strtok(NULL, sep);//如果一直到字符串结尾了还没有找到下一个分隔符 则返回这一次strtok的起始位置
//	printf("%s\n", strtoken);//com
//	strtoken = strtok(NULL, sep);//由于上一次strtok并没有找到分隔符 也就没有记忆位置 所以这一次strtok连返回的起始位置都没有
//	//于是只能返回空指针 所以打印时打印出了空指针
//	printf("%s\n", strtoken);//(null)
//	return 0;
//}//但是这样的写法稍显冗余 并且在打印前还要判断一下是否是空指针 所以接下来有一种"奇技淫巧"

//int main()
//{
//	char* str1 = "abc@163.com";
//	char str2[40] = { 0 };
//	strcpy(str2, str1);
//	const char* sep = "@.";
//	char* strtoken = NULL;//为了避免放在循环中多次初始化 这里先初始化为空指针
//	for ( strtoken = strtok(str2,sep); strtoken !=NULL; strtoken=strtok(NULL,sep))
//	{
//		//我们发现除了第一次传参传的数组名 后续传参都是NULL 所以在for的初始化阶段时先赋值为第一次传参的返回值
//		//然后判断条件无非就是判断是否是空指针 如果是空指针说明strtok函数已经找完了整个字符串了也没有找到下一个标记位置
//		//说明strtok函数的循环调用可以结束了
//		printf("%s\n", strtoken);//abc\n 163\n com\n  每调用一次strtok就可以打印结果了
//	}
//	return 0;
//}//这里对于循环的使用是恰到好处的 尤其是逼近条件设置为strtok返回值 由strtok去实现不断的向后查找 逼近直至返回NULL

//7_strerror:返回错误码所对应的错误信息
//范式： char* strerror(int errnum)
//事实上 C语言内置有错误代码 如0 1 2 3 4 5... 每一个代码有其对应的说明 也就是相应的错误信息
//而strerror就是用来查看代码执行时错误时的相关信息的 示例如下:
//int main()
//{
//	printf("%s\n", strerror(0));//No error  没有错误
//	printf("%s\n", strerror(1));//Operation not permitted   操作不被允许执行(如权限不够等等)
//	printf("%s\n", strerror(2));//No such file or directory  没有找到该文件/文件夹
//	printf("%s\n", strerror(3));//No such process  没有找到该进程
//	printf("%s\n", strerror(4));//Interrupted function call  函数调用错误
//	//...
//	return 0;
//}
//那么如何查看这些内置的错误代码呢？事实上 C语言内置了一个静态全局变量：errno 当程序执行错误发生时 会自动将错误代码存放到errno里面
//所以这时我们就可以通过printf("%s\n",strerror(errno))来打印错误信息

//文件的相对位置和绝对位置
//前者指的是某个项目下的文件在该项目下的位置 相对位置一般直接用文件名.后缀表示
//而绝对位置指的是文件在计算机中存储的明确位置 如C:\Program Files\Microsoft...(如果要在编译器中查找该文件 位置中的\要转义为\\)

//8_字符分类函数：
//我们常用的字符往往各有各的分类 如大写小写等等 而所谓字符分类函数就是 一系列判断字符是否具有该特征的函数 如果具有则返回真：
//iscntrl:判断是否是控制字符
//isspace:判断是否是空白字符(空格' ' 换页'\f' 换行'\n' 回车'\r' 制表'符'\t'或垂直制表符'\v')
//isdigit:判断是否是十进制数字(0~9)
//isxdigit:判断是否是十六进制数字(0~9 a~f A~F)
//islower:判断是否是小写字母
//isupper:判断是否是大写字母
//isalpha:判断是否是字母
//isalnum:判断是否是字母或者数字
//ispunct:判断是否是标点符号
//isgraph:判断是否是图形字符
//isprint:判断是否是可打印字符
//注意：以上字符分类函数的通用范式都是：int xxx(int c)
//int main()
//{
//	int a = isspace('a');
//	printf("%d\n", a);//0 因为a不是空白字符 所以返回0 如果为真则返回非零字符(这个具体返回多少C语言没有明确规定 取决于编译器)
//	return 0;
//}

//9_字符转换函数：tolower/toupper(转换成小写字母/大写字母)
//范式： int tolwer/toupper(int c)


//内存函数：
//1_memcpy:内存拷贝函数
//范式： void* memcpy(void* dest,const void* src,size_t count)	count是欲拷贝过去的字节数 用void*作指针类型是为了提高通用性
//void*表明是有返回类型的 并且返回类型是无类型的指针
//之前我们讲过 strcpy/strncpy 这些函数都只能用于字符串拷贝 如果我们要拷贝的是整型数组/浮点型数组呢
//单独设置相应的copy函数明显过于复杂 所以不妨直接在内存地址上进行操作 于是就有了memcpy：通过内存拷贝实现更通用的拷贝方式
//示例：
//int main()
//{
//	int arr1[] = { 1,2,3,4,5 };
//	int arr2[10] = { 0 };
//	memcpy(arr2, arr1, (size_t)20);//size_t强制类型转换可以不写 编译器会自动进行算术转换
//	for (int i = 0; i < 5; i++)
//	{
//		printf("%d ", arr2[i]);
//	}
//	return 0;
//}
//注意！memcpy负责的是拷贝两块独立空间的数据 但是不能用来进行重叠内存的拷贝 (能拷贝 但是与预期效果不符----->>>>>
//例如 给出一个整型数组{1,2,3,4,5,6,7,8,9} 欲将其用memcpy自行拷贝成{1,2,1,2,3,4,7,8,9} 也就是想要将3,4,5,6用1,2,3,4拷贝覆盖掉
//但是最后的结果会是1,2,1,2,1,2,7,8,9 为什么只剩下1 2了呢 这是因为在重叠拷贝时原本的3 4一开始就被覆盖掉了 
//而memcpy并不会备份将要被覆盖掉的数据 这就导致当拷贝继续往后进行时 原本的3 4已经变成1 2了 所以拷贝的也是1 2
//所以 memcpy通常只能用于拷贝两块相互独立空间中的数据 而重叠内存的拷贝 则常用到memmove函数----->>

//注意：void func(void c)表示这个函数是无返回类型并且无参数的
//而void* func(void* c)则表示这个函数的返回类型是无类型的指针 而且参数也是无类型的指针
//一定要区分出void和void* 前者表示无... 而后者表示无类型的指针   这一点一定要区分开来！！！

//2_memmove: 重叠内存拷贝函数
//范式： void* memmove(void* dest,const void* src,size_t count)   //与memcpy一致
//虽然 我们会发现 在VS编译器中 memcpy也能实现重叠内存的拷贝 但这是C语言规定之外的 C语言只规定了memcpy函数要实现两块独立空间的数据拷贝
//而重叠内存空间的拷贝则由memmove函数来实现 但是VS编译器为了使memcpy函数功能更强大 才额外补充了重叠内存拷贝的实现代码
//所以为了遵循C语言规范 我们仍然让memcpy和memmove各司其职

//模拟实现memmove：
//其实我们会发现 重叠内存拷贝中src拷贝的顺序是会改变的 (数组中的地址随下标增长而增长)
//例如：当dest<src时：1 2 (dest->)3 4 5 (src->)6 7 8 9 10 count=16  欲求得的结果是1 2 6 7 8 9 7 8 9 10
//这时6那里是重叠空间 如果我们让src和dest从后往前进行拷贝的话 那么9就要覆盖掉6 就会导致之前memcpy出现的问题 所以这里
//只能从前往后进行拷贝 而如果是src<dest 1 2 (src->)3 4 5 (dest->)6 7 8 9 10 count=16 欲求得的结果是1 2 3 4 5 3 4 5 6 10
//这时如果还是从前往后拷贝 就会发现 重叠的6那里提前被覆盖掉了 所以这时我们要从后往前拷贝
//这就说明 只要我们分开实现拷贝的功能就能实现重叠内存的拷贝 也即区分出dest</>/=src这里的大小关系是建立在两者有重叠内存基础上的！)
//具体实现：
//void* my_memmove(void* dest, const void* src, size_t count)
//{
//	assert(dest && src);
//	void* ret = dest;
//	if (dest<src)//分为dest<src和dest>=src两种情况
//	{
//		while (count--)
//		{
//			*(char*)dest = *(char*)src;
//			(char*)dest += 1;//由于dest和src是无类型指针 是类型不完整的指针 所以不能直接用dest++ /dest+= 这些写法
//			(char*)src += 1;//否则编译器由于不知道具体步长会访问出错的 所以这里一定要先进行显示类型转换！
//		}
//	}
//	else
//	{
//		while (count--)
//		{
//			*((char*)dest + count) = *((char*)src + count);//这里不需要再dest-1/src-1 因为+count时count本身就在自减
//		}
//	}
//	return ret;
//}
//int main()
//{
//	int arr1[] = { 1,2,3,4,5,6,7,8,9,10 };
//	my_memmove(arr1+2, arr1+5,(size_t)16);
//	for (int i = 0; i < 10; i++)
//	{
//		printf("%d ", arr1[i]);
//	}
//	return 0;
//}

//3_memcmp:内存比较函数
//范式： int memcmp(const void* ptr1,const void* ptr2,size_t count)  count是比较的字节数
//同样的memcmp函数是为了实现通用类型数据的比较 并且与strcmp类似的是 它的返回值也取决于----->>>
//当ptr1指向对象<ptr2指向对象时 返回一个<0的数
//当............>............时 返回一个>0的数
//当............=............时 返回一个=0的数
//并且memcmp函数还有一点与strcmp类似 就是它只要比较到一个字节出现大小关系时 就不会继续后面的比较了

//4_memset:内存设置函数  设置 这里可以理解为填充
//范式： void* memset(void* dest,int c,size_t count)
//解析：返回值是dest c是欲设置/填充的字符 count是设置/填充的字符数目
//使用示例：
//int main()
//{
//	char arr[10] = "hello!";
//	memset(arr, 'x', 3);//将前三个字节的内容设置为'x'
//	printf("%s\n", arr);//xxxlo! 
//	return 0;
//}
//当然 由于memset函数是以字节为单位进行设置/填充的 所以其实并不适用于占多个字节的数据的设置 例如
//memset(arr, 1, 10) 假定arr：int arr[10]={0} 所以这里的memset函数显然是想将arr中的每个元素都初始化为1
//但是最终结果却是将arr每个元素都初始化为了一个较大数  因为memset以字节为单位 设置为 1 则会将每个字节都设置为1
//所以最终会导致一个较大数------>> 所以！memset一般就是用字符串/数组的设置的！它并不适用于占多个字节的数据！


//一道易错题：
//int main()
//{
//	unsigned int a = 0x1234;
//	unsigned char b = *(unsigned char*)&a;
//	printf("%x\n", b);//以16进制形式打印 小端中34
//	return 0;
//}//请问这段代码在大端存储中的结果？
//这道题很容易以为是0x12 因为觉得12是数据的高位 应当在低地址处 没错 但是这样想忽略了a本身的类型
//a是unsigned int 类型 占4个字节0x1234仅仅只占两个字节 所以a实际的大小应该是0x00001234 所以00才是最高位 所以低地址处应该是00
//所以最后会打印00 

//左旋字符串：
//现有字符串 abcdefg  欲将其通过left_rotate函数实现转换为cdefgab
//思路：常规思路是将ab取出 然后先让cdefg指针依次向前进行赋值 然后最后让ab赋值到指针指向的原本fg的位置
//巧解：之前我们不是实现过一个reverse逆序字符串的函数吗？而这里刚好也可以直接用reverse来解决--->>
//首先 假定要左旋k个字符（这里k=2）先将左边k个字符用reverse逆序 然后将右边n-k个字符也用reverse逆序
//最后再将整体用reverse再次逆序 这样就实现了左旋字符串的需求！-------->>>>>这的确是很巧妙的解法啊:)
//将左边逆序 再将右边逆序 最后整体逆序 ->最后一步既将左右两边的字符恢复正常顺序 又将左边与右边顺序交换 实现了左旋字符串！

//杨氏矩阵查找问题：
//杨氏矩阵 由数学家杨辉发现 杨氏矩阵满足以下条件：
//1_数据的每一行 每一列 主对角线都是递增关系
//2_如果是严格的杨氏矩阵 每一行 每一列都要是严格递增关系(如1 2 3..)
//假定给出一个三阶杨氏矩阵：
//1 2 3
//4 5 6
//7 8 9
//现在要在这个矩阵中查找一个指定数据k 求返回坐标/不存在 要求时间复杂度小于o(n)
//解释：时间复杂度 如果说有n个元素 要全部遍历一次才能找到目标元素 则时间复杂度就是o(n)
//如果我们采用简单的forfor二维遍历 则显然时间复杂度就是o(n) 所以这里我们显然要思考出更简单的算法

//我们发现 这里由于每一行 每一列都是递增关系 所以每一行中最大的就是最右边的数据 并且这个数据从上往下也是递增的
//而在这个矩阵中最大的数据就是右下角的数据arr[2][2] 如果要查找的数据大于它 就说明数据没有在这个矩阵之中
//同理 如果一个数据>arr[i][2] 则说明这个数据一定不在这一行中 这样就可以快捷的排除掉这一行
//如果数据<arr[i][2] 则让其与arr[i][1]..[0]依次进行比较 最终得出是否在这个矩阵中即可
//同理也可以用数据<arr[i][0]来比较 如果数据是小于的 则说明一定不在这一行中 则可以跳转到上一行
//如果>arr[i][0] 则让其依次与arr[i][1]..[2]进行比较
//这种算法确实能满足时间复杂度的要求 但是如果让写出来的查找函数能够返回找到的坐标呢？

//我们知道 return只能返回单个数据 如果要返回坐标 这里又有两种方式需要知道：
//1_使用结构体 因为结构体变量相当于是静态全局变量 如果查找到k值 则可以修改s.x/y 然后在main函数中调用该结构体变量中的x y值即可
//struct xy 
//{
//	int x;
//	int y;
//}s;
//int find_num(int arr[3][3], int x, int y, int k)
//{
//	while (x<=2&&y>=0)
//	{
//		if (k<arr[x][y])
//		{
//			y--;
//		}
//		else if (k>arr[x][y])
//		{
//			x++;
//		}
//		else
//		{
//			s.x = x;
//			s.y = y;
//			return 1;
//		}
//	}
//	return 0;
//}
//int main()
//{
//	int arr[3][3] = { 1,2,3,4,5,6,7,8,9 };
//	int k = 0;
//	scanf("%d", &k);
//	int ret=find_num(arr, 0, 2, k);
//	if (ret==0)
//	{
//		printf("No Findings!\n");
//	}
//	else
//	{
//		printf("%d %d\n", s.x, s.y);
//	}
//	return 0;
//}

//2_传址调用x y：利用传址调用x y 在函数中查找的同时也就将x y进行了相应的赋值 最后在main函数中打印出来x y即可
//int find_num(int arr[3][3], int* px, int* py, int k)
//{
//	while (*px<=2&&*py>=0)
//	{
//		if (k<arr[*px][*py])
//		{
//			*py=*py-1;
//		}
//		else if (k>arr[*px][*py])
//		{
//			*px=*px+1;
//		}
//		else
//		{
//			return 1;
//		}
//	}
//	return 0;
//}
//int main()
//{
//	int arr[3][3] = { 1,2,3,4,5,6,7,8,9 };
//	int k = 0;
//	int x = 0, y = 2;
//	scanf("%d", &k);
//	int ret=find_num(arr, &x, &y, k);
//	if (ret==0)
//	{
//		printf("No Findings!\n");
//	}
//	else
//	{
//		printf("%d %d\n", x, y);
//	}
//	return 0;
//}


//自定义类型：结构体/联合体/枚举等等  目的：为了表示复杂对象
//1_结构体：
//结构：值的集合 这些值称作成员变量 成员变量可以是不同的类型
//struct stu//结构体的声明：注意 结构体的声明不能直接用来初始化结构体变量！
//{
//	char name[20];
//	int num[11];
//};//如果直接在这里定义结构体变量 这个变量是全局变量

//特殊的结构体声明：
//---->>>
//匿名结构体类型：
//在创建结构体类型时 我们可以不声明结构体名 而这样创建出来的结构体就是匿名结构体
//如：
//struct
//{
//	int a;
//	char arr[2];
//};//此时的结构体就是匿名结构体  匿名结构体如何使用？
//struct
//{
//	int a;
//	char arr[2];
//}s1;//这便是匿名结构体的使用方式！ 由于其特殊性 不能再后续拿来创建该类型的结构体变量 
//所以如果要使用匿名结构体就只能在声明时使用该结构体 并且 由此不难发现 匿名结构体就是一个一次性的产品
//那么请问 下面这种用法可行吗？
//struct
//{
//	int a;
//	char arr[2];
//}x;
//struct
//{
//	int a;
//	char arr[2];
//}s,*p;
//int main()
//{
//	p = &x;//既然两者同为匿名结构体 并且结构体类型看似也相同 那么这里可以将两者视为同一个结构体吗？
//	return 0;
//}//答案是否定的 编译器会给出"="等号左右类型不匹配的警告 这也就说明两者实质上是不同类型的结构体 至少对于编译器来说是这样的

//结构体的自引用：
//在结构体中包含一个类型为该结构体类型的成员变量：
//struct stu
//{
//	int data;
//	struct stu next;//这样写可以吗？  虽然在C语言规定中这样写也是合法的 但是在VS中这样写就是不合法的了 因为默认stu还未定义
//	//但是即使是这么写 问题也很明显 就是这样的stu定义的变量是无法确定具体大小的 也就无法分配内存空间
//};
//那么正确的结构体自引用呢：
//struct stu
//{
//	int a;
//	struct stu* ps;//答案就是在这里使用结构体指针 这样的话 该结构体的声明至少是完整的 编译器可以确定的
//};
//这种结构体自引用的行为 常见于链表----->>>这里涉及到数据结构
//所谓数据结构 就是数据在内存中的存储结构
//常见的数据结构有线形 树形 图形等等
//其中线形结构主要有两种：数组(又称线性表)以及链表
//前者在内存中用连续的内存来存放数据 而后者则是用不直接连续的内存来存放数据
//那么链表是如何实现对其中数据的访问的呢 答案就是通过结构体的自引用！
//假定一个数据被拆分为1 2 3 4 5个节点 由于其存放的位置不连续 如果要访问链表 那么最有效的方式就是让1节点包含数据的同时指向2节点
//然后2节点又指向3节点...直到5节点指向NULL 这就是链表的访问方式 而要实现这一点 就是要实现在每个节点处存放下个节点的指针
//struct Node//创建一个节点结构体
//{
//	int data;//这里用来存放该节点需要存储的数据  称作：数据域
//	struct Node* Next;//这里用来存放下一个节点的指针  称作：指针域
//};

//那么 下面这种方式可行吗？
//typedef struct //重命名一个匿名结构体
//{
//	int data;
//	Node* Next;//结构体自引用 同时使用的是重命名后的结构体名
//}Node;//试图重命名为Node
//显然这是不行的 因为typedef来重命名一个类型时 该类型必须是完整的 但是这里的Node*又必须要在typedef重命名后才能使用
//而如果Node*跑不通的话 这里的声明又不完整了 也就是说这个匿名结构体类型就不完整了
//那么这就成了一个先有鸡还是先有蛋的问题了 这显然是矛盾的   所以我们给出了避免矛盾的做法：
//typedef struct Node//避免这这里使用匿名结构体以确保后续结构体自引用时是安全的
//{
//	int data;
//	struct Node* Next;//使用目前为止的结构体类型名来自引用(不立刻使用Node*来自引用)
//}Node;//重命名  在这之后就可以正常使用Node来创建该结构体类型了(而不用struct Node)

//结构体的定义与初始化 前面已经讲过 这里只补充一点：
//如果在结构体声明的同时创建结构体变量并初始化？
//struct stu
//{
//	int a;
//	int b;
//}p1 = { 1,2 };//这里的p1就是答案！

//结构体嵌套定义(结构体变量)以及初始化：
//struct score
//{
//	int s1;
//	int s2;
//};
//struct stu
//{
//	char name[20];
//	struct score s;//这里就是嵌套定义了结构体score类型的变量s
//	//struct score s2 = { 2,3 };-->>编译器报错 ->但是 不能在结构体的声明过程中直接对另外一个结构体类型的变量进行初始化！
//	//因为结构体声明过程中的初始化是非法的！
//}P1 = { "zhangsan",{2,3} };//这是结构体嵌套定义后创建变量的初始化方式 即用大{}嵌套小{}的方式
//int main()
//{
//	printf("%s %d %d\n", P1.name, P1.s.s1, P1.s.s2);//这是嵌套定义了的结构体变量访问成员变量的方式之一 还有->
//	return 0;
//}

//结构体内存对齐：
//观察下面这段代码:
//struct s1
//{
//	char c1;
//	int i;
//	char c2;
//};
//struct s2
//{
//	char c1;
//	char c2;
//	int i;
//};//结构体类型s1和s2似乎没有什么区别？只是调换了一下成员的位置------>>>
//int main()
//{
//	printf("%zu\n", sizeof(struct s1));//12  为什么是12?不是6?
//	printf("%zu\n", sizeof(struct s2));//8-------->>>>????  为什么只是调换了一下结构体成员的位置 但是两者的大小却不相同？
//	return 0;
//}

//结构体所占的大小不能直接以成员大小计算 要考虑内存对齐规则：
//1_第一个成员在与结构体变量偏移量为0的地址处---->>也就是说第一个成员变量就以该结构体变量的地址为起点
//2_其他成员变量要对齐到对齐数k的整数倍的地址处--->>即其他成员变量首地址相较于起始地址偏移量为k倍 (偏移量可以理解为地址差值)
//  如果不足k倍则申请更多空间 向后补足k倍
//  对齐数= 编译器默认的一个值与该成员大小之间的较小值---->>VS中默认值为8 其他编译器没有默认值 直接就是成员变量自身大小！！！
//3_结构体总大小为最大对齐数(每个成员变量都有一个对齐数)的整数倍--->>也就是如果不足最大对齐数的整数倍则申请更多的空间
//4_如果有嵌套结构体的 嵌套的结构体仍然对齐到自己的最大对齐数的整数倍处 而结构体的整体大小仍然是所有对齐数中最大对齐数的整数倍
//:)以上的整数倍原则都是：如果不是整数倍则浪费一定空间 向后申请空间直至补齐为整数倍

//关于offsetof函数 调用需要引用<stddef.h>头文件
//范式： size_t offsetof(StructName,MemberName)  :第一个参数是结构体类型名 第二个参数是其中成员变量名
//offsetof函数可以查看结构体成员变量在该结构体变量中的偏移量（这也是offsetof函数的返回值）
//使用示例：printf("%zu\n",offsetof(struct stu,tele))

//关于偏移量：某个元素的(首)地址与这个元素所在的大内存空间的首地址的差值 可以以Byte/bit为单位 默认单位是Byte
//偏移量的用处：在编程中，计算机会利用偏移量来准确地访问数据结构中的成员，比如结构体中的字段，数组中的元素等
//偏移量的重要性：在处理底层内存操作和数据访问时非常重要，它可以帮助程序准确地定位并访问内存中的特定数据

//大的要来了---->>>为什么要存在内存对齐？ 这一点前面也讲过 这里再次重申：
