#define _CRT_SECURE_NO_WARNINGS//VS中使用scanf函数必备宏定义 scanf_s为VS专属
#pragma warning(disable:4996)//避免使用scanf时报 返回值被忽略;
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <windows.h>
#include <time.h>
#include <math.h>
#include <stdbool.h>

//hello world!
//int main()
//{
//	printf("hello world!\n");
//	return 0;
//}


//C语言的基本数据类型：
// char				字符型
// short			短整型	  【整
// int				整型
// long				长整型
// long long		更长的整型	型】
// float			单精度浮点数【实型		//关于float类型的初始化 注意0.0或者3.14等等浮点数，编译器都会默认为double类型
// double			双精度浮点数  即浮点型】//所以需要写作 float f=0.0f; 即在初始化值后面加个f 编译器就会按照float型进行初始化
// void				无值型（空值型）
// 
//布尔类型 bool
//注意布尔类型是在C99标准之后才有的 用于定义表示真假值的变量 例如:
//bool flat = true;也就是1
//		或	= false;也就是0
//bool类型仅这两种取值！并且使用bool类型要包含<stdbool.h>这个头文件


//C语言各基本数据类型的大小：
//int main()
//{
//	 printf("%zu\n", sizeof(char));		1
//	 printf("%zu\n", sizeof(short));	2
//	 printf("%zu\n", sizeof(int));		4
//	 printf("%zu\n", sizeof(long));		4
//	 printf("%zu\n", sizeof(long long));8
//	 printf("%zu\n", sizeof(float));	4
//	 printf("%zu\n", sizeof(double));	8
//	 printf("%zu\n", sizeof(void));		0
//
//	 return 0;
//}


//全局变量和局部变量同时出现时：
// int a=0;
// int main()
//{
//	void iu();
//	{
//		int a = 1;
//		printf("iu-->%d\n", a);
//	}
//	return 0;
//} //变量的赋值遵循就近原则----局部优先级高于全局


//全局变量和局部变量的作用域
//int main()
//{
//	void u();
//	{
//		int a = 1;
//		printf("u-->%d\n", a);
//	}
//	int a = 2;
//	printf("%d\n", a);
//	return 0;
//}


//常量之 数值常量
//int main()
//{
//	int a = 10;
//	printf("%d\n", a);
//	return 0;
//} 这种常量又称为字面常量
//
//
//常量之由 const 定义的常变量：
//int main(void)
//{
//	printf("hello world!\n\n");
//	return 0;
//}
//int main()
//{
//	const int a = 20;//const修饰导致a变为常变量
//	printf("%d\n",a);
//	return 0;
//}
//
//
//常量之由 #define 定义的标识符常量：
//#define max 100//此处 max 为define定义的标志符常量
//#define iu "abcdef"//此处两个宏定义都没有规定 形 可见后面被定义的内容不定
//int main()
//{
//	printf("%d\n", max);
//	int a = max;
//	printf("%d\n", a);//可见其可当作常量来使用
//	printf("%s\n", iu);//%s s:string 即打印字符串
//	return 0;
//}
//
//
//常量之 枚举常量
//enum Color
//{
//	RED,【枚举
//	GREEN,
//	BLUE  常量】
//}					   //R G B作为枚举类型Color的三种可能取值,这些可能取值便是枚举常量
//int main()
//{
//	int num = 10;
//	enum Color c = RED;//此处为对变量c的赋值操作 而赋的值便是枚举常量之一
//	int RED = 20;//容易发现，无法再次对枚举常量进行赋值或是更改操作
//	return 0;
//}


//基础求和程序
//int main()
//{
//	int num1 = 0;
//	int num2 = 0;
//	scanf("%d %d", &num1, &num2);// & 为取地址符 即获取已定义变量在内存中的位置 注意:此处为空格分隔:有时为逗号分隔！
//	int sum = num1 + num2;
//	printf("%d\n", sum);
//	return 0;
//}

//语句末尾勿忘  英文分号； ！
//


//关于数组以及数组内字符串长度的计算规则：
//#include <string.h>;//strlen可计算字符串长度 但是需要此头文件！
//strlen的返回值是 size_t 也就是无符号整型(unsigned int)
//int main() //F10+调试+窗口+监视 可进行查看程序在内存中的存取等操作
//{
//	char arr1[] = "abc";//char[4]
//	char arr2[] = { 'a','b','c' };//char[3]
//	char arr3[] = { 'a','b','c','\0' };//char[4]
//	char arr4[4] = { 'a','b','c' };//char[4]  此处为不完全初始化数组
//	//这说明 \0 仅在读取字符串时出现  是意为字符串读取到此为止的转义字符  而若读取单个字符形式的组合则无需\0 故内存占位将少一个字节
//	//可是注意！在 printf函数中打印截至到\0为止 若无\0 则将出现错误:
//	printf("%s\n", arr1);
//	printf("%s\n", arr2);//报错
//	printf("%s\n", arr3);//正常
//	printf("%s\n", arr4);//输出为"abc"  此处为不完全初始化数组的打印结果
//
//	printf("%d\n", strlen(arr1));//字符串长度为3
//	printf("%d\n", strlen(arr2));//字符串长度为35
//	printf("%d\n", strlen(arr3));//字符串长度为3
//	printf("%d\n", strlen(arr4));//字符串长度为3  此处为不完全初始化数组的字符串长度计算结果
//	//关于不完全初始化：若数组中的元素数目未达到定义数组的数目，则编译器会自动将未初始化的元素赋值为0；
//	//0--数字零  即数值为0（不因编码方式而变化）
//	//"0"--字符零  ASCII码值为48
//	//"\0"--转义字符零  ASCII码值为0
//	//可见 "\0"与被赋值的0（数字0）对于计算机而言是几乎等效的
//	
//	//占位符表示:这里需要占一个位置给后面的数据使用
//	//这说明 \0占内存但不计入字符长度                       补充 拉丁字母长度为一字节  汉字长度至少为二字节
//	 
//	           //                                                  补充 常用打印类型(占位符类型)有：
//            //											%d        整型 (有符号)     
//			 //												%zd		  有符号/无符号整型(能在两者之间自动切换)
//			//												%s        字符串
//		   //												%c        字符型
//		  //												%f        float型
//		 //													%lf       double型
//	    //													%zu       size_t类型
//	   //													%p		  以地址型打印(打印出对应地址)
//	  //													%u		  无符号整型(即无负数)
//	return 0;
//	//	printf()参数与占位符是一一对应关系，如果参数有n个占位符,则printf()的参数就应该有n+1个;
//	//printf()允许限定占位符的最小宽度 %5d表示这个占位符的宽度至少为5位，若不足，则对应的值前面会添加空格，若超出，则正常输出
//}//如若用 %*d则表示自动取占位符宽度;


//打印的标准模式：
//printf ("%...\n",",,,");
// 
// printf("%...\n"); 为字符串专属简写    建议统一写成标准模式；


//转义字符					释义
//\?							在书写连续多个问号时使用，防止他们被解析为三字母词
//\'							用于表示字符常量'
//\"							用于表示一个字符串内部的双引号
//\\							用于表示一个反斜杠，防止它被解释为一个转义序列符
//\a							警告字符，蜂鸣
//\b							退格符
//\f							进纸符
//\n							换行
//\r							回车
//\t							水平制表符  效果类似于 Tab
//\v							垂直制表符
//\ddd						    ddd表示一到三个八进制数字  编译器会将其转换为十进制后对应ASCII信息交换表里的字符后输出
//\xdd						    x后面的dd表示两个十六进制数字     同上
//\0							字符串的结束标志符
//备注：转义字符看似占多个字节 实则不然 均仅占位一个字节 为一个字符  如\t看似可打印出四个空格 实则是为单字符  示例如下
//
//存在转义字符的字符串长度计算
//int main()
//{
//	printf("%d\n", strlen("\ta"));   //长度为2
//	printf("%d\n", strlen("\x22 b"));//长度为3    注意 " "空格（占位符）也占了一个字节长度 
//
//	/*此处常见错误示范之-- > 试问下列字符串长度？*/
//    printf("%d\n", strlen("c:\test\628\test.c"));//长度为十四  易误以为是十三
//	printf("%d\n", strlen("abc\666"));//长度无法计算  易误以为是四
//	此处涉及到两个关于进制转义字符的常见错误 
//	1 前者\628 欲取八进制 但第三位却超过了8 故编译器自动判定为\62 而8则作为一个字符 这为错误一；
//	2 后者\666 欲取八进制 但换算为十进制后过大 超出了127 故无法在ASCII表中找到对应字符 故无法计算字符串长度 这位错误二；
//	return 0;
//} 


//注释
//C语言注释风格 /* */		不可嵌套 就近原则
//C++语言风格注释 //		可嵌套


//常见选择语句				常见循环语句
//1_ if  else                 while循环
//2_ switch                   for循环
//3_                          do...while循环


//if 语句示例
//int main()
//{
//	int a = 0;
//	printf("%s\n", "你想成为程序员大牛吗？");
//	printf("%s\n", "请选择1/0");
//	scanf("%d", &a);
//	if (a == 1)
//	{
//		printf("%s", "那就继续加油吧!");
//	}
//	else
//	{
//		printf("%s", "请不要忘记你为何开始！\n请选择1");
//	}
//	return 0;
//}
//"="表示赋值操作		"=="则表示判断或者比较两个值是否相等，是一种关系运算符


//while 语句示例
//int main()
//{
//	int line = 0;
//	printf("%s\n", "努力学习计算机知识");
//	while (line < 20000)
//	{
//		printf("练习敲代码:%d", line);
//		line++;
//
//		if (line >= 20000)										//常用技巧之--在打出函数名后按"Tab"键可快速生成{ }大括号;
//		{
//			printf("%s\n", "学习永不停止！");
//		}
//		else
//		{
//			printf("%s\n", "继续练习！");
//		}
//	}
//	return 0;
//}


//hhhhhhhhhhhhhhhhhhhhhh 是时候强调这件事情了少年！！！！！！
//没错！！！
//你个傻卵儿老是中英文字符搞混了还看不出来！！！ tmd报错的时候就使劲难受吧！
//尤其是这个 中文的"；" 和 英文的";"
//汗流浃背了吧老弟hhhhhhhhhhh
//其实关键就在于...字符所占的长度不同***
//仔细观察吧少年   line++


//C语言结构类型:
//1_顺序结构
//2_选择结构（分支结构）
//3_循环结构


//数组基础
//int main()
//{
//	int sss[3] = { 1,2,3 };
//	有序排列的同类数据元素的集合称为数组  (存储作用)
//				   0 1 2
//	为区分数组的各个元素 各分量对应着其数字编号 即下标 下标默认从零开始 如上;
//	printf("%d\n", sss[2]);
//	"[]"内自动识别为下标 而不是数字本身 若超出下标范围则输出错误，并且其中只能是常量不能是变量（VS不支持变长数组所致）；
//  事实上C99标准之前，数组的大小都是用常量或者常量表达式来指定的
//  而C99之后支持了变长数组，允许数组的大小是变量，但这种指定方式的数组是不能初始化的；
//  数组的初始化：int sss[3]={1,2,3};		不初始化：int sss[3];
//	return 0;
//}
//
//
//数组基础...
//int main()
//{
//	int ddd[7] = { 1,2,3,4,5,6,7};
//	int i = 0;
//	while (i <3)
//	{
//		i = i + 1;
//		printf("%d\n", ddd[i]);
//		i = i + 1;
//	}
//	while()内的真假用于判断是否进入循环
//	注意i++在前和在后对输出结果的影响是不同的！
//	return 0;
//
//}


//比大小并输出的两种写法--1 直接型
//int main()
//{
//	int a = 0;
//	int b = 0;
//	scanf("%d %d", &a, &b);
//	if (a>b)
//	{
//		printf("%d\n", a);
//
//	}
//	else
//	{
//		printf("%d\n", b);
//	}
//	return 0;
//}

//比大小并输出的两种写法--2 间接型
//int Max(int x, int y)
//{
//	if(x>y)
//		return x;
//	else
//		return y;
//}
//int main()
//{
//	int a = 0;
//	int b = 0;
//	scanf("%d %d", &a, &b);
//	int c=Max(a, b);
//	printf("%d\n", c);
//	return 0;
//}


//错误示例之 if语句中 的return后返回值必须为常量；
//int Change(int z)
//{
//	if (z > 0)
//	{
//		return -1;
//	}
//
//	else
//	{
//		return 0;
//	}
//}


//求一个函数 使得 当x>0时输出-1；当x<0时输出1；当x=0时输出0；
//int change(int a)
//{
//	if (a<0)
//	{
//		return 1;
//	}
//	else if (a==0)//注意 =是赋值   ==是判断等号两边是否相等；
//	{
//		return 0;
//	}
//	else
//	{
//		return -1;
//	}
//}
//int main()
//{
//	int a = 0;
//	scanf("%d", &a);
//	int b = change(a);
//	printf("%d", b);
//	return 0;
//}


//操作符
//算术操作符：
//=  -  *  /  %
//加 减 乘 除 取模
//除
//int main()
//{
//	int a = 7/2;
//	printf("%d\n", a);
//	//结果为3；这是因为当a b 同为整数时  计算机进行的是整数除法；而只有当其中至少有一个浮点数时才会进行浮点数除法！！！！！；
//	float a = 7/2;
//	printf("%f\n", a);
//	//更改打印形式后发现；输出错误；这说明除法种类会影响打印结果；
//	int a = 7/2.0;
//	printf("%d\n", a);
//	//仅更改除法种类后发现 仍然打印不出浮点数结果；可见二者缺一不可！！！；
//	float a = 7/2.0;
//	printf("%f\n", a);
//	float a = 7.0/ 2;
//	printf("%.1f\n", a);
//	//若要保留到浮点后几位  可如上操作 保留一位为.1 两位...
//	float a = -7 / 2.0;
//	printf("%.1f\n", a);
//	//可见该操作符适用于含有负数的操作
//	return 0;
//}
//取模
//int main()
//{
//	int b = 7 % 2;
//	printf("%d\n", b);
//	//取模操作符意为取余数 且该操作符两端仅能为整数 
//	int b = -7 % 2;
//	printf("%d\n", b);
//	//可见该操作符能进行含负数的操作 负数取模结果的正负号由第一个运算数的正负决定;
//	return 0;
//}


//赋值操作符
//=	+=	-=	*=	/=	%=	&=	^=	|=	>>=	<<=
//int main()
//{
//	int a = 0;
//	a = 10;
//	a = a + 1;
//	printf("%d\n", a);
//	int a = 0;
//	a = 10;
//	a += 1;
//	printf("%d\n", a);//上下二者等效  即a+=便是a=a+...	类比可知后面的操作符的含义；
//	return 0;
//}


//双目操作符：需要两个操作数的操作符，如+ - * /等；
//单目操作符；仅需要一个操作数的操作符，相关如下：
//逻辑反操作符：
//首先！C语言中规定 变量值为零则为假 其余则为真
//int main()
//{
//	int a = 0;
//	if (a)//if (ture)
//	{
//		printf("%s\n", "hehe");
//	}
//	int a = 0;
//	if (!a)
//	{
//		printf("%s\n", "hehe");
//	}
//	可见逻辑反操作符可改变C语言中逻辑的真假判断，从而影响输出结果；
//	return 0;
//}
//负值-以及正值+：
//int main()
//{
//	int a = 10;
//	int b = -a;
//	int c = +a;
//	printf("%d\n", b);//-意为取值为负
//	printf("%d\n", c);//+意为+() 意义不大
//	return 0;
//}
//sizeof 操作符：
//注意！！！size of 是单目操作符 不是函数；
//int main()
//{
//	int a = 0;
//	printf("%d\n", sizeof(a));//4
//	printf("%d\n", sizeof(int));//注意 若为此写法 则无法取去括号来写；
//	printf("%d\n", sizeof a);//省略a的括号后结果仍然计算正确 可见其不是函数(是函数则不能去除a的括号，否则报错)
//	return 0;
//}
//int main()
//{
//	int ass[10] = { 0 };//后续自动不完全初始化为数值0；
//	printf("%d\n", sizeof ass);//40;可见sizeof 计算的是整个数组的大小 单位为字节;  注意\0 是在字符串中出现！而非此处的(整型)数组
//	printf("%d\n", sizeof ass[0]);//4 []内的数字对应下标 数组下标从零开始 [0]代表第一个数组内的元素；
//	printf("%d\n", sizeof ass / sizeof ass[0]);//10 可如此求出数组内元素的个数
//	return 0;
//}
//前后置++ --
//int main()
//{
//	int a = 10;
//	int b = a++;//此处为后置++ 即++操作在欲++的变量之后 后置++遵循先使用 后++的原则!
//	printf("%d\n", a);//11
//	printf("%d\n", b);//10
//	//int c = d++;//注意 此处这种先使用标识符 再定义的方式是错误的! 并不是前置++！
//	int d = 20;
//	int e = ++d;//这才是正确的前置++的写法 遵循先++后使用的原则！
//	printf("%d\n", d);//21
//	printf("%d\n", e);//21
//	return 0;
//}
//-- 原理等同
//(类型) 强制类型转换
//int main()
//{
//	int a = 3.1;
//	printf("%d\n", a);// 3 “初始化”: 从“double”转换到“int”，可能丢失数据 
//	//由此看出 1-哪怕赋值为浮点数 编译器仍按整型输出 且程序依然能跑；2-哪怕赋值为一位 编译时也默认按double型转换为int型
//	//为何为最终仍然为int? 因为最开始定义变量时在内存中获取的是int型的存储位置 故哪怕赋值为浮点数 仍然会被转化为整型
//	int b = (int)2.1;//(类型)可以强制转换其类型 此处 double-->int
//	printf("%d\n", b);//不再报这个错误：“初始化”: 从“double”转换到“int”，可能丢失数据
//	return 0;
//}


//关系操作符
// > < = <= >=		!=				==
//				用于测试不等于  用于测试等于
//着重！== 判断两端是否相等 
//int main()
//{
//	int a = 0;
//	if (a=1)//if语句()括号内会判断是否为真	a初始化为0 本为假 但是当赋值a=1后为真 故打印成功
//	{
//		printf("hehe\n");
//	}
//	return 0;
//}
//int main()
//{
//	int a = 0;
//	if(a==1)//a赋值为零 ==测试不等于1 故判断为假 打印失败
//	{
//		printf("hehe\n");
//	}
//	return 0;
//}


//逻辑操作符
//&& 逻辑与-并且...
//|| 逻辑或-或者...


//三目操作符（条件操作符）
//int main()
//{
//	int a = 1;
//	int b = 2;
//	int c = (a > b ? a : b);//条件操作符的示例：exp1 ? exp2 : exp3
//	int d = (a < b ? a : b);//			第一表达式是在进行判断；若一为真 则该操作符输出结果为就近原则 输出二；反之输出三
//	printf("%d\n", d);
//	printf("%d\n", c);
//	return 0;
//}


//逗号表达式
//特点：从左向右 依次计算 取最后表达式的结果为整个表达式的结果；
//int main()
//{
//	int a = 1;
//	int b = 2;
//	int c = (a + b, a * b, a - b);
//	printf("%d\n", c);//值为-1 满足特点；
//	return 0;
//}


//下标引用操作符
//[]是下标引用符 arr 和 3 是[]的操作数
//int main()
//{
//	int arr[10] = { 1,2,3,4,5,6,7,8,8,10 };
//	printf("%d\n", arr[3]);//4
//	printf("%d\n", 3[arr]);//4 可见[]对操作数的处理是一视同仁的
//	int n = 3;
//	printf("%d\n", arr[n]);//4 可见在[]利用下标引用已定义数组中的参数时 []中可以为变量 但是定义数组时[]中不能有变量
//	return 0;
//}
// 
// 
// 函数调用操作符：（） 括号不可省 且括号内外均为该操作符的操作数！


//关键字：C语言本身内置的 而非编写者可以自创的： 编写者定义变量名时也不可以用关键字来命名
//举例一：auto  auto一般被省略掉	define不是关键字！！！
//当定义局部变量时 进入局部变量的作用域时，局部变量自动开始生效；处作用域时自动失效 这便是 auto的作用效果：自动


//变量的命名
//1_应当有实际意义 并且编写者能看懂
//2_名字必须是字母 数字 下划线 组成 不能有特殊字符 不能以数字开头
//3_不能是关键字
//
//
//typedef:对类型重命名
//typedef unsigned int uit;//将无符号整型重命名为 uit;
//int main()
//{
//	uit a = 1;
//	int b = 1;
//	printf("%d\n", a);//1
//	printf("%d\n", b);//1
//	//两者打印结果相同；可见被typedef重命名之后的类型与命名前等效 只是更改了写法
//	return 0;
//}
////有时重命名 形如下所示
//typedef struct Node
//{
//	int data;
//	struct Node* next;
//}stde;//此时对于结构体类型 struct Node重命名为stde 此两种仅为不同情况下的写法；


//static及存储体系介绍
//void test()
//{
//	//int a = 1;//结果：2，2，2...
//	static int a = 1;//结果：2，3，4...
//	a++; 
//	printf("%d\n", a);//为何先使用后加加打印结果为2？因为在a++的a之前并无使用a的地方 而语句从左往右继续执行 故到打印时已加一
//}
//int main()
//{
//	int i = 0;
//	while (i<10)//i为循环次数
//	{
//		test();
//		i++;
//	}
//	return 0;//为何循环打印出来是十个2 而不是2，3...？
//			 //这是因为建立函数test时 其中设置的变量a为局部变量 具有生命周期 每次进入作用域时都重新开始了
//}
//关于 static：
//1_使用static声明的变量是静态变量 初始值为0，其作用域被限制在其被定义的源文件中 生命周期为整个程序开始到结束;
//1-1 static修饰局部变量的时候改变了局部变量的存储位置 从内存的栈区改为了静态区 即原先的局部变量改变为静态(局部)变量了;
//1-2 static修饰全局变量的时候改变了其 外部链接属性-->内部链接属性 此工程的其他源文件便不能再使用这个全局变量了；
//2_使用static声明的函数是静态函数 作用域被限制在其被定义的源文件中 其不能被其他文件中的函数调用；
// 注意：函数本来也有外部链接属性的 若要调用具有该属性的函数或全局变量 只需在其前面加上 extern即可！
//3_使用static声明的代码块是静态代码块 其只会在第一次被使用时执行一次 之后不会再次执行.


//关于内存的分区:
//1_栈区(static) :存放局部变量(包括const定义的局部变量) 形参 返回值;先入后出	由编译器自动分配释放
//2_堆区(heap) : 调用函数 : malloc(),free(),calloc(),realloc();					由程序员分配内存和释放(动态内存分配)
//3_全局(静态)区(分为 .bass 以及 .data) :存放全局变量和静态变量;
//4_常量区(.rodata) :存放字符串 数字等常量以及const修饰的全局变量;
//5_代码区(.text):存放程序的执行代码 也可能有字符串常量和define定义的常量存放.
//
//
//计算机存储体系：
//1_寄存器(集成到CPU上)
//2_高速缓存(cache)
//3_内存
//4_硬盘
//越往上，与CPU交换信息的速度越快，空间越小，造价越高； 实际使用时信息会有自下往上的信息传递；
//关键字register:(寄存器)
//int main()
//{
//	register int a = 1;//register意为 建议将该变量的位置存放在寄存器中使其读写和运行速度更快 但只能是建议！
//	printf("%d\n", a);
//	return 0;
//}


//#define 不仅可以定义标识符常量 还可定义宏
//#define ADD(x,y) ((x)+(y))
//ADD为宏名 宏是宏 而函数是函数
//(x,y)中的x,y为宏的参数，参数是无类型；
//而((x)+(y))为宏体
//需要知道的是 宏是完成替换的 当下文ADD返回参数给宏时 宏自动给对应参数完成替换 如：
//int c = ADD(a, b)-- > int c = ((a)+(b));
//int main()
//{
//	int a = 10;
//	int b = 20;
//	int c = ADD(a, b);
//	printf("%d\n", c);
//	return 0;
//}


//指针***
//1_内存
//首先：计算机中程序的运行都是在内存中运行的
//为提升内存的使用效率 内存被划分成一个个小的内存单元(类似于excel表格形式) 每个内存单元的大小是一个Byte
//同时每个内存单元有自己的编号 称为该内存单元的地址 地址为便于编号采用16进制数表示(只是一种数据表示方式)
//补充 在计算机内部二进制数据转换为16进制数据最直接 最快捷 占用存储空间最小；
//在32位电脑中 可能的内存地址(寻址空间)数有2^32次方个 换算如下：(地址为32bit位 二进制 故有2^32次方种可能)
//2^32=4294967296Byte
//	=4194304Kb
//	=4096Mb
//	=4Gb 即4Gb个
//而在64位电脑中 可能的内存地址达到了惊人的16384Pb个 但受实例的限制 目前windows仅能支持达到512Gb的内存
//换算关系:
//8 bit =1Byte
//1024 Byte=1Kb
//1024 Kb=1Mb
//1024 Mb=1Gb
//1024 Gb=1Tb
//1024 Tb=1Pb


//2_查看内存地址
//int main()
//{
//	int a = 10;//向内存申请4个字节，用于存储10; 但实际上哪怕变量a要了四个字节单位 a仍然是放在第一个字节单位中;
//	printf("%p\n", &a);//0x 0000 00C5 D28F FC74 这便是内存地址之一(第一个字节的)(随机)	0x表示这个数据是16进制表示的
//	printf("%p\n", a);//000000000000000A	 而这是内存中的数据(16进制的 10) 
//	return 0;
//}
//也可直接查看内存地址调用等信息:F10+调试到末行+调试+窗口+内存+&a即可
//如上操作结果左侧为内存地址 中间为内存中的数据 右边为不准确的内存数据的文本解析


//查看字符类型的ascii码值：
//int main()
//{
//	char a = 0;
//	scanf("%c",&a);
//	printf("%d\n", a);//以整型输出字符时会默认输出ascii码值！
// //反之亦可以利用给定数值当作ascii码值反向输出对应字符：
//	int b = 0;
//	scanf("%d", &b);
//	printf("%c\n", b);//以字符型输出数字时会默认输出ASCII码表中对应字符！
//	return 0;
//}


//3_指针及指针变量
//int main()
//{
//	int b = 20;////注意 内存地址用编号表示 而地址也被称之为指针 而存储指针的变量就是指针变量
//	int* p = &b;//int是因为p存储着b的内存地址&b,而指向的数据为int类型的b  *说明p是指针变量
//	char c = 'w';//上下的p q均为指针变量的名字 而int* 和 char*为其类型声明
//	char* q = &c;//此处c为char型 故存放指向c地址的指针变量q应表示为char*型		对应关系！
//	//指针变量的意义？
//	*p=10;//解引用操作符，和取地址符在一定程度上是互逆关系：即通过p中存放的地址找到p所指的对象 *p就是p指向的对象
//	printf("%d\n", b);//10; 利用指针变量可以很容易地通过地址指向找到最初变量的地址 并且进行数据更改！
//	return 0;
//}注意：口头上经常就将指针变量叫为指针
//指针变量的大小？
//int main()
//{
//	printf("%zu\n", sizeof(char*));//8
//	printf("%zu\n", sizeof(short*));//8
//	printf("%zu\n", sizeof(int*));//8
//	printf("%zu\n", sizeof(long*));//8
//	printf("%zu\n", sizeof(long long*));//8
//	printf("%zu\n", sizeof(float*));//8
//	printf("%zu\n", sizeof(double*));//8
//	//为何结果全为8? 不管任何类型的指针都是在创建指针变量 指针变量是用来存放地址的
//	//指针变量的大小取决于计算机内存地址编号的长度 64位处理器的计算机内部的内存地址编号均为64bit位 也即8字节的大小
//  //而指针是用来存放这些地址编号的 那么指针的大小就不能低于8字节 所以x64中指针的大小都是8字节的
//	//值得一提的是 x86是32位处理器 其寄存器是32位的	x86只是由于其CPU架构为x86类型而得名 类比可知其中指针的大小是4字节
//	return 0;
//}


//结构体 struct
//C语言给了程序员自定义类型的能力 结构体便是一种自定义类型
//结构体使得C语言能够描述复杂类型 因为结构体是把单一类型组合在一起用的做法
//struct stu//创建结构体类型struct stu
//{
//	char name[20];
//	int age;
//	char sex[10];
//	char tele[12];//这四个均为结构体的成员(变量)
//};
//
//void print(struct stu* ps)//此处无需计算出值后返回而是直接打印 故使用void表明无返回值 ()内表明参数为结构体类型stu类型的指针变量ps
//{
//	printf("%s\n %d\n %s\n %s\n", (*ps).name, (*ps).age, (*ps).sex, (*ps).tele);
//	//*ps意为解引用指针变量ps以找到s ()是为了提升优先级 因为其优先级低于.和->操作符;'.'仍然是从结构体对象(变量s)中引用成员...
//	printf("%s\n %d\n %s\n %s\n", ps->name, ps->age, ps->sex, ps->tele);//->也是操作符 意为从结构体指针变量中引用成员...
//	//可以理解为 ps指向变量s的地址 而->则更进一步指向name的地址从而引用成员name 即指向的结构体的...
//	//-> 和 (*). 此二者是等效的
//}
//
//int main()
//{
//	struct stu s = { " 张三",18,"男","12345678" };//由int ...类型可创建变量联想 结构体类型也是类型 故此处创建结构体类型变量s ："图纸"-->"房子"
//	//注意 结构体类型列出成员时均为{} 而创建相应变量时也用{} 而{}内" 张三"等是在进行相应的初始化 也即整个变量的初始化
//	//printf("%s\n %d\n %s\n %s\n", s.name, s.age, s.sex, s.tele);//.是操作符 意为从结构体对象(变量s)中引用成员... 即结构体对象的...
//	//printf("%s\n %s\n %d\n %s\n", s.name, s.sex, s.age, s.tele);//可见结构体变量创建后对于其成员的调用不必按照创建结构体类型时的顺序！
//	print(&s);//print是一个函数 ()内意为引用s的地址作为函数print的入口参数
//	return 0;
//}


//拆分输入输出
//int main()
//{
//	int a1, a2, a3 = 0;
//	scanf("%3d %3d %3d", &a1, &a2, &a3);//照此输入后 输入的整型数据会每三位数字一份放入到a1 a2 a3中 超出三位也只取三位
//	printf("%d %d %d", a1, a2, a3);
//	return 0;
//}
//注意：%m,nf表示输出的浮点数，m为宽度(域宽)，n为小数点右边数位(精度),未指定n时，隐含的精度为6(因为是单精度浮点型)；
//同时，在字符串的拆分输入输出时：
//int main()
//{
//	char a[10];
//	gets(a);//gets()可以读取含空格的字符串 而scanf不能 但是要用gets()时只能输入字符数组类型的变量；并且！gets()和scanf均不能检测越界
// 补充puts()的用法，puts()与前两个函数的区别是puts()在输出完后会自动换行；
//	printf("%6.3s", a);//要求输出前三个且占六列 %m.ns: 输出m列 但只取字符串字符串中左端n个字符 空格从左往右补位；
//	return 0;//注意 无论是浮点数还是整型还是字符串若写为%-m.n...则表示空格从右往左补位 但若是n>m 则会自动取n值以保证完整性；
//}
//注意：
//int main()
//{
//	char a[10];//由于此处要输入的是字符串数据 故不能用 char a=0;来进行初始化！而是应采用字符数组来放置字符串
//	scanf("%s", &a);
//	printf("%s\n", a);
//	return 0;
//}


//现在 恭喜你到达C语言初阶的世界!
//回顾：C语言语句分类：
//1_表达式语句
//2_函数调用语句
//3_控制语句
//4_复合语句
//5_空语句
//接下来要学习的是其中的控制语句
//前面提到C语言是一种结构性程序设计语言 三大结构便是 顺序 选择 循环
//而控制语句用于控制程序的执行流程，以实现程序的各种结构方式，它们由特定语句定义符组成 C语言提供了9种控制语句
//分成三类如下：
//1_分支语句(条件判断语句)： if语句  switch语句；
//2_循环执行语句：do while语句 while语句 for语句；
//3_转向语句：break语句 goto语句 continue语句；


//if语句：
//语法结构：1
//if(表达式)//若表达式的真值为1，则输出下列语句；
//	语句；
//int main()
//{
//	if (1==2)
//	{
//		printf("%s", "hello");//未输出"hello"
//	}
//	if (1<2)
//	{
//		printf("%s", "hehe\n");//输出"hehe"
//	}
//	int a = 1;
//	if (a=2)//编译器会将这里理解为对a的赋值 所以无论怎样都是"true"  上一步则会被理解为对变量a的初始化
//	{
//		printf("%d", a);//仍然输出了2  因为变量的使用是遵循就近原则的 
//	}
//	return 0;
//}
//语法结构：2
//if (表达式)
//	语句1；
//else
//	语句2；
//与上文同理，只是if和else后面跟的语句都默认只有一条 若要使用多条语句 需用{}括起来 VS中在if后使用Tab键可自动补全 {}表示代码块
//语法结构：3
//if (表达式)
//	语句1；
//else if (表达式)//else if可以多次使用以表明多分支
//	语句2；
//else
//	语句3；//适用于多分支结构
//int main()
//{
//	int age = 0;
//	scanf("%d", &age);
//	if (0 < age < 28)
//	{
//		printf("%s\n", "童年/少年/青年");
//	}
//	else if (28 < age < 50)
//	{
//		printf("%s\n", "中年");
//	}
//	else if (50<age<65)
//	{
//		printf("%s\n", "中老年");
//	}
//	else
//		printf("%s\n", "老年");
//	return 0;
//}//有意思的是 你将会发现不管输入多少 都会输出第一个结果 这是因为C语言并不完全支持数学中的写法
//在数学中 a<x<b 和 x>a且x<b 是等价的 但是在C语言中会认为这两者是 或 的关系 因此 我们需要对程序进行一些修改
//int main()
//{
//	int age = 0;
//	scanf("%d", &age);
//	if (age > 0 && age < 28)//在C语言中 &&表示并且，||表示或者；
//	{
//		printf("%s\n", "童年/少年/青年");
//	}
//	else if (age > 28 && age < 50)
//	{
//		printf("%s\n", "中年");
//	}
//	else if (age>50 && age<65)
//	{
//		printf("%s\n", "中老年");
//	}
//	else
//		printf("%s\n", "老年");
//	return 0;
//}//注意编译器当读取到if内为真时便不会再编译else后面的语句 反之若if内为假便不会编译if后面的语句
// //修改后程序运行正常 可见在C语言中要写成 x>a且x<b 的形式 才能被编译器正确处理；


//悬空else:
//int main()
//{
//	int a = 0;
//	int b = 2;
//	if (a == 1)
//		if (b == 3)
//			printf("%s\n", "haha");
//	else
//		printf("%s\n", "hehe");
//	return 0;
//}//猜猜打印结果？"hehe"吗？			哈哈 啥也没有
//这是因为 if语句是和就近的else匹配的 二者反之也是 所以第一个if是语法结构1的类型，又因为a\=1 所以下面的整个if else都不会执行
//这里容易误以为第一个if和else对齐从而以为会输出"hehe",但事实上 else本身位置是悬空的，与是否对齐无关 类似的悬空情况有很多
//亦得 写代码时要注意其可读性 并尽可能地用{}将代码块括起来 


//预防出现bug小技巧之一：
//在需要使用 == 判断左右两边是否相等时将变量放右边 常量放左边(常左变右)
//int main()
//{
//	int a = 10;
//	if (a=1)//不小心输入错误 少写了一个= 变成了赋值(无所谓真假)
//	{
//		printf("%s", "hehe");//仍然打印了"hehe" 这是因为编译器并不会对其if()内赋值操作报语法错误  这便导致了出现bug的潜在风险
//	}
//	return 0;
//}
//我们不妨写为：
//int main()
//{
//	int a = 10;
//	if (1=a)
//	{
//		printf("%s", "hehe");
//	}//编译器报错了 因为将一个变量赋值给一个常量是不被允许的！  在这种情况下 编写者便能在第一时间内发现这个错误
//	if (1==a)//修改后
//	{
//		printf("%s", "hehe");
//	}//这便于避免bug的出现
//	return 0;
//}

//:判断一个数是否是奇数 分支语句示例如下
//int main()
//{
//	int a = 0;
//	scanf("%d", &a);
//	if (1==a%2)
//	{
//		printf("%d为奇数",a);
//	}
//	else
//	{
//		printf("%d是偶数",a);
//	}
//	return 0;
//}


//输出1-100中的所有奇数:
//int main()
//{
//	int i = 1;
//	while (i<100)
//	{
//		if (1==i%2)
//		{
//			printf("%d\n", i);
//		}
//		i++;
//	}
//	return 0;
//}//这便是经典的循环+分支嵌套！
//纯循环写法:
//int main()
//{
//	int i = 1;
//	while (i<100)
//	{
//		printf("%d\n", i);
//		i += 2;//i+=2即i=i+2;
//	}
//	return 0;
//}

//在讲switch之前，紧急补充关于char类型的知识：
//int main()
//{
//	char a = -1;
//	unsigned char b = -1;
//	signed char c = -1;
//	printf("%d\n%d\n%d\n", a,b,c);//-1 255 -1
//	char d = 128;
//	unsigned char e = 128;
//	signed char f = 128;
//	printf("%d\n%d\n%d\n", d, e, f);//-128 128 -128
//	return 0;
//}//这里涉及到几个很古老的疑惑：
//为什么这里能用整型打印字符型数据？	为什么字符型数据打印为整型时会有有符号和无符号之分，并且打印效果迥异？
//char 类型声明用于存储字符，但是其本质上是整型的一个分支
//这是因为计算机并不能理解字符，所以在存储字符时实际存储的是整型数据，所以在打印时可采用%d,%c两种打印类型
//当采用%d类型时，则直接打印该字符在存储时使用的整型数据(与ASCII码表相对应)
//若采用%c类型时，则会在打印时再根据ASCII码表转换回整型对应的字符
//由此观之，char类型实质上就是整形的分支之一，所以甚至可以直接定义整型变量时使用char来声明
//但是这里又要注意
//1_在使用char类型创建变量时，存在 有符号和无符号之分，这里的有无符号实质是指一个字节(8bit)中首个个bit是否是符号位之分
// 若首bit是符号位，则这个字节大小由后7个二进制数表示，首位仅表示正负:1为负，0为正；			范围:-128到127
// 若首bit不是符号位，则字节大小由8个二进制数共同表示，显然此时能表示更大的数，但不能表示负数；	范围:0到255
//2_如上所示，有符号位字符类型写作 (signed) char;而无符号位字符类型则写作 unsigned char;前者的signed被大部分编译器认为可以忽略
//而上面程序中的无符号字符变量b因为存储整型范围限制，所以无法打印出负数
//而上面的有符号字符变量d和f也因为...，所以无法打印出>127的数
//有趣的是，对于无符号位char类型而言，全体整数都是由0-255的区间构成的，即从-无穷到+无穷是由无数个该区间一前一后紧挨着填充满的
//用样的，计算机对与有符号位char类型也是这么理解的，只不过区间是-128到127；
//由此，你便可以类比理解到 unsigned int,unsigned short int.etc以及用字符型来打印整型数据最后得到字符的原理
//最后，还需补充:无论是有还是无符号位char类型，能存储的整型数据区间大小都是256，但是ASCII码表仍然只能对应0-127
//补充一个定义 char类型定义一个字符类型的变量，而''内则称之为字符常量；


//switch 语句:是一种多路选择结构，通常用于替代一系列嵌套的if-else语句，使代码更清晰易懂;
//int main()
//{
//	switch (整形表达式)//()内是switch的开关，也就是分支结构执行的入口
//	{
//	case 整型常量表达式://整型常量表达式包括字符常量！理由见上
//		语句;//当case后的整型常量表达式==switch中的整型表达式时,程序才会进入这个分支，从而执行后面的语句;
//		break;//break是该分支结构结束的出口,若没有 break,则程序进入此分支之后的分支都会挨个进入并且执行;
//			 //需要知道的是 break能力是有限的 当存在嵌套switch时 内层的break只能跳出内层switch分支 而想要跳出外层则需要外层break才行
//	case...
//		语句;
//		break;
//	default://当switch结构中的case无一匹配时，程序便会进入default,并执行语句,然后退出switch分支结构;
//		语句;
//		break;//似乎哪怕没有default,分支结构依然会到此为止,但是default及后面语句的存在才可以确保程序至少会有一个默认行为！
//	//default语句可以放在switch中的任意一个位置...补充 case语句并不要求顺序 也就是说可以随意摆放case default位置 只要符合语法规则
//	}
// 
//	return 0;
//}
//下面是一个典型的switch语句:
//int main()
//{
//	int day = 0;
//	scanf("%d", &day);
//	switch (day)
//	{
//	case 1:
//		printf("星期一\n");
//		break;
//	case 2:
//		printf("星期二\n");
//		break;
//	case 3:
//		printf("星期三\n");
//		break;
//	case 4:
//		printf("星期四\n");
//		break;
//	case 5:
//		printf("星期五\n");
//		break;
//	case 6:
//		printf("星期六\n");
//		break;
//	case 7:
//		printf("星期天\n");
//		break;
//	default:
//		printf("输入错误\n");
//		break;
//	}
//
//	return 0;
//}
//如果想要在输入1，2，3，4，5时 输出工作日;6，7时 输出周末;可以按照如下操作:
//int main()
//{
//	int day = 0;
//	scanf("%d", &day);
//	switch (day)
//	{
//	case 1://即不使用出口break，任其执行下面的分支路径，直到break为止即可;
//	case 2:
//	case 3:
//	case 4:
//	case 5:
//		printf("weekday\n");
//		break;
//	case 6:
//	case 7:
//		printf("weekend\n");
//		break;
//	default:
//		printf("error\n");
//		break;
//	}
//
//	return 0;
//}
//补充:switch是可以嵌套的，但请注意,break仍然只和相应的的case对应,例如在嵌套的switch中，遇见break仅仅只会跳出当前嵌套，而不是整个分支结构


//while循环:
//int main()
//{
//	int i = 1;
//	while (i<=10)
//	{
//		//if (5==i)
//		//{
//		//	break;//打印结果为1234;可见在while循环中的break可以直接终止整个循环，这点与switch语句不同；
//		//}
//		if (5==i)
//		{
//			continue;//打印结果同样为1234但是右边|光标一直闪烁，这是因为程序一直在运行，还远未结束
//		}//可见continue可以跳过本次循环后面的代码，直接去判断下一次循环是否进行 由于i++在后 故i一直=5 陷入了死循环
//		printf("%d", i);
//		i++;
//	}
//
//	return 0;
//}
//int main()
//{
//	int i = 0;
//	while (i <= 10)
//	{
//		i++;
//		if (5==i)
//		{
//			continue;//为什么这次continue打印出了后面的数并且没有死循环? 这是因为i++在前，从i>5开始if分支便不执行了 于是循环继续 直到i>10为止
//		}
//		printf("%d", i);//打印出了123467891011
//	}
//
//	return 0;
//}


//int main()
//{
//	int ch = getchar();
//	//关于getchar():意为获取一个字符,注意仅为一个字符(人为输入的)，将其放置到变量ch中,类似于scanf();
//	//为什么用int不用char? 首先请注意，对于计算机而言，字符的实质就是ascii数字编码，因此getchar的返回值便是整型数据
//	//其次，当遇到读取错误或者读取到EOF(end of file)时,函数会返回一个'EOF',而EOF本质上是define定义的-1，故也需要整型返回 综上两点
//	//其实若只是常规用来读取字符，char类型也可以，因为char类型也是整型的一种
//	//但是考虑到可能会返回EOF，而EOF(整型的-1)用char类型返回长度会溢出，故综合考量下使用int类型为不会出错的选择
//		putchar(ch);
//	//关于putchar() 类似于printf() 输出int类型数据，但是要输出的字符常常使用unsigned char长度传递(8位)，故实际上这些字符被视为char类型处理；
//	return 0;
//}


//补充：为什么getchar 和scanf是截然不同的两种输入函数？
//因为getchar能够读取\n(空格)和回车，而scanf不能；当键盘的输入数据传递到缓冲区后,若是scanf，则会取走前面的数据而留下\n
//而这将导致在下一次读取时，缓冲区会有残留的数据(空格或回车等)，在一些需要重复读取输入的问题中将可能出错，比如请确认密码时；
//而putchar则不会出现这种情况 当然也可以用putchar来清空缓冲区然后再进行重复的读取输入;
//示例如下:
//int main()
//{
//	char password[20] = { 0 };
//	int ch = 0;
//	printf("请输入密码:\n");
//	scanf("%s", password);
//	printf("请确认密码(Y/N):\n");
//	ch = getchar();//此处采用scanf()读取同样会出错，原因如上；
//	if (ch == 'Y')
//		printf("确认成功\n");
//	else
//		printf("确认失败\n");
//	return 0;
//}
//修改后:(利用getchar来清空缓冲区)
//int main()
//{
//	char password[20] = { 0 };
//	int ch = 0;
//	printf("请输入密码:\n");
//	scanf("%s", password);//此处之所以不用&，是因为数组本身就是地址
//	while (getchar() != '\n')//此处用循环getchar()清空而不是单个getchar()是为了以防在输入的密码中间有空格或者制表符存在的情况
//	{
//		;			// !=需连写，用于判断等式两边是否不相等
//	}
//	//事实上，scanf也能跳过空格和制表符等继续读取，只需要使用前导空格字符 即scanf(" %s",password);但是这种方式还是会导致缓冲区仍有余留
//	printf("请确认密码(Y/N):\n");
//	ch = getchar();
//	if (ch == 'Y')
//		printf("确认成功\n");
//	else
//		printf("确认失败\n");
//
//	return 0;
//}


//int main()
//{
//	int ch = '\0';//初始化为0也可以，因为'\0'的ascii码值就是0；
//	while ((ch = getchar()) != EOF)//注意，虽然getchar每次仅读取一个字符，但放入循环后便会一直读取,直到读取到\n换行继续等待下一次输入
//	{
//		if (ch < '0' || ch>'9')//此处意为当ch中字符对应的ascii码值 <0或者>9的ascii码值时将跳过此次打印，不会打印出来
//			continue;
//		putchar(ch);
//	}//这段代码的作用便是只打印数字字符，跳过其他字符的打印
//	//注意，含有getchar()的循环(其实是通用的方法...)如何让程序停止？ctrl+c(推荐)或ctrl+z+enter  而shift+esc可关闭过程窗;
//	return 0;
//}


//for循环：
//其实我们不难发现，while循环的主体就是三个部分
//int main()
//{
//	int i = 1;//这是对循环参量的初始化部分
//	while (i<=10)//这是循环的条件判断部分
//	{
//		printf("%d\n", i);
//		i++;//这是循环的调整部分
//	}
//	return 0;
//}//这三个部分其实就是while循环的主体，任意一个部分的改变都可能导致完全不同的循环
//可是这三个主体过于分散 不利于可能的修改 由此 我们开始for循环的新大门
//for语句:
//for (size_t i = 0; i < length; i++)//注意 各部分之间用;分隔开
//{
	//由这个for范例可以看出，for括号内其实就是三个主体部分 size_t是变量类型 i=...是初始化值 i<...是条件判断 i++为调整部分
//}
//接下来使用for来实现上一个程序
//int main()
//{
//	for (int i = 1; i <=10; i++)//肉眼可见地利于修改了
//	{
//		printf("%d\n", i);
//	}
//	//printf("%d\n", i);	注意 将打印语句放在for循环之外时 i便是一个未定义的标识符，可见由for循环定义的变量只能在for之内用
//	return 0;
//}//当然，for循环中同样有break and continue并且效果一致
	//但是for中continue满足时并不会跳过后面的调整部分，这与while中不同(while中会跳过i++从而陷入死循环)
//for循环的使用建议:
//1_不要在for循环体内修改变量，以防for循环失去控制；
//2_建议for语句的循环控制变量的取值采用[ )前闭区间后开区间的写法; i<=9是闭区间写法，而i<10则是开区间写法，这样的代码可读性更高
//3_注意，for循环中初始定义的变量的作用域仅限于for循环以内，当走出for之后，编译器便不再认for以内的任何变量值


//for循环的一些变种:
//int main()
//{
//	for  (; ;)//for循环中的三个部分均可以省略，但是不建议初学者这样操作，容易出错;
//	{
//		printf("hehe\n");//这里陷入了死循环;因为判断部分省略了之后这个判断就会恒成立，循环也就会一直进行;
//	}
//	return 0;
//}
//接下来是一个常见的错误引例:
//int main()//不省略
//{
//	int i = 0;
//	int j = 0;
//	for (int i = 0; i < 10; i++)
//	{
//		for (int j = 0; j < 10; j++)
//		{
//			printf("hehe\n");//此时打印了100个hehe 这是因为嵌套for循环的原则是先内后外 只有当内层循环完了之后外层才继续下一次循环
//		}//内层循环完打印十遍hehe，而外层要循环十次，外层嵌套的内层也就要跟着循环十次，故10*10=100;
//	}
//	return 0;
//}

//int main()//省略
//{
//	int i = 0;
//	int j = 0;
//	for (;i< 10;i++)
//	{
//		for (;j< 10;j++)
//		{
//			printf("hehe\n");//结果是打印了十个hehe;为什么呢?
//		}//这是因为对于j而言当j等于10第一次跳出循环时，后续再进入到这个循环时因为j没有初始化为0，所以j依然等于10导致
//	}//也就是说外层循环依然循环了10次，但是内层循环实际上只循环了第一次，后续几次根本没有进入内层循环
//	return 0;
//}
//提醒! for(int a=0;a<10;a++)中int a=0的写法是C99标准之后才支持的，一些较古早的编译器可能只支持for(a=0;a<10;a++)这种写法;

//事实上，可以使用多个变量来控制循环:
//int main()
//{
//	for (int x = 0,y=5; x < 3 && y>4; x++,y++)//这里便同时使用了两种变量来控制循环的开始与结束;
//	{
//		printf("hehe\n");
//	}
//
//	return 0;
//}

//int main()
//{
//	int i = 0;
//	int j = 0;
//	for (int i = 0,j=0; j=0; i++,j++)//请仔细观察！
//	{
//		printf("hehe\n");//为什么循环0次？ 因为判断条件为j=0;意为将0赋给j;0为假 故判断结果是不进入循环;
//	}
//
//	return 0;
//}

//do while循环:
//形如 :
//do
//	循环语句
//while(表达式)
//可见do while循环的特点是 至少先完成一次循环，然后再判断是否进行下一次循环;
//int main()
//{
//	int i = 1;
//	do
//	{
//		printf("%d\n", i);
//		i++;//注意 和while for 一样，若想要在循环中执行多条操作语句，需要用{}括起来;否则程序运行错误或者死循环！
//	}
//	while (i < 11);
//	return 0;
//}
//int main()
//{
//	int i = 0;
//	do
//	{
//		if (4==i)
//		{
//			//break;
//			continue;
//		}
//		printf("%d\n", i);
//		i++;
//	} while (i<10);//0 1 2 3后接空白死循环
//	//在do while语句中，break and continue和在while语句中具有相同效力
//	while (i < 11)
//	{
//		if (4 == i)
//		{
//			continue;
//		}
//		printf("%d\n", i);
//		i++;
//	}//0 1 2 3后接空白死循环
//	//这两者死循环的都因为后置i++，导致i一直等于4，然后一直被跳过...
//	for (int i = 0; i < 11; i++)
//	{
//		if (4==i)
//		{
//			continue;
//		}
//		printf("%d\n", i);
//	}
//	//在这三种写法中，仅有for循环成功达到了预期
//	//这也是为什么 在平时使用时最常用的便是for循环 提高容错 而且书写更方便;
//	return 0;
//}

//运用循环:
//计算阶乘 考虑递归或者循环;
//int main()
//{
//	int n= 0;
//	int t = 1;
//	scanf("%d", &n);
//	for (int i = 1/*i为1或者2均可*/; i <= n; i++)
//	{
//		t = i * t;//这里的t初始化必须均为1，这样1*i才会等于i本身, t的意义就是存储乘积并且迭代;
//	}
//	printf("%d\n", t);
//	return 0;
//}//这种方法不能实现大数运算，因为会溢出，只有模拟实现大数运算，才能解决内存溢出问题;

//计算阶乘之和;
//int main()
//{
//	int n = 0;
//	int t = 1;
//	int s = 0;
//	scanf("%d", &n);
//	for (int i = 1; i <=n; i++)
//	{
//		t = t * i;
//		s = s + t;
//		//需要注意 for循环中定义的变量是有其作用域的 当内外同时定义了一个变量时 一旦离开for 变量值就回归外部定义值了
//	}
//	printf("%d\n", s);//而s之所以能出for而且值为循环后的结果 是因为s不是for循环定义的变量 只是经过了循环
//	return 0;
//}
//另一种写法;
//int main()
//{
//	int n = 0;
//	int i = 1;
//	int sum = 0;
//	//这里可以再定义一个变量，就可以将这个程序改写为输入决定输出型;
//	for (int n = 1; n<=3 ; n++)
//	{
//		int p = 1;//此处添加上初始化;
//		for (int i = 1; i <=n; i++)
//		{
//			p *= i;//打印结果为15 原因是此处p没有在外层循环被初始化，导致内层循环计算单个阶乘时出错(p值一直叠加)
//		}
//		sum += p;
//	}
//	printf("%d\n", sum);//添加初始化后打印结果为9;
//	return 0;
//	//需要注意的是，这种嵌套for的写法时间和空间复杂度都提高了，因为每次计算一个阶乘后下一个都要从头开始，很浪费资源
//	//当我们采用上一个写法时，新阶乘只需要在前一个基础上*i就可以了，而原阶乘又可以直接拿去相加，节省了时间和空间
//}

//关于调试(Debug)
//需要知道，VS并不只是一个编译器，而是一个IDE，其中当然也包含了调试器
//在上方 项目 的下面可以看到Debug，这表示当前是调试版本，里面包含调试信息，程序员可以在里面进行各种调试，而后者则不能调试;
//而点击后可以选择为Release，也就是发布版本，这往往是进行了各种优化使得程序在代码大小和运行速度上都是最优解的，是利于发布和用户使用的版本
//常用的调试是 点按F10/F11 程序会自动按照流程走 F10与F11的区别在于后者可以帮助我们进入函数内部而前者会跳过函数代码块
//因此常用F11 点按后程序的执行情况便一句一句清晰可见 通常还需要用到监视窗口以看到变量值的变化，或者查看内存的地址变化等等
//还有的调试是F9(设置断点)+F5(执行调试)，不过这需要鼠标点按 故较少用
//年轻人，多做调试吧，提高自己的纠错能力，这也是代码水平的一部分！


//在一个有序数组中查找某个数n:
//int main()
//{
//	int i = 0;
//	int arr[] = { 1,2,3,4,5,6,7,8 };
//	int sz = sizeof(arr) / sizeof(arr[0]);
//	int k = 35;
//	for (int i = 0; i <=sz; i++)
//	{
//		if (arr[i]==k)
//		{
//			printf("找到了\n%d\n", arr[i]);
//			break;
//		}
//		if (i == sz)
//		{
//			printf("没找到\n");
//		}
//	}
//	return 0;
//}//这种低级算法好处是哪怕数组内部是无序的也同样可以使用,但是这本身比较浪费有序数组的条件
//接下来我们来讲二分查找:
//何为二分查找?
//经典猜数字:
//1到100请猜一个数，如何才能更快? 
//50 大/小 25/75 大/小 ...
//上述就是二分查找 这带来的是肉眼可见的速度提升，相较于枚举而言;下面我们来学习一下其代码表示;
//仍然用于在一个有序数组中查找某个数;
//int main()
//{
//	int arr[] = { 1,2,3,4,5,6,7,8,9 };
//	int sz = sizeof(arr) / sizeof(arr[0]);
//	int k = 0;
//	scanf("%d", &k);//k为欲查找数
//	int left = 0;//意为左逼近
//	int right = sz - 1;//意为右逼近，sz-1是因为当有sz个数时尾数的下标为sz-1
//	while (left<=right)
//	{
//		//int mid = (left + right) / 2;//如若担心mid的值越界(整型范围)，可改写为:
//		int mid = left + (right - left) / 2;//这种写法下允许了更大值和左右均遇到奇数时的查找,虽然仍然有越界可能;
//		if (arr[mid]<k)
//		{
//			left = mid + 1;//此处为何一定要+1?
//		}
//		else if (arr[mid]>k)
//		{
//			right = mid - 1;//此处为何一定要-1?
//		}
//		else
//		{
//			printf("找到了\n下标是%d\n", mid);
//			break;
//		}
//	}//若上面的循环中left right不加减1则当出现.5时，系统会保留为整数，当遇到边界值时,left/right会一直被赋为同一个值 导致死循环
//	if (left>right)//若不加减1 也同样无法出现left>right的情况 只能是陷入相等的死循环
//	{
//		printf("找不到匹配项\n");
//	}
//	return 0;
//}

//试着打印一个字符从两端到中间逐渐显现出的效果
//#include<windows.h>//这里为了展示渐进效果，需要使用sleep函数，而sleep需要从这个头文件蕴含的库函数中调用;
//#include<stdlib.h>//这里为了实现每次渐进仅展示一行的效果调用了系统命令 system("cls") 而调用system这个库函数需要包含这个头文件
//int main()
//{
//	char arr1[] = "Welcome to code world!!!";//arr1是欲显现的字符数组;
//	char arr2[] = "########################";//arr2是显现过程即开始过程挡住的字符数组(即渐进效果)
//	int left = 0;
//	int right = strlen(arr2 - 1);//用arr2/1均可，因为上下长度一致，strlen计算字符串长度会包含字符串中间的空格 -1是因为right是下标
//	//int right = sizeof(arr2 - 2);//此处-2是因为sizeof包含了"\0"故而计算出的个数会多一个;
//	while (left<=right)
//	{
//		arr2[left] = arr1[left];
//		arr2[right] = arr1[right];
//		printf("%s\n", arr2);
//			Sleep(1000);//Sleep 意为休眠多久多久，括号内的数字为多少分之一秒 此处为千分之一秒;S要大写 注意
//			system("cls");//system是一个库函数，可以执行系统命令 表示 clear screen 清屏
//		left++;
//		right--;
//	}
//	printf("%s\n", arr2);//这里是为了在while最后一次打印后不清屏而不得不添加的补充打印 目的仅仅是为了打印最后一次
//	return 0;
//}

//接下来试试 设计一个程序，使得用户可以输入密码并实现验证(<=3次) 假定密码为 abc123;
//#include<string.h>//本程序用到了 strcmp 调用此函数需要调用该头文件 考虑到此源文件开头已经包含了此头文件 此处便不再赘述;
//int main()
//{
//	int i = 0;
//	char password[20] = { 0 };//初始化一个字符数组 注意要确定字符数目的上限 否则程序不会正常结束;
//	printf("请输入密码\n");
//	for (i=0 ; i < 3; i++)//此处for不使用int i =0;
//	{
//		//这是因为一旦一个变量在for之中被声明 那么该变量的作用域将限制于for内 意为:这是一个在for循环内新创建的一个局部变量
//		//哪怕在外界已经声明了一个重名变量 当离开for时，该变量的值会立刻回归到外界声明的值;
//		//而外界声明了但for内不声明的变量的值便是可以带出for循环的了 此处便是为了带出i的值以使当三次输入错误时 最后的if语句能正常实现
//		scanf("%s", password);
//		if (strcmp(password,"abc123") == 0)//strcmp 意为string compare 用于字符间的比较 实质是比较ASCII码值之和
//		{
//			printf("密码正确\n");
//			break;//若无此跳出 则会陷入死循环
//		}// 当括号内前者大于后者时 strcmp返回一个正值 反之则返回一个负值(多数编译器对应返回的就是1和-1) 相等时则返回0;
//		else
//		{
//			printf("密码错误\n");
//		}
//		
//	}
//	if (3==i)
//	{
//		printf("三次密码均输入错误 请明天再试!\n");
//	}
//	return 0;
//}


//猜数字游戏
//思路:
//1 电脑随机生成一个数;
//2 玩家来猜一个数;
//3 电脑给出大/小/猜对;
//4 玩完后返回菜单页面,等候下一次选择;

//设计菜单页面:
//void menu()
//{
//	printf("####################\n");
//	printf("###请选择是否游玩###\n");
//	printf("#####  1 游玩  #####\n");
//	printf("#####  0 退出  #####\n");
//}

//设计游戏主体部分:
//void Game()
//{
////	printf("%d\n", rand());//srand是随机数发生器的初始化函数 和rand函数均被放于<stdilb.h>这个头文件中 故使用时需引入该头文件
////	printf("%d\n", rand());//原型: void srand (unsigned int seed) seed相当于一个种子 srand函数根据这个seed设置一个随机起点
////	printf("%d\n", rand());//而rand函数根据这个随机起点 返回一个随机数 范围是0~0x7ffff(32767) 注意 除非给一个变化的种子
////	printf("%d\n", rand());//否则这个随机数就是伪的随机数(多次编译时产生的随机数是一样的)
//	srand(1);//值得注意 rand函数每一次调用时都会查看之前是否调用了srand函数 若调用了 则rand函数会调用srand(seed)来初始化它的随机值
//	printf("%d\n", rand());//若之前没有调用srand 则会默认调用srand(1)来初始化它的随机值
//	printf("%d\n", rand());
//	printf("%d\n", rand());
//	srand(2);
//	printf("%d\n", rand());
//	printf("%d\n", rand());
//	printf("%d\n", rand());
//	srand(3);
//	printf("%d\n", rand());
//	printf("%d\n", rand());
//	printf("%d\n", rand());//由这三次结果可知 当每次输入不同的种子时 产生的每组随机数都是不一样的
//	//那么 接下来问题就变成了如何让srand(seed)中存在一个变化的种子
//}
//接下来介绍时间戳:
//time函数包含于<time.h>这个头文件中
//time函数可以获取当前的系统时间:是指从1970年1月1日零时零分到目前为止所经过时间的秒数累计 也即 时间戳
//可见时间戳就是一个一直都在变化的量
//time_t time(time_t*t); 这是time函数的形式 对于64位处理器 time_t是long int 或者 long long int类型
//该函数提供两种返回方式 返回值或者返回指针参数 当参数为空指针(NULL)时只返回值 而NULL的定义是(void*)0 可见time(NULL)和time(0)是等效的
//看来我们需要使用这个time(NULL) 但是srand()中的种子seed要求是unsigned int 类型 故我们还需要强制类型转换
//即 srand((unsigned int)time(NULL)) 这样便得到了一个变化的种子 接下来我们再来写一下游戏的主体部分试试
//void Game()
//{
//	int guess = 0;//guess用于放置玩家猜的值
//	int ran = rand()%100 + 1;//rand()%100表示的值将不会超过100(取模运算);即0~99 而+1后得到的范围就是1~100之间 范围更加合理了
//	int count = 0;//count用于记录猜的次数;
//	while (1)
//	{
//		printf("请输入数字\n");
//		scanf("%d", &guess);
//		if (guess<ran)
//		{
//			printf("你猜小了 笨蛋\n");
//		}
//		else if (guess>ran)
//		{
//			printf("你猜大了 傻卵\n");
//		}
//		else
//		{
//			printf("恭喜！ 你猜对了！\n共计猜了%d次\n",count+1);
//			break;
//		}
//		count++;
//	}
//}

//int main()
//{
//	int input = 0;
//	srand((unsigned int)time(NULL));
//	//将srand置于这里是因为整个工程中只需要设置一次随机生成数的起点就可以了 并非每次生成随机数都需要设置一次起点
//	//如果是后者 也就是说将这个srand置于Game函数中的话 将导致一旦生成随机数过快(相差不超过1s) 将生成同一个随机数 这是不可取的
//	do
//	{
//		menu();
//		scanf("%d", &input);
//		switch (input)
//		{
//		case 1:
//			Game();
//			break;
//		case 0:
//			printf("退出游戏\n");
//			break;
//		default:
//			printf("输入错误，请重新输入!\n");
//			break;
//		}
//	} while (input);//此处通过输入input的值来判断是否进入下一次循环 准确来说是输入值也就是真假值(0/1/其他) 这个设计很巧妙
//
//	return 0;
//}


//goto 语句 即瞬时跳转语句;
//C语言提供了可以滥用的goto语句和标记跳转的标号;
//但是从理论上来说 goto语句是没有太大实际意义的 因为没有它我们也能轻易写出代码来
//它的两个缺点:
//1_由于goto语句的随意性 导致它可能让整个程序的执行顺序变得混乱 这可能导致更多的bug出现 威胁程序的安全
//2_goto语句无法跳转到单独的函数代码块中 也就是说跳转的位置是受限的
//它的优点:
//goto语句最常用的就是用于跳出深度嵌套结构 比如多重循环 这是break难以达到的效果 因为它只能跳转到上一层循环 但goto却可以跳出整体
//这是一个goto语句的示例:
//int main()
//{
//	char input[20] = { 0 };
//	system("shutdown -s -t 60");//shutdown -s:关机指令 -t:设置关机指令(需要设置时间) 60则是设置的时间
//again:
//	printf("请注意！你的电脑即将在60秒后关机\n若输入:我是猪\n即可取消关机\n");
//	scanf("%s", input);
//	if (strcmp(input,"我是猪")==0)
//	{
//		system("shutdown -a");//-a 表示 -annul 即取消指令
//		printf("已取消关机:>\n");
//	}
//	else
//	{
//		goto again;
//	}
//	return 0;
//}//不难发现 这段代码也可以使用循环来写 也就是用循环主体替换again后面的内容即可


//函数:
//在C语言中函数的定义与数学中略有不同
//在C语言中 
//函数是一个子程序，是一个大型程序的某部分代码，由一个或多个语句块组成，负责完成某项特殊的任务，具有一定的独立性;
//特征:一般会有输入参数并有返回值，提供对过程的封装和细节的隐藏，这些代码通常被集成为软件库。
//分类：1_库函数 2_自定义函数
//为什么会有库函数?
//库函数是C语言后续发展来的 可以提高写代码的效率和代码的标准化程度 还可以降低出现bug的可能;
//在www.cplusplus.com中可以查看库函数列表
//通过这个网站我们可以很迅速地学习到各类库函数的用法
//简单总结一下，C语言常用的库函数有:
//IO函数
//字符串操作函数
//字符操作函数
//内存操作函数
//时间/日期函数
//数学函数
//其他
//当然，请注意使用这些库函数时必须要包含能调用这些库函数的头文件
//自定义函数也由以下几个部分组成：
//ret_type_(返回值类型...可以是void 即不返回) fun_name(函数名)(paral,*参数 参数最好写上类型！)
//{
	//statement;//语句项
//}//{}括起来的内容是自定义函数的主体部分 也即函数的实现
//需要知道 主体程序传递给函数的参数是实参 而函数名括号内的变量是形参 形参是实参的一份临时拷贝
//所以当自定义函数无返回值时 函数部分对形参的修改不会影响实参
//但是请注意 如果主程序传递到函数的是变量的地址 那么此时改动形参和改动实参的效果就可能是一样的
//因为当用一个指针变量来存放这个传递过来的地址后 一旦对这个这个指针进行解引用 那么此时就可以通过这个指针指向的地址直接对原变量(实参)进行修改
//所以 当我们需要函数对实参进行修改时 就可以传递实参对应的地址 反之则正常使用形参来进行函数操作就可以了
//这里其实也涉及到两种函数调用方式 1 传值调用(后者); 2 传址调用(前者)
//关于实参:
//实参是真实传递给函数的参数 实参可以是常量 变量 表达式 函数等 在进行函数调用时 实参必须要有确定的值 以便把这些值传递给形参
//关于形参:
//形参是指函数名括号中的变量 形参只有在函数被调用的过程中才实例化(分配内存单元) 并且形参在函数被调用完后会自动销毁 故形参只在函数调用的过程中存在
//形参和实参的命名可以相同 也可以不同 这两者的作用域不同 所以无论是否重名都不会互相影响 形参只是实参的临时拷贝

//求100~200之间的素数?(素数指仅能被1和自己整除的数 也就是说2到该数之间没有数可以整除该数)
//int main()
//{
//	int i = 0;//用i表示100~200之间的数
//	int count = 0;//count用于计算素数的个数
//	//for (i = 100; i <= 200; i++)//容易知道 当i>2后的素数必然是奇数 所以我们可以就此从源头上减小计算复杂度
//	for (i = 101; i <= 200; i += 2)
//	{
//			int t = 1;//用t的值来得知该数是否是素数
//			//for (int j = 2; j < i-1; j++)//思考 这里是否也可以简化?是否一定要用2到i-1之间每一个数去除试试?``````答案是否定的！
//			//由数学知识可知 其实我们只需要试到根号下i就可以了 因为根号i已经是除i以外最大的一个因数了
//			//所以我们稍作优化 降低其时间上的损耗;
//			for (int j = 2; j <= sqrt(i); j++)//sqrt 是开方函数 调用该函数需要包含<math.h>这个头文件
//			{
//				int z = i % j;
//				if (0 == z)
//				{
//					t = 0;//t为0则说明该数不是素数
//				}
//			}
//			if (1 == t)
//			{
//				printf("%d ", i);
//				count++;
//			}
//	}
//	printf("\ncount= %d\n", count);
//	return 0;
//}
//接下来我们来看看如何用函数表示
//int ion_prime(int n)//注意函数的命名 ion means is or not 而prime number意为素数 这里简写prime
//{
//	for (int j = 2; j <= sqrt(n); j++)
//	{
//		if (0 == n % j)
//		{
//			return 0;
//		}
//		//else
//		//{
//		//	return 1;
//		////为什么这种写法是错误的?  因为将return 1放入for内的话 这个for并未循环到sqrt(n)为止而是第一次循环就返回1 跳出了函数体
//		//}
//		//else if (1== n % j)
//		//{
//		//	return 1;
//		////不难发现 这种写法也是错误的 因为函数也会在第一次循环时提前结束
//		//}
//	}
//	return 1;//因此 我们直接将返回1放在for循环之外 让for循环完成之后再返回 真
//}
//int main()
//{
//	int i = 0;
//	int count = 0;
//	for (i = 101; i <= 200; i += 2)
//	{
//		if (ion_prime(i))//此处直接用函数返回值来进行真假判断 这是常见技巧
//		{
//			printf("%d ", i);
//			count++;
//		}
//		
//	}
//	printf("\ncount= %d\n", count);
//	return 0;
//}

//写一个函数 判断公元0到2000年之间有多少闰年
//首先我们需要知道 判断闰年有两个判断条件
//1_这个年份可以被4整除 但不可以被一百整除
//2_这个年份如果被400整除 那么这一年也是闰年
//由此 我们可以先写出一个不用函数的写法
//int main()
//{
//	int i = 0;//i表示年份
//	int count = 0;//count表示出现闰年的个数
//	for ( i = 0; i <= 2000; i++)
//	{
//		//if (0 == i%4)
//		//{
//		//	if (0 != i%100)
//		//	{
//		//		printf("%d ", i);
//		//		count++;
//		//	}
//		//}
//		//else if (0 == i%400)
//		//{
//		//	printf("%d ", i);
//		//	count++;//不难发现 这种写法下 满足规则2的闰年其实并没有被打印下来 因为此处的第一二中情况并不是并列关系 换成else也不行
//		//}
//		//if (0 == i%400)//只有这种写法才是并列关系的if 也才能使两条规则同时满足
//		//{
//		//		printf("%d ", i);
//		//	count++;
//		//}
//		//其实这里的两条规则都是 并且 并列 关系的组合 因此我们还可以换种写法 更为简洁
//		if (((0 == i%4)&&(0! = i%100))||(0 == i%400))
//		{
//			printf("%d ", i);
//			count++;
//		}
//	}
//	printf("\ncount=%d\n", count);
//	return 0;
//}
//接下来试试函数的写法
//int ion_leap_year(int year)//leap year是闰年的意思
//{
//	if (((0 == year%4)&&(0 != year%100))||(0 == year%400))
//	{
//		return 1;
//	}
//	else
//	{
//		return 0;
//	}
//	//为什么不在函数内同时完成year的判断和打印？
//	//因为这将导致函数的二功能不够单一
//	//函数的功能越单一 使用时也就越自由 越不用顾虑 在程序封装之后也更好使用
//	//关于函数自定义的一个口诀:高内聚(内部功能完整凝练)	  低耦合(与程序的其他部分关联度要小)
//}
//int main()
//{
//	int i = 0;
//	int count = 0;
//	for ( i = 0; i <= 2000; i++)
//	{
//		if (ion_leap_year(i))
//		{
//			printf("%d ", i);
//			count++;
//		}
//		else
//		{
//			continue;
//		}
//	}
//	printf("\ncount=%d", count);
//	return 0;
//}

//写一个函数 实现整型有序数组的二分查找
//int search(int *arr, int k,int sz)//这里可以直接用指针变量*arr接受 因为数组名就是一个地址(数组的传递是以数组中的首地址来进行传递的)
//{
//	//如果上方采用(int arr[],int k,int sz)的形式其实也是一样的 arr[]看起来是个数组 但里面放的也是指针 因为数组传递过来的就是首地址
//	//但是无论怎样写 sz的值都不能放在函数中进行计算 为什么呢?
//	//这是因为 传递过来的是数组的首地址 那么sizeof(arr)就是arr[]中首位元素所占的内存大小(int 类型占4)也即是sizeof(arr[0])
//	//那么如果sz让这两者相除 结果必然恒为1 left和right也就直接相等了 这显然是不合理的
//	//由此得出/！	我们无法在函数内部去计算一个函数参数部分中数组的大小或者元素个数！
//	int left = 0;
//	int right = sz - 1;
//	while (left <= right)
//	{
//
//		int mid = left + (right - left) / 2;//注意 该语句必须放在循环以内 否则mid就只会赋一次值 后续程序由于arr[mid]不变将陷入死循环
//		if (arr[mid] < k)
//		{
//			left = mid + 1;
//		}
//		else if (arr[mid] > k)
//		{
//			right = mid - 1;
//		}
//		else
//		{
//			return mid;
//			//下面之所以直接接return -1而不是再用一个if(left>right)是因为return优先级远高于break(只能跳出循环)
//			//如果条件满足 那么return在此处就可以直接终止函数(这也是为何此处不用接break)
//		}
//	}
//	return -1;//return -1是因为要做区别 -1绝不可能是返回的下标 但是0却可能是返回的下标
//}
//int main()
//{
//	int arr[] = {1,2,3,4,5,6,7,8,9,10};
//	int k = 0;
//	int sz = sizeof(arr) / sizeof(arr[0]);
//	scanf("%d", &k);//k为欲查找的数 显然k<=10;
//	if (search(arr , k , sz) != -1)//注意 当主体程序传过去数组时 无论哪种传递方式都只能在主程序这边写数组名 不能写arr[]
//	{
//		printf("找到了 下标是：%d\n", search(arr , k , sz));
//	}
//	if (search(arr , k , sz) == -1)
//	{
//		printf("找不到对应下标\n");
//	}
//	return 0;
//}

//有时 真假值的返回也可以采用布尔类型(需引入头文件<stdbool.h>)	例如：
//bool ion_even(int x)//这个函数用于判断是否是偶数(even number)，奇数的英文(odd number)
//{
//	if (0 == x%2)
//	{
//		return true;//也就是 1
//	}
//	return false;//也就是0
//}
////bool类型的返回值只有 true/false两种 这也使得相较于传统的1/0返回值 它显得更美观直接 同时减少了bug出现的可能(有时1/0不好用于返回真假值)
////但是因为它是C99标准之后的产物 同时功用有替代品 所以使用较少 但是若要提升代码可读性 也可以使用bool类型来代替传统的1/0返回真假值
//int main()
//{
//	int i = 0;
//	for ( i = 1; i < 10; i++)
//	{
//		if (ion_even(i))//此处根据布尔类型调用函数的返回值来作为判断依据
//		{
//			printf("%d ", i);
//		}
//	}
//	return 0;
//}

//写一个函数 每调用一次函数 num的值就+1
//第一种写法 传址调用
//int num_(int* p)
//{
//	(*p)++;//注意此处*p必须加括号 否则调用顺序会出错
//}
//int main()
//{
//	int num = 0;
//	num_(&num);//每调用一次 num_ num的值就会直接加一
//	printf("%d\n", num);
//	return 0;
//}
//第二种写法 传值调用
//int num_(int n)
//{
//	return ++n;
//}
//int main()
//{
//	int num = 0;
//	num=num_(num);//这种写法就是通过在函数中来进行++的操作后返回值又放到num中来实现要求的
//	printf("%d\n", num);
//	return 0;
//}

//函数的嵌套调用
//函数是允许互相调用的 但是不允许嵌套定义
//int ad(int x)
//{
//	return ++x;
//}
//int zs(int n)
//{
//	return ad(n);//这便是函数的嵌套调用 每一层函数之间依然是平等关系
//}
//int main()
//{
//	int i = 0;
//	zs(i);
//	printf("%d\n", zs(i));
//	return 0;
//}
//int add(int x, int y)
//{
//	return x + y;
//}
//int sub(int x, int y)
//{
//	return x - y;
//}
//接下来来看一种错误写法
//int add(int x, int y)
//{
//	return x + y;
//	int sub(int x, int y)//这种写法就是错误的了 因为函数不可以嵌套定义:一个函数中不能再去定义另外一个函数
//	{
//		return x - y;
//	}
//	//如果要实现函数的嵌套调用 至少对函数要先定义 再嵌套调用
//}
//int main()
//{
//	int x, y = 0;
//	scanf("%d %d", &x, &y);
//	printf("两数之和是 %d\n", add(x, y));//注意加减乘除的命名 加 addition 减 subtract 乘 multiply 除 divide
//	printf("两数之差是 %d\n", sub(x, y));
//	return 0;
//}

//函数的链式访问 (实现依赖于函数的返回值)
//链式访问 意为用前一个函数的返回值作为后一个函数的参数
//接下来看一个经典的链式访问
//int main()
//{
//	int i = 43;
//	printf("%d", printf("%d", printf("%d", i)));
//	//猜猜打印结果？
//	//为什么打印结果为4321？
//	//需要知道 printf函数的返回值是 打印字符的数目
//	//根据链式访问原理 最内层的printf返回值--打印字符(43)的数目--2 作为中间printf返回值--打印字符(2)的数目--1 又作为最外层printf打印值
//	//由此 得到了43 2 1的数据
//	return 0;
//}
//注意 当函数不写返回类型时 系统默认返回int型 但这是很不规范的代码 
//同样也不要有返回类型的函数结果不返回值(此时大部分编译器会默认返回函数中最后一条指令执行的结果) 这些都是不规范的代码写法
//注意一下的写法
//int main(void)//这里的void写法并没有错 只是想明确说明 main函数不需要参数 以避免有些ide错误地给main放置了参数
//	//事实上 main有三种参数: int argc,char *argv[],char *envp[] 这三种参数都有实际意义 只不过一般情况下编译器默认main是不需要参数的
//	//但是这种被默认的执行程度会稍弱于明确强调void 只是说在大多数情况下我们无需担心这一点 所以可以直接省略void
//{
//	printf("hehe\n");
//}

//函数的声明和定义：
//函数声明就是告诉编译器有一个什么样的函数是长什么样的 但是这个函数是否真的存在 函数声明决定不了(需要函数的定义)
//并且函数的声明一般出现在函数的使用之前 要满足先声明后使用 如果将函数声明放在使用后面 编译器就会报一个警告"函数...未定义..."(能运行但是)
//函数的声明和函数的主体可以分开
//比如 可以先在主函数之前写 int ion_prime(int x) 但是函数主体可以放在主函数之后写
//函数的声明一般要放在头文件中的
//函数的定义是指函数的具体实现，交代函数的功能实现
//我们知道
//int ion_prime(int x);//这是函数的声明
//接下来这一块是函数体 函数体和函数所声明的部分的组合才是函数的完整定义
//{
//	for (int i = 2; i < sqrt(x); i+=2)
//	{
//		if (0 == x%i)
//		{
//			return 1;
//		}
//	}
//	return 0;
//}
//接下来具体阐述为什么说函数的声明一般要放在头文件中
//总结起来就是：
//1_为了模块化和可维护性： 
//将函数声明放在头文件中可以帮助代码模块化，使代码更易于维护。通过在头文件中声明函数，可以清晰地了解库或模块提供了哪些功能，以及如何使用它们。
//2_为了避免重复定义：
//如果不使用头文件，当在多个源文件中引用相同的函数时，每个文件都会包含相同的函数声明，这可能导致重复定义错误。使用头文件可避免这种情况，因为源文件只需要包含一次头文件即可。
//3_为了便于扩展： 
//如果要更新函数原型，只需更新一次头文件，所有引用该函数的源文件都会受益于更新，而无需逐个修改。
//事实上 当我们进行真正的程序开发时
//为了更好地进行团队协作以及实现模块化开发 我们往往是将一个程序分为多个源文件同时进行开发的 在最后才实现程序的整体封装
//而这时如果我们要自定义一个函数 我们常常将这个函数的声明放到一个头文件中去 然后再将函数的定义部分放到另外一个源文件中去
//只要我们需要调用这个函数 我们就只需要写下	例如#include"ion_prime.h"	这个程序就会根据这个引用头文件中的声明找到对应函数的定义
//然后对这个函数进行实现
//意义?
//这里简单介绍一种情况下将自定义函数的声明和定义分开放在不同文件的意义
//当程序员A写了一个APP时 他想将该APP卖给B公司赚钱 但是他又不能直接将源码一股脑都交给B公司(可能代码被对方骗到手后就翻脸不认人了)
//于是他可以选择将自定义函数的声明放在一个头文件中 再将定义放在另一个源文件中 含有主体程序的源文件就不涉及到该函数定义部分了
//然后将含有函数定义的项目fun(含fun.h)编译成静态库fun-->fun.lib 静态库中都是二进制编码 很难轻易被反编码为原先的代码
//这时他再将该静态库和对应的fun.h以及主体源文件一同卖给B公司即可 B公司通过fun.h(函数声明)就可以了解到该函数是如何使用的
//然后B公司再在主源文件中导入静态库: #pragma comment(lib,"fun.lib")  后就可以正常使用该程序中的函数了(虽然他无法得知函数具体是如何实现的)
//可以看到这种处理方法 极大地保护了代码的安全 同时满足了代码对于迁移使用的需要


//！！！ 函数的递归
//递归是程序调用自身的编程技巧 只需要少量的代码就能描述出多次重复的计算 递归的主要思考方式就是：大事化小
//实现递归的两个条件
//1_存在限制条件 当满足限制条件后 递归函数就不再继续
//2_每一次递归调用之后都会越来越接近这个限制条件
//引入... 请写出一段代码 使得它能接受一个整型值(无符号),并按照顺序打印它的每一位 如输入1234 打印 1 2 3 4
//int main()
//{
//	//unsigned int a1,a2,a3,a4= 0;
//	//scanf("%1u %1u %1u %1u", &a1, &a2, &a3, &a4);//输入 1234		//%1u表示每次只读入一位数据并依次存储到对应的变量中去
//	//printf("%u %u %u %u\n", a1, a2, a3, a4);//打印1 2 3 4
//	//这是由前面的关于打印格式的知识所知的 但很显然 当输入123时这段代码便不能正常运行了 
//	//于是我们想到了取模运算
//	unsigned int a = 0;
//	scanf("%u", &a);
//	while (a)//通过a的值来作为判断依据 最后a=0则跳出循环
//	{
//		printf("%d ", a % 10);//通过取模运算 得到每个数的尾数
//		a = a / 10;//再通过除法运算(整数除法 最后得到的数必是0) 将每次除后的整数部分赋给a(其实也就是a的前几位)
//	}//但是这样打印的结果是倒过来的:< 咋办捏
//	//简单粗暴的思路:把每次取模得到的值放到另一个创建的数组中去 然后再从末尾往前用一个for打印(每次i--)即可
//}

//下面这种对于取模的妙用也是可以实现的 别称 首位剥离法 而上面的思路是末尾剥离法 这两种是常见的对于取模的化用 合成首尾剥离法
//int main()
//{
//	unsigned int num = 0;
//	scanf("%u", &num);
//	int temp = num; //temp用于保存原始值
//	int count = 0; //count用于计算数字的位数
//	while (temp > 0) 
//	{
//		temp = temp / 10;
//		count++;
//	}
//	temp = num;
//	for (int i = count - 1; i >= 0; i--)
//	{
//		int j = pow(10, i);//调用pow需要包含<math.h> pow(a,x)的返回值是a^x次幂
//		printf("%d ", temp / j);//首位剥离法<打印的是除法结果 末尾剥离法却是取模结果> 依次是--> 1 (234) ->2 (34) -> 3 4 ->4
//		temp = temp % j;// temp-->以1234为例 temp=1234->234->34->4
//	}
//	return 0;
//}//不过如果我们还是想要让思路和代码呈现更简洁的话 那接下来就要请出今天的主角--递归函数了

//！！！递归函数的中心思想-->大事化小 一个递归函数的实现代码往往不会超过6行！
//void print_order1(unsigned int n)
//{
//	if (n>9)//规则一 递归函数需要有限制条件<这个条件是为了当n的位数减小到个位时及时停下 不至于停下过早 也不至于过晚>
//		//每次调用函数都会在栈区申请空间 如果没有这个限制条件递归函数就会一直递进深入 最后出现Stack overflow(栈溢出) 最终程序崩溃!
//	{
//		print_order1(n / 10);//规则二 每一次递归调用都会更接近这个限制
//	}
//	//捋捋思路：
//	//递归要将大事化小 前面我们采用末尾剥离法时 发现该思路是可行的就是顺序有误
//	//如果我们可以让数据从小到大<1 12 123 1234>的顺序挨个取模<1 2 3 4>的顺序就出来了
//	//而递归函数的作用就是将数据由大化小(通过不断调用函数本身 但是执行不同n值的整数除法来实现 直到个位数为止)
//	//此时数据已经按照由小到大的层级排好了<1位 12位 123位...>然后我们再让其每一层都取模并且打印一次然后一层层回归到外层函数即可
//	//其中规则一是当n是个位数时就不再继续递归<限制> 规则二是每一次递归都会让这个数的位数减少一 该数也会不断逼近个位数
//	//这 就是递归函数！！！ 
//	//递归递归 其实就是两个部分 -->先递进深入 再回归向上
//	printf("%d ", n % 10);
//}
//int main()
//{
//	unsigned int num = 0;
//	scanf("%u", &num);
//	print_order1(num);//这里命名为print_order1意为 这个函数的功能就是print 但要按照order 每次打印 1 个 即print_order1
//	return 0;
//}

//接下来 我们来试着实现以下 strlen 函数 即计算字符长度
//int my_strlen(char* p)//这里用数组形式作为形参也行 即 char brr[]也可以
//{
//	int count = 0;
//	while((*p) != '\0')//这里之所以能够直接比较字符而没有调用strcmp是因为根据指向地址直接用字符本身<'a'...>来比较了(本质ASCII码值)
//			//而之前比较字符数组和 "abc123"是否相等 因为涉及到调用数组内所有字符这么一个过程 才需要用到strcmp函数
//			//事实上 普通的字符(串)都可以直接进行比较的！
//	{
//		count++;
//		p++;
//		//这里的指针p++与常规++不同的是 原本p中存放的是arr[0]的地址 p++后就直接将其中的地址更换为arr[1]的地址了
//		//也就是说p++对应的其实是arr[0]->arr[1]  p指针指向的对象也就成了数组中第二个字符了
//		//注意！无论这个指针指向的对象是什么类型 或者说这个数组是什么类型 p++的效果都是如此 这是语法规定的！
//	}
//	return count;
//}
//int main()
//{
//	char arr[] = "abc";
//	int c = my_strlen(arr);
//	printf("%d\n",c);
//	return 0;
//}

//如果这个题目 是 在不创建临时变量的情况下 模拟实现strlen函数
//注意 以上方法的my_strlen函数中实际上创建了 count这个用于计数的临时变量 如何在不创建临时变量的情况下实现？
//int my_strlen(char* arr)
//{
//	if (*arr != '\0')//递归的限制
//	{
//		return 1 + my_strlen(arr+1);//每一次递归都会更接近该限制 这是递归的必备条件！！！
//		//注意 这里千万不能用arr++;arr++会陷入死递归！ 推荐写为arr+1 因为++arr改变了arr的值 arr+1只是改变了函数识别到的地址
//		//递归 如果首元素不是'\0';就返回1 并且进入下一个递归函数中 如果该递归到下一层仍然不是'\0'开头就再+1 反之+0
//		//再注意！ 递归调用的过程中往往是单向完成任务的 此处在递进深入的过程中 my...函数一直都没有+1! 直到回归向上时才开始+0 +1..
//	}
//	else
//	{
//		return 0;//注意！这里的返回0 并不是整个函数的返回值 而是递归每一层加减值的区别 思路是 用1+my...再1+1+my...直到首元素为'\0'
//	}
//}
//int main()
//{
//	char arr[] = "abc";
//	printf("%d\n", my_strlen(arr));
//	return 0;
//}
//这就满足了不创建临时变量的条件

//递归与迭代...
//迭代就是重复 循环就是一种迭代  来看看两者区别
//还是欲求 n的阶乘
//int ite(int m)//迭代的英文描述 iteration
//{
//	int i = 0;
//	int j = 1;//j用于存放阶乘值
//	for (i = 1; i <= m; i++)
//	{
//		j = j * i;
//	}
//	return j;//j初始化为1 这很重要 因为要包含 m=0时阶乘要返回1
//	//这里和递归一样 采用数学思维 将阶乘看作 i<=1;i>2两部分 只不过这里的for循环能将两者都包含其中
//}

//int rec(int n)//recursive function是递归函数的英文 这里取rec为递归函数的代表
//{
//	if (n <= 1)
//	{
//		return 1;
//	}
//	else
//	{
//		return n * rec(n - 1);
//	}
//}
//int main()
//{
//	int n = 0;
//	scanf("%d", &n);
//	//int ret = rec(n);
//	int ret = ite(n);
//	printf("%d\n", ret);
//	return 0;
//}//在这种情况下 似乎递归更加地小巧实用 但是也并不是所有情况都如此！

//求斐波那契数列输入为n的值 不考虑溢出
//斐波那契数列：1 1 2 3 5 8 13 21 44
//即 当n>2时 n=(n-1)+(n-2);
//用递归来描述依然思路简洁：
//int rec(int i)
//{
//	if (i > 2)
//	{
//		return rec(i - 1) + rec(i - 2);//但是这里却出现了问题 当输入n=50时 程序计算了很长时间 以至于半天加载不出来 这是为什么?
//		//当存在多递归模型时 函数很容易存在大量重复的计算量
//		//此处双递归 当输入 n=50时 对应：
//		//return rec(49)+rec(48)... 49+48 48+47... 48+47 47+46 47+46 46+45... 以此类推 越到递进深处 重复的计算量越大(千万级以上)
//	}
//	else
//	{
//		return 1;
//	}
//}

//对应迭代写法则不会如此复杂地计算 但是代码量也随之增加了
//int ite(int n)
//{
//	/*int a = 1;
//	int b = 1;
//	int c = 0;
//	if (n>2)
//	{
//		for (int i = 3; i <= n; i++)
//		{
//		c = a + b;
//		a = b;
//		b = c;
//		}
//		return c;
//	}
//	return 1;*/
//	//或者 while: --类
//	int a = 1;
//	int b = 1;
//	int c = 1;//c赋值为1是为了将n=0，1时包含其中---直接返回c=1即可
//	while (n >= 3)
//	{
//		c = a + b;
//		a = b;
//		b = c;
//		n--;
//	}
//	return c;
//}
//int main()
//{
//	int n = 0;
//	scanf("%d", &n);
//	//int ret = rec(n);
//	int ret = ite(n);
//	printf("%d\n", ret);
//	return 0;
//}

//由此引出一个问题 何时采用递归 何时又采用迭代？
//当可能要调用多递归模型时 请谨慎使用递归函数以避免大量重复计算;
//很多时候我们只是运用递归的思路来解释问题 以使思路更清晰 但是这些问题的迭代实现往往效率更高 只是可读性稍差
//当一个问题相当复杂 难以用迭代实现时 此时递归实现的简洁性可以来弥补它运行时产生的开销
//但其实 哪怕不进入死递归 递归函数仍然可能导致栈溢出！ 如何解决？
//1_简单粗暴 尽量使用非递归函数替换递归函数
//2_使用static对象替代局部变量 
//这不仅可以减少每次递进和返回时产生局部变量对栈区的消耗 而且静态常量还可以保存递归调用的中间状态 便利地为各个调用层所访问


//用代码将三个整数按从大到小来输出(不使用含数组的排序手法)
//void exch(int* px, int* py)//这里传址调用是为了直接对 a b c进行修改 使其分别按大小对应一二三顺位
//{
//	int ord = *px;//注意 如果想交换两个数的值 一定要有第三个数来放置其中一个数值 否则两者交换后其实是相同值
//	*px = *py;
//	*py = ord;
//}
//int main()
//{
//	int a,b,c= 0;
//	scanf("%d %d %d", &a, &b, &c);
//	if (a<b)
//	{
//		exch(&a, &b);
//	}
//	if (a<c)
//	{
//		exch(&a, &c);
//	}
//	if (b<c)
//	{
//		exch(&b, &c);
//	}
//	//为什么只有a<b;a<c;b<c三种？因为a>b;a>c;b>c;这三种情况是符合最后打印的大小次序的 不需要互相交换数值 也就无需列出！
//	printf("%d %d %d", a, b, c);
//	return 0;
//}


//给定两个数，求这两个数的最大公约数？
//思路：从两数的较小数开始递减 直到一个数可以同时整除两个数 则该数就是最大公约数
//1_从较小数开始 因为能同时整除两个数的必然要小于最小数 否则对于最小数而言连1倍都达不到
//2_采用递减而不是递增 也是为了节省时间和内存调用 因为题目要求找到最大公约数 递减得到的第一个公约数必然就是最大的
//int main()
//{
//	int a, b = 0;
//	scanf("%d %d", &a, &b);
//	int min = (a < b ? a: b);//这里使用了三目操作符
//	//注意 求两数之中的较大或较小数 都可以使用三目操作符来快捷地实现 如果求max就写作a>b 反之min就写作a<b
//	int m = min;
//	while (1)
//	{
//		if (a%m == 0 && b%m == 0)
//		{
//			break;
//		}
//		m--;
//	}
//	printf("最大公约数是：%d\n", m);
//	return 0;
//}//这样的实现方法简单粗暴 但是计算冗余 思考一下是否有更优算法？

//接下来介绍辗转相除法：
//辗转相除法，又称欧几里得算法，适用于计算最大公约数
//(a,b)->(b,r)->(b',r')->(b",r")->...0	（a,b）表示a模b，设结果为r，然后继续以b为被除数计算(b,r)...直到(b^n,r^n)==0为止
//这时得到的r^n就是最大公约数
//原理 a==q*b+r 则r==a-q*b 设a==m*u b==n*u 则u即为a,b公约数 r==a-q*b==u*(m-n*q)==u*v 易得v必为整数 所以u也就是[a,b,r]的公约数
//也就是说[a,b] [b,r] 的公约数是完全一致的 当一直取模运算到r^n时,[b^n,r^n]的公约数u^n就是r^n 因为r^n能同时整除b^n和它本身
//又因为公约数不能大于两数任一一个 所以r^n就是[b^n,r^n]的最大公约数 又因为[a,b],[b,r] 的公约数是完全一致的所以后者的最大公约数也是前者的最大公约数
//得证！
//程序实现：

//int main()
//{
//	int a, b = 0;
//	int r = 0;//r用于计算模 同时将数值赋给下一次计算模时的b
//	scanf("%d %d", &a, &b);
//	while (r=a%b)//r在此处还用作判断条件 当r==0时退出循环并打印b（也就是r^n）的值
//	{
//		a = b;
//		b = r;
//	}
//	printf("最大公约数是：%d\n", b);
//	return 0;
//}
//这种算法肉眼可见的简洁:> 事实上这种涉及到数论的算法还有很多 比如如何求最小公倍数? 后面在数据结构与算法分析的学习中便会涉及到

//求十个数中的最大数？（非排序问题）
//思路 打擂台 ---用到了冒泡排序的一些思想
//假定第一个数据最大 将其放入到一个变量后让其与后续数据遍历比较 若后者大 则更新变量值 当循环结束 即可得到最大值
//int main()
//{
//	int arr[10] = { 0 };
//	//注意 如果写作arr[] 那么数组向内存申请的大小就取决于{}中的数据数 此时的{0}会被处理为存放一个数据(0)而不是对数组的初始化
//	//此时对于arr[2...10]都是越界访问了 栈区中的数组存放结构就会被破坏 程序报错
//	int i = 0;
//	for (i = 0; i < 10; i++)
//	{
//		scanf("%d", &arr[i]);
//		//此处若不采用数组来循环读入数据 则代码量冗余了 所以采用数组+循环是更方便的做法
//		//还需注意 当涉及到数组中具体的元素时 arr[i]就不是地址了 而是对应下标的元素 那么此时就需要用取地址符
//	}
//	int max = arr[0];//max为最大值 此处假定为第一个数据的值
//	for (int n = 1; n < 10; n++)
//	{
//		if (arr[n]>max)
//		{
//			max = arr[n];
//		}
//	}
//	printf("最大数是：%d\n", max);
//	return 0;
//}

//打印9*9乘法表
//首先 观察9*9乘法表
//1*1=1
//2*1=2 2*2=4
//3*1=3 3*2=6 3*3=9
//4*1=4 4*2=8 4*3=12 4*4=16
//...
//可见乘法表主体是两个变量：
//i		*j [j<=i]
//1		*1
//2		*1 *2
//3		*1 *2 *3
//...
//故函数的实现可以是
//int main()
//{
//	int i = 0;//i是左边的第一个数，也是行数
//	for ( i = 1; i < 10; i++)
//	{
//		for (int j = 1; j <= i; j++)//这里j必须是<=i(i为几则j乘到几)而不能是<=10 否则1~9每个数都会自乘1~9 就会产生大量重复
//		{
//			printf("%d*%d=%2d ", i, j,i*j);
//			//用%2d是为了让前面乘出的一位数和后面的两位数对齐 2是数据在打印时至少要占的宽度 +2表示右对齐2宽度 -2表示左对齐2宽度
//			//这里的%2d后面必须要留有空格 否则单数位和双数位对齐后 前面的结果会和后面的乘数粘连 影响观感
//			//此外 这里必须要用一个变量来对应这个%2d所占的位置 否则传参不够，导致打印时原本对应的乘积全部打印错误
//		}
//		printf("\n");
//		//如果在内层for的printf中加入\n 将导致每打印一个i*j(如2*1=2)后立刻换行 但我们所需要的是每打印完一行i*1 2...i之后再换行
//	}
//	return 0;
//}
//补充：打印一个由输入值决定打印行数的9*9乘法表
//其实只需要让第一层函数的i<=n即可 n为输入的值


//一道重要的回顾题：
//把函数处理结果的两个数据都返回给主调函数，下列做法不正确的是？
//1_return这两个值	 2_形参用数组	3_形参用两个指针	4_用两个全局变量
//答案为1 下面分别举例进行分析

//1_return:
//int func()
//{
//	return 3, 4;//return (3, 4);
//	//这两种写法编译器都不报错并且由于都是逗号操作符 返回值都是4！
//}
//int main()
//{
//	int ret = func();
//	printf("%d\n",ret);//只打印了4 因为return 3,4时 由于逗号操作符是将表达式从左到右依次计算后取最后的结果 所以取4作为返回值
//	return 0;
//}//由此可见 return 两个值 这种写法并没错 但是编译器只会返回一个值 换句话说return 只能返回一个值;

//2_形参用数组:
//void func(int arr[])//这里的arr[]其实就是指针
//{
//	arr[0] = 3;//这里的arr[0]其实是*(arr+0)
//	arr[1] = 4;//arr[1]即*(arr+1) 注意arr是数组首元素的地址 +1是直接指向数组中下一个元素地址的
//	//可见 当函数参数是数组时 其实就是传址调用 因此函数中对arr[0]和arr[1]赋值就是对arr数组本身的元素进行赋值
//}
//int main()
//{
//	int arr[2] = { 0 };
//	func(arr);
//	printf("%d %d\n",arr[0],arr[1]);//3 4 
//	return 0;
//}

//3_形参用两个指针
//void run(int* px,int* py)
//{
//	*px = 3;
//	*py = 4;
//}
//int main()
//{
//	int a, b=0;
//	run(&a, &b);
//	printf("%d %d\n", a, b);
//	return 0;
//}//这更简单明了了 直接就是传址调用

//4_用两个全局变量
//int a, b = 0;//这里的a,b的定义在dun main函数之前 是为全局变量
//void dun()
//{
//	a = 3;
//	b = 4;//这里分别对a,b进行赋值
//}
//int main()
//{
//	dun();//由于全局变量的作用域是整个程序 所以调用dun函数后 dun函数中对于a,b的赋值在整个程序中都是可以生效的
//	printf("%d %d\n", a, b);//3 4
//	return 0;
//}


//数组
//数组的概念
//数组是一组相同类型元素的集合，数组的产生便于我们去存放一组数据
//数组中存放的是1个或者多个数据 但是不能是零个！
//随着数组下标的由小到大 地址由低到高
//数组分一维数组和多维数组 二维数组是最常见的多维数组

//一维数组的创建和初始化
//创建的基本语法： type arr_name[常量值] type为数组类型 也是数组中存储的元素的类型
//注意 在C99标准之前是不允许[]中放置变量的 但是在C99标准后[]中允许放置变量 也就是说支持了变长数组：数组的长度(大小)由变量大小来决定
//而数组中的元素也是在确定变量值后再输入或者给定的
//不过VS编译器是不支持变长数组的，而别的一些编译器如linux环境下的GCC编译器是支持的
//还需要提醒 变长数组的变量值未确定前 是不能初始化的 只能进行声明:	int arr[n];
//因为n不给定之前数组是不会向内存申请空间的 也就无法初始化
//数组的初始化指，在创建数组的同时给数组的内容一些合理初始值
//区分不完全和完全初始化！
//int arr[10] = {1,2,3}; 这就是不完全初始化，剩余的元素默认初始化为0
//区分{}和""
//char ch1[10] = ={'a','b','c'}; 补齐七个默认初始化为0的元素
//char ch2[10] = "abc";补齐默认六个初始化为0的元素 因为存在\0
//int main()
//{
//	char arr[4] = "abc";//注意这和下面的写法效果是一样的 不要因为"abc"写在一起而理解搞混 实际上arr[0]就是a arr[1]就是b...
//	char brr[3] = { 'a','b','c' };
//	printf("%c %c %c\n", arr[0], arr[1], arr[2]);
//	printf("%c %c %c", brr[0], brr[1], brr[2]);
//	return 0;
//}
//数组的大小是可以计算出的 int sz=sizeof(arr)/sizeof(arr[0]) 同样的 使用sz可以用于循环打印arr[0]到arr[sz-1]..即数组内所有的元素

//一维数组在内存中的存储
//%p可以打印地址（16进制形式） 如下
//int main()
//{
//	int arr[] = { 1,2,3,4,5 };
//	int i = 0;
//	int sz = sizeof(arr) / sizeof(arr[0]);
//	for ( i = 0; i < sz; i++)//<sz也就是 <=sz-1;
//	{
//		printf("&arr[%d]=%p\n", i, &arr[i]);//%p打印地址 这里对应地用&来打印arr[i]的地址
//	}
//	return 0;
//}
//结果分析:
//&arr[0] = 000000EA616FF568
//&arr[1] = 000000EA616FF56C
//&arr[2] = 000000EA616FF570
//&arr[3] = 000000EA616FF574
//&arr[4] = 000000EA616FF578
//每个地址大小相差四 因为该数组为整型数组 一个整型占4个字节 而该地址是4个字节中占首字节空间的地址
//结论：数组在内存中是连续存放的; 随着下标的增长，地址是由小到大，由低到高的顺序变化的

//二维数组
//总结：二维数组其实就是一维数组的数组，二维数组的每一行都是一个一维数组 而这一行一维数组又是二维数组的元素！！！
//定义：
//type arr_name[常量值1][常量值2]; 其中常量值1代表行 常量值2代表列
//int main()
//{
//	//完全初始化：
//	int arr[3][5] = { 1,2,3,4,5,2,3,4,5,6,3,4,5,6,7 };//联想三行五列矩阵
//	//该二维数组其实就长这样：可以用调试监视窗口查看对应值
//	/*	0 1 2 3 4
//	0	1 2 3 4 5
//	1	2 3 4 5 6
//	2	3 4 5 6 7*/
//	//每一行编译器会自动找5个数据填充为1行 它也就等价于 int arr[3][5] = {{1,2,3,4,5},{2,3,4,5,6},{3,4,5,6,7}};
//	//也可以不填充满，也就是不完全初始化，如
//	int brr[3][5] = {{1,2},{3,4},{5,6}};//编译器会自动填充每行的剩余数据为0！即:{{1,2,0,0,0},{3,4,0,0,0},{5,6,0,0,0}}
//	//同时通过监视窗口我们可以看到brr中存放的就是{1,2,0,0,0}的地址 也就是说二维数组对应的地址依然是首元素的地址
//	//这里可以类比于集合的概念 {{},{}...} 第一个{}整体是首元素
//	//还要注意！二维数组等多维数组都只能省略掉行（第一维） 不能省略掉后面的部分
//	//因为编译器可以在没有第一维的情况下根据后面维度的需求填充好完整的多维数组 但是没有第二维 第三维..则不行！
//	//以arr[2][]={1,2,3,4,5,6}为例 它有无穷多种可能情况
//	/*	0 1...n
//	0	
//  1	
//	n>4时第二行为全零行*/
//	int crr[][4] = { {1,2,3,4},{5,6} };//编译器会自动将其补齐为：
//	/*	0 1 2 3
//	0	1 2 3 4
//	1	5 6 0 0*/
//	return 0;
//}


//二维数组的访问:
//int main()
//{
//	int arr[3][3] = { {1,2,3},{4,5,6},{7,8,9} };//注意 定义为[3][3]但是下标访问范围依然是0~2;0~2！！！
//	printf("%d\n", arr[0][2]);//打印第一行第三列的数据
//	for (int i = 0; i < 3; i++)//需要注意这里的i和下面的j的边界值 三行三列所以<3 因为下标引用是从零开始的
//	{
//		int j = 0;//j每次都要从零开始 故每次i循环都必须要初始化一次j=0;
//		for ( j = 0; j < 3; j++)
//		{
//			printf("%d ", arr[i][j]);
//		}
//		printf("\n");//类比于9*9乘法表那里的外层换行操作 借以实现每循环完一次i就换行
//	}//这个嵌套循环是访问二维数组最常见的方法
//	return 0;
//}

//二维数组在内存中的存储
//因为二维数组是一维数组的数组 每一行都是一个一维数组 而且一个一维数组又都是二维数组中的一个元素 数组在内存中的存储又都是连续的
//由此可得 二维数组在内存中的存储也都是连续的并且是以一维数组的存储长度为单位的 第一行接着第二行...第一个一维数组接着第二个...
//int main()
//{
//	int arr1[6] = { 1,2,3,4,5,6 };
//	int arr2[3][2] = { {1,2},{3,4},{5,6} };
//	//由监视窗口可知 这两者在内存中的存储其实是一样的 arr的地址都是首元素地址 而每个元素都对应一个地址
//	//只是arr1地址是arr[0]的地址 而arr2地址是arr[0][0~1](->即第一个一维数组)的地址 同时每个元素又都对应一个一维数组的地址罢了
//	return 0;
//}

//数组越界
//数组的下标是有范围限制的 假定有n个元素 则范围：0~n-1
//超出这个范围都属于越界访问 这里需要注意的是：C语言和编译器不会做数组下标的越界检查 但是不报错不意味着程序就是正确的
//所以程序员在写代码时最好自己做越界的检查
//特别注意一下多维数组的越界访问
//以二维数组为例 行越界和列越界是不同的 行越界时是直接越界访问到随机值 但是列越界时会正常访问前面的数据 直到数组中数据访问完才访问随机值
//这是因为二维数组在内存中的的存储是arr[0][0~n]紧接着arr[1][0~n].. 因此当列越界时数据访问会继续访问到下一个一维数组中的数据
//当且仅当数组访问完整个二维数组的数据后才会越界访问随机值直到结束 


//数组的一些常见用例
//1_数组作为函数参数: void func(int arr[]) 这里的数组arr[]就是作为函数参数的用法 实际上这和int* arr是一样的 都是指针
//只不过用数组作参更利于理解 毕竟实参是数组 形参也用数组表示更利于理解
//接下来我们用数组作参来写一个貌似常见的函数...>>>以实现冒泡排序
//冒泡排序算法核心：用相邻的两个元素进行比较！  因为数的上浮过程类似于汽水饮料的冒泡 因此得名
//现有：9 8 7 6 5 4 3 2 1 0 请将其改为升序
//升序冒泡思路：
//9>8 则9和8交换位置..9>7则9和7交换位置..直到换位置到末尾 也就是最大数对应的位置后这一趟冒泡才结束
//紧接着这时第一个元素就是8了 8重复9的操作..交换到倒数第二位后即可停止第二趟冒泡(因为它不是最大数,这是第一趟冒泡后的结论)
//然后是7...1 当1这一趟冒泡结束后整个冒泡排序就结束了 因为最后一个元素是被其他元素筛选了的 必然是最小的
//所以得出结论:n个元素的冒泡排序趟数=n-1趟 ！
//补充结论:在一趟冒泡排序中若有n个元素需要排序 则比较数=n-1 因为第一个数不需要和它本身进行比较 所以比较数会减一！
//而升序排序每一趟由于最后面的数据会相继确定(从后往前) 导致每一趟冒泡中需要比较的元素数目也是递减的 即n-1-1-1...
//有了上面的理论知识 我们来实现一下冒泡排序吧！
//int main()
//{
//	int arr[10] = { 9,8,7,6,5,4,3,2,1,0 };
//	int sz = sizeof(arr) / sizeof(arr[0]);
//	for (int i = 0; i < sz-1; i++)//i<sz-1?
//	{
//		int flag = 0;
//		for (int j = 0; j < sz-1-i; j++)//j<sz-1-i?
//		{
//			int c = 0;
//			if (arr[j]>arr[j+1])
//			{
//				c = arr[j];
//				arr[j] = arr[j+1];
//				arr[j+1] = c;
//				flag = 1;
//			}
//		}
//		if (0==flag)//flag?
//		{
//			break;
//		}
//	}
//	for (int n = 0; n < sz; n++)
//	{
//		printf("%d ", arr[n]);
//	}
//	return 0;
//}
//上面有三个问题 接下来一一解答：
//1-->>	i<sz-1?
//这里的i是冒泡排序的趟数 由前面的结论可知i的范围是[1,n-1] 因为i从0开始 所以还需要减一 即i[0,n-2];
//又因为<=n-2 和<n-1是等效的 所以写作i<n-1 注意 这种替换非常常见 因为在编程规范中我们会尽量少用<=这种写法
//2-->> j<sz-1-i?
//j用于表示一趟冒泡排序中的比较次数 在升序排序中 数据是从后往前一个个确定的 所以j每次都要从零开始 但是j的上限递减直到0
//由上面的补充结论 一趟冒泡排序有n个元素时 比较数是n-1 而且随着冒泡的趟数增加 比较数是递减的
//所以这里j<sz-1(等效于j<=sz-2，因为j也是从0开始) j的上限sz-2就是第一趟时的比较数 但是如何表示出j随冒泡趟数增加的递减特性?
//我们注意到 i的上下限=j的上下限 只是前者递增后者后者递减 那么我们就可以试着用上限-i来表示j的递减
//当i加1时j=上限-i也对应减一 当i到达上限时j也到达下限 同时因为i表示趟数 也完美契合了j随冒泡趟数增加而递减的特性
//所以我们用i来实现j每一趟冒泡时的递减 也就是j<sz-1-i 这样就不用再设置一个变量了
//3-->> flag?
//这里由于9,8,7..是完全逆序的 所以冒泡会一直进行到最后一个数 但有时一堆数据中只有部分数据是逆序的
//所以我们使用flag作一个标志变量 当数据中最后一个逆序的数被纠正时 下一趟冒泡就不会进入交换的if语句中 flag也就不会被赋值为1
//那么此时我们就可以用if(flag==0)..break;来跳出循环 避免后续继续无效循环浪费运行时间和内存空间
//事实上 我们常常将冒泡排序写作函数(名Bubble_sort:冒泡排序翻译)的形式独立于主函数之外 这样可以随时调用冒泡排序
//但是千万注意！当传递数组到函数中去时 函数不能进行数组大小以及数组元素个数(sz)的计算 前面已经解释过：函数中的sz恒等于1(x86)或2(x64)

//数组名
//我们常说：数组名就是首元素地址 事实上这并不完全正确
//存在两个特例：
//1_sizeof(数组名) 此时数组名代表的是整个数组的地址 而sizeof计算的也就是整个数组地址的大小;
//2_&数组名，这里取数组地址表示的是取出整个数组的地址 单位是字节

//int main()
//{
//	int arr[10] = { 0 };
//	printf("%zu\n", sizeof(arr));//40=10*4 这就是第一个特例 
//	return 0;
//}

//int main()
//{
//	int arr[10] = { 0 };
//	printf("%p\n", arr);//结尾08
//	printf("%p\n", &arr[0]);//结尾08
//	printf("%p\n", &arr);//结尾08
//	printf("----------------\n");
//	//这三个打印出来结果完全一致？ 一二相同容易理解 因为数组在非特例情况下就是首元素地址 但是为何第三个也是相同的？
//	//这是因为取出整个数组的地址时 这个"整个数组的地址"仍然是用首元素地址来代表的 但是这不意味着它就和前两者是一样的 理由：
//	printf("%p\n", arr + 1);//结尾0C
//	printf("%p\n", &arr[0] + 1);//结尾0C
//	printf("%p\n", &arr + 1);//结尾30
//	//按16进制计算 0C的十进制是12 08的十进制就是8 前者比后者多4个字节 说明arr+1和&arr[0]+1都是从数组的首元素地址跳到下一个元素地址
//	//但是30的十进制是48 而48-8=40 40/4=10(个整型数据的内存大小)也就是说&arr+1是直接跳到了整个数组后面的下一个内存地址
//	//从这儿就可以看出来 虽然打印&arr时仍然打印的是首元素地址 但是本质上和前二者是完全不同的	这就是特例二
//	return 0;
//}

//由此也再次印证了不能在函数里计算数组大小和元素个数 因为非特例情况下数组名就是首元素地址
//也就是说数组传参时传的是首元素地址-->>即一个指针 
//那么sizeof(arr)就恒等于8(x64中一个指针占据8字节大小) 而不是整个数组的大小 所以不能在...

//二维数组名的理解
//int main()
//{
//	int arr[3][4] = { 0 };//总共12个整型数据
//	int c = sizeof(arr);
//	printf("%d\n", c);//48=12*4 可见arr的大小就是整个二维数组的元素所占的大小
//	printf("%p\n", arr);
//	//非两个特例下二维数组的数组名也表示首元素的地址名 并且由前面知识点可知 二维数组的首元素是第一行的一维数组
//	//虽然打印一维数组地址时又用首元素arr[0][0]的地址来代表 但是注意分清楚本质
//	//在一维数组中 我们需要计算元素个数时采用的数组大小/首元素大小的做法
//	//那么在二维数组中 我们就可以用二维数组大小/首个元素(一维数组)大小来计算
//	int d = sizeof(arr) / sizeof(arr[0]);//这里是第一个特例 sizeof(数组名)计算整个数组大小 arr[0]代表第一行对应一维数组的大小
//	printf("%d\n", d);//3
//	//同理 我们还可以计算二维数组的列数=二维数组中中一维数组的的元素个数
//	int e = sizeof(arr[0]) / sizeof(arr[0][0]);//这里其实就是一维数组元素个数的计算方式 只是arr变成了arr[0] arr[0]变成了arr[0][0]
//	printf("%d\n", e);
//	//sizeof返回类型是size_t(无符号整型) 打印时应该使用%zu来打印 但是如果用一个int(有符号位)变量来接收 编译器是不会报警告的 
//	return 0;
//}


//2_三子棋的实现
//思路:
//1_先打印一个菜单 询问是否游戏-->0/1/错误
//2_游戏-->打印棋盘 并让玩家和电脑一起下棋 不游戏-->回到菜单
//棋盘大概长相：
//	 |	 |
//___|___|___
//	 |	 |
//___|___|___
//   |   |   
//	 |	 |
//3_玩家下棋/电脑下棋 并实时判断是否有胜者 是否平局
//4_回到菜单 是否继续？
//我们来实现一下：
//#define Row 3
//#define Col 3
//int flag = 0;
//void menu()
//{
//	char arr1[] = "            ";
//	char arr2[] = "Play or Not?";
//	char arr3[] = "                           ";
//	char arr4[] = "Play: input 1 exit: input 2";
//	int left1 = 0, left2 = 0;
//	size_t right1 = strlen(arr1 - 1);
//	size_t right2 = strlen(arr3 - 1);
//	while (left1<=right1)
//	{
//		arr1[left1] = arr2[left1];
//		arr1[right1] = arr2[right1];
//		printf("%s\n", arr1);
//		Sleep(300);
//		system("cls");
//		left1++;
//		right1--;
//	}
//	while (left2<=right2)
//	{
//		arr3[left2] = arr4[left2];
//		arr3[right2] = arr4[right2];
//		printf("%s\n", arr3);
//		Sleep(150);
//		system("cls");
//		left2++;
//		right2--;
//	}
//	printf("%s\n%s\n", arr1,arr3);
//}
//void initboard(char chessboard[Row][Col], int row, int col)
//{
//	int i=0, j = 0;
//	for ( i = 0; i < row; i++)
//	{
//		for ( j = 0; j < col; j++)
//		{
//			chessboard[i][j] = ' ';
//		}
//	}
//}
//void printboard(char chessboard[Row][Col],int row,int col)
//{
//	int i = 0;
//	for (int i = 0; i < row; i++)
//	{
//		int j = 0;
//		for (j = 0; j < col; j++)
//		{
//			if (j < col - 1)
//			{
//				printf(" %c |", chessboard[i][j]);
//				
//			}
//			else
//				printf(" %c \n", chessboard[i][j]);
//		}
//		if (i<row-1)
//		{
//			for (int j = 0; j < col; j++)
//			{
//				if (j < col - 1)
//			{
//					printf("---|");
//			}
//				else
//					printf("---\n");
//			}
//		}
//	}
//}
//void playermove(char chessboard[Row][Col], int row, int col)
//{
//	int x, y = 0;
//	printf("Player Chess-->input n,n \n");
//	scanf("%d,%d", &x, &y);
//	while (true)
//	{
//		if (x > 0 && x <= row && y > 0 && y <= col)
//		{
//			if (chessboard[x - 1][y - 1] == ' ')
//			{
//				chessboard[x - 1][y - 1] = '*';
//				flag = 0;
//				break;
//			}
//			else
//			{
//				printf("This coordinate is already occupied,please re-enter it.\n");
//				Sleep(2500);
//				flag = 1;
//				break;
//			}
//		}
//		else
//		{
//			printf("The coordinates entered are illegal.\nPlease try again.\n");
//			Sleep(2500);
//			flag = 1;
//			break;
//		}
//	}
//}
//void computermove(char chessboard[Row][Col], int row, int col)
//{
//	printf("Computer chess...\n");
//	Sleep(2000);
//	int x, y = 0;
//	while (1)
//	{
//		x = rand() % row;
//		y = rand() % col;
//		if (chessboard[x][y] == ' ')
//		{
//			chessboard[x][y] = '#';
//			break;
//		}
//	}
//}
//char ionwin(char chessboard[Row][Col])
//{
//	int i, j = 0;
//	for ( i = 0; i < Row; i++)//行等
//	{
//		int countp=0,countc = 0;
//		for ( j = 0; j < Col; j++)
//		{
//			if (chessboard[i][j]=='*')
//			{
//				countp++;
//			}
//			if (chessboard[i][j]=='#')
//			{
//				countc++;
//			}
//		}
//		if (countp==3)
//		{
//			return 'y';
//		}
//		if (countc==3)
//		{
//			return 'n';
//		}
//	}
//	for ( j = 0; j < Col; j++)//列等
//	{
//		int countp = 0, countc = 0;
//		for ( i = 0; i < Row; i++)
//		{
//			if (chessboard[i][j] == '*')
//			{
//				countp++;
//			}
//			if (chessboard[i][j] == '#')
//			{
//				countc++;
//			}
//		}
//		if (countp == 3)
//		{
//			return 'y';
//		}
//		if (countc == 3)
//		{
//			return 'n';
//		}
//	}
//	if (1)//交叉等
//	{
//		int countp1 = 0, countc1 = 0;
//		int countp2 = 0, countc2 = 0;
//		for (i = 0, j = 0; i < Row && j < Col; i++ && j++)
//		{
//			if (chessboard[i][j] == '*')
//				countp1++;
//			else if (chessboard[i][j] == '#')
//				countc1++;
//			else
//				break;
//		}
//		for (i = 2, j = 0; i >= 0 && j < Col; i-- && j++)
//		{
//			if (chessboard[i][j] == '*')
//				countp2++;
//			else if (chessboard[i][j] == '#')
//				countc2++;
//			else
//				break;
//		}
//		if (countp1==3||countp2==3)
//		{
//			return 'y';
//		}
//		if (countc1==3||countc2==3)
//		{
//			return 'n';
//		}
//	}
//	int flag = 1;//判断平局
//	for (int i = 0; i < Row; i++)
//	{
//		for (int j = 0; j < Col; j++)
//		{
//			if (chessboard[i][j]==' ')
//			{
//				flag = 0;
//			}
//		}
//	}
//	if (flag)
//	{
//		return 't';
//	}
//}
//void game()
//{
//	char chessboard[Row][Col] = { 0 };
//	initboard(chessboard, Row, Col);
//	printboard(chessboard,Row,Col);
//	while (1)
//	{
//		char judge = 0;
//		playermove(chessboard, Row, Col);
//		printboard(chessboard, Row, Col);
//		judge=ionwin(chessboard);
//		if (judge=='y')
//		{
//			printf("YOU WIN!\n");
//			Sleep(1500);
//			break;
//		}
//		else if (judge=='t')
//		{
//			printf("STALEMATE!\n");
//			Sleep(1500);
//			break;
//		}
//		if (flag==0)
//		{
//			computermove(chessboard, Row, Col);
//			printboard(chessboard, Row, Col);
//		}
//		judge = ionwin(chessboard);
//		if (judge == 'n')
//		{
//			printf("YOU LOSE!\n");
//			Sleep(1500);
//			break;
//		}
//		else if (judge == 't')
//		{
//			printf("STALEMATE!\n");
//			Sleep(1500);
//			break;
//		}
//	}
//}
//
//int main()
//{
//	int input = 0;
//	srand((unsigned int)time(NULL));
//	do
//	{
//		menu();
//		scanf("%d", &input);
//		switch (input)
//		{
//		case 1:
//			printf("Enter the game...\n");
//			Sleep(1000);
//			game();
//			break;
//		case 2:
//			printf("Exit the game...\n");
//			Sleep(1000);
//			exit(0);//退出
//			break;
//		default:
//			printf("Wrong choice! Please re-select-->\n");
//			Sleep(1500);
//			break;
//		}
//	} while (input);
//	return 0;
//}


//递归实现一个reverse_string 将字符串逆序--不只是逆序打印！
//思路：
//元素下标 0 1 2 3 4 5 
//我们只需要让0和5，4和1，2和3对应交换即可 那么我们可以设置一个函数用来交换传递过来的参数所对应的数组中的字符
//而当第一次交换完0和5之后让它继续递归调用 左参数+1，右参数-1，即可交换1，4和2，3，直到左参数>=右参数时停止递归并返回主函数
//总结就是，限制条件：左参数<右参数		逼近方式：每次递归调用左参数-1，右参数+1；
//非递归实现：
//static reverse_string(char arr[], size_t left, size_t right)
//{
//	char temp = 0;
//	while (left<right)
//	{
//		temp = arr[left];
//		arr[left] = arr[right];
//		arr[right] = temp;
//		left++;
//		right--;
//	}
//}
//错误的递归实现：	先交换 再判断是否递归
//static reverse_string(char arr[], size_t left, size_t right)
//{
//	char temp = 0;
//	temp = arr[left];
//	arr[left] = arr[right];
//	arr[right] = temp;
//	if (left < right)
//	{
//		reverse_string(arr, left + 1, right - 1);//fecdba 为什么会出错呢？其实错误之处就在于先交换再判断 导致程序不具有普适性
//	}
//	//当字符串长度为偶数时 这样的递归会导致原本进行到递归底层时由于left<right从而再次进入递归调用后进行了一次额外的交换
//	//然后再回归向上 所以此时中间那两个字符就会呈现出未交换的顺序 实则已经交换了两次
//	//而当字符串长度为奇数时 多一次递归调用也不会出错 因为那时的left+1已经等于right-1了 自己和自己交换并不会改变顺序
//}
//正确的递归实现:	先判断 再交换和递归
//static reverse_string(char arr[],size_t left,size_t right)
//{
//	if (left<right)
//	{
//		char temp = 0;
//		temp = arr[left];
//		arr[left] = arr[right];
//		arr[right] = temp;
//		reverse_string(arr,left+1,right-1);//fedcba
//	}
//}
//int main()
//{
//	char arr[] = "abcdef";
//	size_t sz = sizeof(arr) / sizeof(arr[0]);//勿忘:sizeof不能放函数中计算
//	//这里用strlen也可，但是换成strlen-1，因为\0不计入字长
//	reverse_string(arr, 0, sz - 2);
//	for (int i = 0; i < sz-1; i++)
//	{
//		printf("%c", arr[i]);
//	}
//	return 0;
//}
//补充：size_t
//size_t是无符号整型的一种 它能够以字节为单位表示任何对象的大小(自适应性) 它可以是 unsigned char,int,long,long long等等
//它的优点是可以提高代码移植时的兼容性 还可以分配最合适的内存空间，避免浪费 这在嵌入式系统开发中是比较在意的一点
//它对应的标准占位符是%zu 但是也兼容%u毕竟说到底也是无符号整型 

//写一个递归函数 DigitSum 使其能计算数位之和
//例如: 输入非负整数 1234 计算出 1+2+3+4=11并输出在控制台
//思路：
//非负整数-->unsigned int 所以可以用size_t来定义变量
//1+2+3+4即是4+3+2+1 容易知道 取末尾数字采用%10即可 所以容易发现
// x	   x%10
//1234		4
//123		3
//12		2
//1			1
//0			0
//显然x并不需要递归深入到0 只是到个位数就可以了 所以限制条件可设置为x>9 逼近方式自然是x/10
//而后向上回归 每次回归都加上x%10(底层回归时返回x本身即可)作为整体返回值 这就实现了1+2+3+4并且最后到达顶层时又返回了主函数
//注意 哪怕x就是个位数也无所谓 直接作底层回归 返回本身到主函数
//size_t DigitSum(size_t x)
//{
//	if (x>9)
//	{
//		return DigitSum(x / 10)+x%10;
//	}
//	return x;//这个return x只有在底层回归时才会执行 后面每次回归由于x都>9所以会一直在if语句中 到顶层时直接返回主函数
//}
//int main()
//{
//	size_t x= 0;
//	scanf("%zu", &x);
//	size_t ret =DigitSum(x);
//	printf("%zu", ret);
//	return 0;
//}


//递归实现n的k次方
//思路类似于上题 关键：大事化小！//补充 其实库函数中本身就含有计算次方的函数 pow(n,k) 即是计算n的k次方
//double power(int x,int y)//power:幂，指数
//{
//	//对y进行判断
//	if (y>0)
//	{
//		return power(x, y - 1) * x;
//	}
//	else if(y<0)
//	{
//		return 1/power(x,-y);//因为x^y(y<0)=1/x^-y(-y>0) 所以分母部分可以直接传参-y进行递归调用 计算出次方值后返回到此处即可
//	}
//	//递归深入到底层时对x进行判断
//	if (x!=0)
//	{
//		return 1;
//	}
//	return 0;
//}
//int main()
//{
//	int n,k = 0;
//	scanf("%d %d", &n,&k);
//	double ret = power(n,k);
//	printf("%d^%d=%.4lf\n", n, k, ret);//注意打印ret时要用%lf
//	return 0;
//}


//数组习题：
//1_请问这两个数组的长度关系？
//char acX[] = "abcd";
//char acY[] = { 'a','b','c','d' };
//注意这里很容易误以为两者长度相等 但是！！！这里是数组长度！
//数组长度的计算是要算入'\0'的！ 而字符串的长度计算以'\0'为结束标志所以不计入'\0'
//ans: 数组acX的长度大于数组acY的长度

//2_请问这种初始化正确吗?
//int a[][3] = { {0,,2},{},{3,4,5} };
//这里犯了两个错误：
//1..{0,,2} 两个逗号之间不能为空 {,,}不会被算作初始化为空 编译器也不会自动补全成0 所以这样写是非法的；
//2..{} 初始化为{}编译器也是无法解释的 如果解释为三行 那么这里面不能为空 如果解释为两行 那么数组中就不该存在{}这个初始值设定项
//所以这种初始化是错误的


//扫雷游戏:




//操作符详解
//操作符分类：
//算术操作符;移位操作符;位操作符;赋值操作符;单目操作符;关系操作符;逻辑操作符;条件操作符;逗号表达式;下标引用,函数调用,结构成员等等

//1_算术操作符：
//关于取整(trunc) 取模(mod) 取余(rem)
//事实上 关于取整有四个函数 代表了四种取法：
//trunc:->0方向取整		ceil:->+∞方向取整		floor:->-∞方向取整		round:->四舍五入取整
//在不同的语言中 采取的取整方式是不同的 向0取整系:c,c++,java,c#...		向-∞取整:python
//-10/3的C语言解释 ： - 10 = (-3) * 3 + (-1)
//因为c语言是对于商的计算是往0方向取整 在数轴上-3离0更近 所以取商为-3 那么余数就是-1
//-10/3的python解释： - 10 = (-4) * 3 + 2
//因为python的取整是往-∞方向 -4离-∞更近 所以取商为-4 余数也就是2
//也就是说出现-3.333..在python和c语言中有着不同的理解 这里的不同就是取整方向不同
//还要补充：在数学语言中余数是大于0的 但是在编程语言中 余数r的定义范围是 0<=|r|<|d| d:除数
//取模与取余的区别：以a=b*q+r为例
//取模是为了让商q往-∞方向取整 而取余是为了让q向0方向取整 
//当%两边操作数同号时取模和取余等效 ； 操作数异号时则两者不相等
//所以 C,C++,Java..中的%取模符号其实本质上是取余 而python中的%才是真正的取模运算
//---------------------------------------------------------------------------------------->>>>>
//为避免混淆 我们此后在C语言中起一个约定 统称%为取余操作符
//关于余数的符号 -->0系取整的编程语言体系中 余数的符号与被除数相同
//而对-->-∞系的python而言余数的符号取决于除数 除数为正，则余数符号和被除数相同；如果除数为负，则余数符号与被除数相反

//2_移位操作符
//左移位:<<		右移位:>>
//注意这里的移位移的是二进制  这里先介绍：原码 反码 补码
//我们知道 数据在计算机中是用二进制存储的 一个整型数据占据四个字节 也就是32bit位 而数据的二进制表示有原码 反码 补码三种
//原码：首位为符号位 0表示这是个正数 1表示这是负数 而后面的31位用二进制表示该整数即可 如7的原码:0000..0111
//反码：在原码的基础上 首位不变 其他位取反
//补码：在原码的基础上+1
//注意：只有负数才有原码 反码 补码的区别 正数的原码反码补码都是同一个二进制序列
//而整型数据在内存中统一采用的是补码！因为原码反码在进行减法时无法正确处理符号位 也就是说原码反码在进行加法和减法运算时需要进行转换
//而采用补码可以简化硬件设计 因为补码能同时进行加法和减法运算而不需要转换即可正确输出结果
//此外 补码还解决了0的符号位问题 避免了像原码补码那样对+0,-0的分开处理 实现了通用一套硬件电路进行正负数的加减法运算
//而-------->移位操作符 就是在数据对应补码的基础上进行移位操作  移位操作就是将整个补码序列进行左右移动
//注意移动后要保持32位序列 所以左移就丢弃左边的二进制数 在右边通过补0进行补全；右移同理 
//但是！移位操作符不会改变操作数本身的二进制序列和十进制的数值 只是我们可以通过移位操作来获取该操作数移位后的数值和二进制序列
//这种关系类似于 int b=a-1;将a-1的值赋给b并不会改变a本身的值
