#define _CRT_SECURE_NO_WARNINGS//VS中使用scanf函数必备宏定义 scanf_s为VS专属
#pragma warning(disable:4996)//避免使用scanf时报 返回值被忽略;
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <windows.h>
#include <time.h>
#include <math.h>
#include <stdbool.h>

//hello world!
//int main()
//{
//	printf("hello world!\n");
//
//
//	return 0;
//
//}


//C语言的基本数据类型：
// char				字符型
// short			短整型	  【整
// int				整型
// long				长整型
// long long		更长的整型	型】
// float			单精度浮点数【实型		//关于float类型的初始化 注意0.0或者3.14等等浮点数，编译器都会默认为double类型
// double			双精度浮点数  即浮点型】//所以需要写作 float f=0.0f; 即在初始化值后面加个f 编译器就会按照float型进行初始化
// void				无值型（空值型）
// 
//布尔类型 bool
//注意布尔类型是在C99标准之后才有的 用于定义表示真假值的变量 例如:
//bool flat = true;也就是1
//		或	= false;也就是0
//bool类型仅这两种取值！并且使用bool类型要包含<stdbool.h>这个头文件


//C语言各基本数据类型的大小：
//int main()
//{
//	 printf("%zu\n", sizeof(char));		1
//	 printf("%zu\n", sizeof(short));	2
//	 printf("%zu\n", sizeof(int));		4
//	 printf("%zu\n", sizeof(long));		4
//	 printf("%zu\n", sizeof(long long));8
//	 printf("%zu\n", sizeof(float));	4
//	 printf("%zu\n", sizeof(double));	8
//	 printf("%zu\n", sizeof(void));		0
//
//	 return 0;
//}


//全局变量和局部变量同时出现时：
// int main()
//{
//	int a = 10;
//	void iu();
//	{
//		int a = 1;
//		printf("iu-->%d\n", a);
//	}
//	return 0;
//} //变量的赋值遵循就近原则----局部优先级高于全局


//全局变量和局部变量的作用域
//int main()
//{
//	void u();
//	{
//		int a = 1;
//		printf("u-->%d\n", a);
//
//	}
//	int a = 2;
//	printf("%d\n", a);
//
//
//	return 0;
//}


//常量之 数值常量
//int main()
//{
//	int a = 10;
//	printf("%d\n", a);
//	return 0;
//} 这种常量又称为字面常量


//常量之由 const 定义的常变量：
//int main(void)
//{
//	printf("hello world!\n\n");
//
//
//	return 0;
//
//}
//int main()
//{
//	const int a = 20;//const修饰导致a变为常变量
//	printf("%d\n",a);
//
//	return 0;
//}


//常量之由 #define 定义的标识符常量：
//#define max 100//此处 max 为define定义的标志符常量
//#define iu "abcdef"//此处两个宏定义都没有规定 形 可见后面被定义的内容不定
//int main()
//{
//	printf("%d\n", max);
//	int a = max;
//	printf("%d\n", a);//可见其可当作常量来使用
//	printf("%s\n", iu);//%s s:string 即打印字符串
//
//	return 0;
//
//
//}


//常量之 枚举常量
//enum Color
//{
//	RED,【枚举
//	GREEN,
//	BLUE  常量】
//}					   //R G B作为枚举类型Color的三种可能取值,这些可能取值便是枚举常量
//int main()
//{
//	int num = 10;
//	enum Color c = RED;//此处为对变量c的赋值操作 而赋的值便是枚举常量之一
//	int RED = 20;//容易发现，无法再次对枚举常量进行赋值或是更改操作
//	return 0;
//}


//基础求和程序
//int main()
//{
//	int num1 = 0;
//	int num2 = 0;
//	scanf("%d %d", &num1, &num2);// & 为取地址符 即获取已定义变量在内存中的位置 注意:此处为空格分隔:有时为逗号分隔！
//	int sum = num1 + num2;
//	printf("%d\n", sum);
//	return 0;
//
//
//}


//语句末尾勿忘  ； ！
//



//关于数组以及数组内字符串长度的计算规则：
//#include <string.h>;//strlen可计算字符串长度 但是需要此头文件！
//strlen的返回值是 size_t 也就是无符号整型(unsigned int)
//int main() //F10+调试+窗口+监视 可进行查看程序在内存中的存取等操作
//{
//	char arr1[] = "abc";//char[4]
//	char arr2[] = { 'a','b','c' };//char[3]
//	char arr3[] = { 'a','b','c','\0' };//char[4]
//	char arr4[4] = { 'a','b','c' };//char[4]  此处为不完全初始化数组
//	//这说明 \0 仅在读取字符串时出现  是意为字符串读取到此为止的转义字符  而若读取单个字符形式的组合则无需\0 故内存占位将少一个字节
//	//可是注意！在 printf函数中打印截至到\0为止 若无\0 则将出现错误:
//	printf("%s\n", arr1);
//	printf("%s\n", arr2);//报错
//	printf("%s\n", arr3);//正常
//	printf("%s\n", arr4);//输出为"abc"  此处为不完全初始化数组的打印结果
//
//	printf("%d\n", strlen(arr1));//字符串长度为3
//	printf("%d\n", strlen(arr2));//字符串长度为35
//	printf("%d\n", strlen(arr3));//字符串长度为3
//	printf("%d\n", strlen(arr4));//字符串长度为3  此处为不完全初始化数组的字符串长度计算结果
//	//关于不完全初始化：若数组中的元素数目未达到定义数组的数目，则编译器会自动将未初始化的元素赋值为0；
//	//0--数字零  即数值为0（不因编码方式而变化）
//	//"0"--字符零  ASCII码值为48
//	//"\0"--转义字符零  ASCII码值为0
//	//可见 "\0"与被赋值的0（数字0）对于计算机而言是几乎等效的
//	
//	//占位符表示:这里需要占一个位置给后面的数据使用
//	//这说明 \0占内存但不计入字符长度                       补充 拉丁字母长度为一字节  汉字长度至少为二字节
//	 
//	          //                                                        补充 常用打印类型(占位符类型)有：
//           //                                           %d        整型 (有符号)             
//			//										      %s        字符串
//		   //											  %c        字符型
//		  //											  %f        float型
//		 //												  %lf       double型
//	    //												  %zu       size of类型的返回值
//	   //												  %p		以地址型打印(打印出对应地址)
//	  //												  %u		无符号整型(即无负数)
//	return 0;
//	//	printf()参数与占位符是一一对应关系，如果参数有n个占位符,则printf()的参数就应该有n+1个;
//	//printf()允许限定占位符的最小宽度 %5d表示这个占位符的宽度至少为5位，若不足，则对应的值前面会添加空格，若超出，则正常输出
//}//如若用 %*d则表示自动取占位符宽度;


//打印的标准模式：
//printf ("%...\n",",,,");
// 
// printf("%...\n"); 为字符串专属简写    建议统一写成标准模式；


//转义字符					释义
//\?							在书写连续多个问号时使用，防止他们被解析为三字母词
//\'							用于表示字符常量'
//\"							用于表示一个字符串内部的双引号
//\\							用于表示一个反斜杠，防止它被解释为一个转义序列符
//\a							警告字符，蜂鸣
//\b							退格符
//\f							进纸符
//\n							换行
//\r							回车
//\t							水平制表符  效果类似于 Tab
//\v							垂直制表符
//\ddd						    ddd表示一到三个八进制数字  编译器会将其转换为十进制后对应ASCII信息交换表里的字符后输出
//\xdd						    dd表示两个十六进制数字     同上
//\0							字符串的结束符
//备注：转义字符看似占多个字节 实则不然 均仅占位一个字节 为一个字符  如\t看似可打印出四个空格 实则是为单字符  示例如下


//存在转义字符的字符串长度计算
//int main()
//{
//	printf("%d\n", strlen("\ta"));   //长度为2
//	printf("%d\n", strlen("\x22 b"));//长度为3    注意 " "空格（占位符）也占了一个字节长度 
//
//	/*此处常见错误示范之-- > 试问下列字符串长度？*/
//    printf("%d\n", strlen("c:\test\628\test.c"));//长度为十四  易误以为是十三
//	printf("%d\n", strlen("abc\666"));//长度无法计算  易误以为是四
//	此处涉及到两个关于进制转义字符的常见错误 
//	1 前者\628 欲取八进制 但第三位却超过了8 故编译器自动判定为\62 而8则作为一个字符 这为错误一；
//	2 后者\666 欲取八进制 但换算为十进制后过大 超出了127 故无法在ASCII表中找到对应字符 故无法计算字符串长度 这位错误二；
//
//	return 0;
//} 


//注释
//C语言注释风格 /* */		不可嵌套 就近原则
//C++语言风格注释 //		可嵌套


//常见选择语句				常见循环语句
//1_ if  else                 while循环
//2_ switch                   for循环
//3_                          do...while循环


//if 语句示例
//int main()
//{
//	int a = 0;
//	printf("%s\n", "你想成为程序员大牛吗？");
//	printf("%s\n", "请选择1/0");
//	scanf("%d", &a);
//	if (a == 1)
//	{
//		printf("%s", "那就继续加油吧!");
//
//	}
//	else
//	{
//
//		printf("%s", "请不要忘记你为何开始！\n请选择1");
//	}
//
//	return 0;
//}
//"="表示赋值操作		"=="则表示判断或者比较两个值是否相等，是一种关系运算符


//while 语句示例
//int main()
//{
//	int line = 0;
//	printf("%s\n", "努力学习计算机知识");
//	while (line < 20000)
//	{
//		printf("练习敲代码:%d", line);
//		line++;
//
//		if (line >= 20000)										//常用技巧之--在打出函数名后按"Tab"键可快速生成{ }大括号;
//		{
//			printf("%s\n", "学习永不停止！");
//		}
//		else
//		{
//			printf("%s\n", "继续练习！");
//		}
//	}
//	return 0;
//}


//hhhhhhhhhhhhhhhhhhhhhh 是时候强调这件事情了少年！！！！！！
//没错！！！
//你个傻卵儿老是中英文字符搞混了还看不出来！！！ tmd报错的时候就使劲难受吧！
//尤其是这个 中文的"；" 和 英文的";"
//汗流浃背了吧老弟hhhhhhhhhhh
//其实关键就在于...字符所占的长度不同***
//仔细观察吧少年   line++


//C语言结构类型:
//1_顺序结构
//2_选择结构（分支结构）
//3_循环结构


//数组基础
//int main()
//{
//	int sss[3] = { 1,2,3 };
//	有序排列的同类数据元素的集合称为数组  (存储作用)
//				   0 1 2
//	为区分数组的各个元素 各分量对应着其数字编号 即下标 下标默认从零开始 如上;
//	printf("%d\n", sss[2]);
//	"[]"内自动识别为下标 而不是数字本身 若超出下标范围则输出错误，并且其中只能是常量不能是变量（VS不支持变长数组所致）；
//  事实上C99标准之前，数组的大小都是用常量或者常量表达式来指定的
//  而C99之后支持了变长数组，允许数组的大小是变量，但这种指定方式的数组是不能初始化的；
//  数组的初始化：int sss[3]={1,2,3};		不初始化：int sss[3];
//	return 0;
//}


//数组基础...
//int main()
//{
//	int ddd[7] = { 1,2,3,4,5,6,7};
//	int i = 0;
//	while (i <3)
//	{
//		i = i + 1;
//		printf("%d\n", ddd[i]);
//		i = i + 1;
//	}
//	while()内的真假用于判断是否进入循环
//	注意i++在前和在后对输出结果的影响是不同的！
//	return 0;
//
//}


//比大小并输出的两种写法--1 直接型
//int main()
//{
//	int a = 0;
//	int b = 0;
//	scanf("%d %d", &a, &b);
//	if (a>b)
//	{
//		printf("%d\n", a);
//
//	}
//	else
//	{
//		printf("%d\n", b);
//	}
//	return 0;
//}

//比大小并输出的两种写法--2 间接型
//int Max(int x, int y)
//{
//	if(x>y)
//		return x;
//	else
//		return y;
//}
//int main()
//{
//	int a = 0;
//	int b = 0;
//	scanf("%d %d", &a, &b);
//	int c=Max(a, b);
//	printf("%d\n", c);
//	return 0;
//}


//错误示例之 if语句中 的return后返回值必须为常量；
//int Change(int z)
//{
//	if (z > 0)
//	{
//		return -1;
//	}
//
//	else
//	{
//		return 0;
//	}
//
//}


//求一个函数 使得 当x>0时输出-1；当x<0时输出1；当x=0时输出0；
//int change(int a)
//{
//	if (a<0)
//	{
//		return 1;
//	}
//	else if (a==0)//注意 =是赋值   ==是判断等号两边是否相等；
//	{
//		return 0;
//	}
//	else
//	{
//		return -1;
//	}
//
//}
//
//int main()
//{
//	int a = 0;
//	scanf("%d", &a);
//	int b = change(a);
//	printf("%d", b);
//	return 0;
//}


//操作符
//算术操作符：
//=  -  *  /  %
//加 减 乘 除 取模
//除
//int main()
//{
//	int a = 7/2;
//	printf("%d\n", a);
//	//结果为3；这是因为当a b 同为整数时  计算机进行的是整数除法；而只有当其中至少有一个浮点数时才会进行浮点数除法！！！！！；
//	float a = 7/2;
//	printf("%f\n", a);
//	//更改打印形式后发现；输出错误；这说明除法种类会影响打印结果；
//	int a = 7/2.0;
//	printf("%d\n", a);
//	//仅更改除法种类后发现 仍然打印不出浮点数结果；可见二者缺一不可！！！；
//	float a = 7/2.0;
//	printf("%f\n", a);
//	float a = 7.0/ 2;
//	printf("%.1f\n", a);
//	//若要保留到浮点后几位  可如上操作 保留一位为.1 两位...
//	float a = -7 / 2.0;
//	printf("%.1f\n", a);
//	//可见该操作符适用于含有负数的操作
//	return 0;
//}
//取模
//int main()
//{
	//int b = 7 % 2;
	//printf("%d\n", b);
	//取模操作符意为取余数 且该操作符两端仅能为整数 
	//int b = -7 % 2;
	//printf("%d\n", b);
	//可见该操作符能进行含负数的操作 负数取模结果的正负号由第一个运算数的正负决定;
	//return 0;
//}


//赋值操作符
//=	+=	-=	*=	/=	%=	&=	^=	|=	>>=	<<=
//int main()
//{
//	int a = 0;
//	a = 10;
//	a = a + 1;
//	printf("%d\n", a);
//	int a = 0;
//	a = 10;
//	a += 1;
//	printf("%d\n", a);//上下二者等效  即a+=便是a=a+...	类比可知后面的操作符的含义；
//	return 0;
//}


//双目操作符：需要两个操作数的操作符，如+ - * /等；
//单目操作符；仅需要一个操作数的操作符，相关如下：
//逻辑反操作符：
//首先！C语言中规定 变量值为零则为假 其余则为真
//int main()
//{
//	int a = 0;
//	if (a)//if (ture)
//	{
//		printf("%s\n", "hehe");
//	}
//	int a = 0;
//	if (!a)
//	{
//		printf("%s\n", "hehe");
//	}
//	可见逻辑反操作符可改变C语言中逻辑的真假判断，从而影响输出结果；
//	return 0;
//}
//负值-以及正值+：
//int main()
//{
//	int a = 10;
//	int b = -a;
//	int c = +a;
//	printf("%d\n", b);//-意为取值为负
//	printf("%d\n", c);//+意为+() 意义不大
//	return 0;
//}
//sizeof 操作符：
//注意！！！size of 是单目操作符 不是函数；
//int main()
//{
//	int a = 0;
//	printf("%d\n", sizeof(a));//4
//	printf("%d\n", sizeof(int));//注意 若为此写法 则无法取去括号来写；
//	printf("%d\n", sizeof a);//省略a的括号后结果仍然计算正确 可见其不是函数(是函数则不能去除a的括号，否则报错)
//	return 0;
//}
//int main()
//{
//	int ass[10] = { 0 };//后续自动不完全初始化为数值0；
//	printf("%d\n", sizeof ass);//40;可见sizeof 计算的是整个数组的大小 单位为字节;  注意\0 是在字符串中出现！而非此处的(整型)数组
//	printf("%d\n", sizeof ass[0]);//4 []内的数字对应下标 数组下标从零开始 [0]代表第一个数组内的元素；
//	printf("%d\n", sizeof ass / sizeof ass[0]);//10 可如此求出数组内元素的个数
//	return 0;
//}
//前后置++ --
//int main()
//{
//	int a = 10;
//	int b = a++;//此处为后置++ 即++操作在欲++的变量之后 后置++遵循先使用 后++的原则!
//	printf("%d\n", a);//11
//	printf("%d\n", b);//10
//	//int c = d++;//注意 此处这种先使用标识符 再定义的方式是错误的! 并不是前置++！
//	int d = 20;
//	int e = ++d;//这才是正确的前置++的写法 遵循先++后使用的原则！
//	printf("%d\n", d);//21
//	printf("%d\n", e);//21
//	return 0;
//}
//-- 原理等同
//(类型) 强制类型转换
//int main()
//{
//	int a = 3.1;
//	printf("%d\n", a);// 3 “初始化”: 从“double”转换到“int”，可能丢失数据 
//	//由此看出 1-哪怕赋值为浮点数 编译器仍按整型输出 且程序依然能跑；2-哪怕赋值为一位 编译时也默认按double型转换为int型
//	//为何为最终仍然为int? 因为最开始定义变量时在内存中获取的是int型的存储位置 故哪怕赋值为浮点数 仍然会被转化为整型
//	int b = (int)2.1;//(类型)可以强制转换其类型 此处 double-->int
//	printf("%d\n", b);//不再报这个错误：“初始化”: 从“double”转换到“int”，可能丢失数据
//	return 0;
//}


//关系操作符
// > < = <= >=		!=				==
//				用于测试不等于  用于测试等于
//着重！== 判断两端是否相等 
//int main()
//{
//	int a = 0;
//	if (a=1)//if语句()括号内会判断是否为真	a初始化为0 本为假 但是当赋值a=1后为真 故打印成功
//	{
//		printf("hehe\n");
//	}
//	return 0;
//}
//int main()
//{
//	int a = 0;
//	if(a==1)//a赋值为零 ==测试不等于1 故判断为假 打印失败
//	{
//		printf("hehe\n");
//	}
//	return 0;
//}


//逻辑操作符
//&& 逻辑与-并且...
//|| 逻辑或-或者...


//三目操作符（条件操作符）
//int main()
//{
//	int a = 1;
//	int b = 2;
//	int c = (a > b ? a : b);//条件操作符的示例：exp1 ? exp2 : exp3
//	int d = (a < b ? a : b);//			第一表达式是在进行判断；若一为真 则该操作符输出结果为就近原则 输出二；反之输出三
//	printf("%d\n", d);
//	printf("%d\n", c);
//	return 0;
//}


//逗号表达式
//特点：从左向右 依次计算 取最后表达式的结果为整个表达式的结果；
//int main()
//{
//	int a = 1;
//	int b = 2;
//	int c = (a + b, a * b, a - b);
//	printf("%d\n", c);//值为-1 满足特点；
//	return 0;
//}


//下标引用操作符
//[]是下标引用符 arr 和 3 是[]的操作数
//int main()
//{
//	int arr[10] = { 1,2,3,4,5,6,7,8,8,10 };
//	printf("%d\n", arr[3]);//4
//	printf("%d\n", 3[arr]);//4 可见[]对操作数的处理是一视同仁的
//	int n = 3;
//	printf("%d\n", arr[n]);//4 可见在[]利用下标引用已定义数组中的参数时 []中可以为变量 但是定义数组时[]中不能有变量
//	return 0;
//}
// 
// 
// 函数调用操作符：（） 括号不可省 且括号内外均为该操作符的操作数！


//关键字：C语言本身内置的 而非编写者可以自创的： 编写者定义变量名时也不可以用关键字来命名
//举例一：auto  auto一般被省略掉	define不是关键字！！！
//当定义局部变量时 进入局部变量的作用域时，局部变量自动开始生效；处作用域时自动失效 这便是 auto的作用效果：自动


//变量的命名
//1_应当有实际意义 并且编写者能看懂
//2_名字必须是字母 数字 下划线 组成 不能有特殊字符 不能以数字开头
//3_不能是关键字


//typedef:对类型重命名
//typedef unsigned int uit;//将无符号整型重命名为 uit;
//int main()
//{
//	uit a = 1;
//	int b = 1;
//	printf("%d\n", a);//1
//	printf("%d\n", b);//1
//	//两者打印结果相同；可见被typedef重命名之后的类型与命名前等效 只是更改了写法
//	return 0;
//}
////有时重命名 形如下所示
//typedef struct Node
//{
//	int data;
//	struct Node* next;
//}stde;//此时对于结构体类型 struct Node重命名为stde 此两种仅为不同情况下的写法；


//void test()
//{
//	//int a = 1;//结果：2，2，2...
//	static int a = 1;//结果：2，3，4...
//	a++; 
//	printf("%d\n", a);//为何先使用后加加打印结果为2？因为在a++的a之前并无使用a的地方 而语句从左往右继续执行 故到打印时已加一
//}
//int main()
//{
//	int i = 0;
//	while (i<10)//i为循环次数
//	{
//		test();
//		i++;
//	}
//	return 0;//为何循环打印出来是十个2 而不是2，3...？
//			 //这是因为建立函数test时 其中设置的变量a为局部变量 具有生命周期 每次进入作用域时都重新开始了
//}
//关于 static：
//1_使用static声明的变量是静态变量 初始值为0，其作用域被限制在其被定义的源文件中 生命周期为整个程序开始到结束;
//1-1 static修饰局部变量的时候改变了局部变量的存储位置 从内存的栈区改为了静态区 即原先的局部变量改变为静态(局部)变量了;
//1-2 static修饰全局变量的时候改变了其 外部链接属性-->内部链接属性 此工程的其他源文件便不能再使用这个全局变量了；
//2_使用static声明的函数是静态函数 作用域被限制在其被定义的源文件中 其不能被其他文件中的函数调用；
// 注意：函数本来也有外部链接属性的 若要调用具有该属性的函数或全局变量 只需在其前面加上 extern即可！
//3_使用static声明的代码块是静态代码块 其只会在第一次被使用时执行一次 之后不会再次执行.


//关于内存的分区:
//1_栈区(static) :存放局部变量(包括const定义的局部变量) 形参 返回值;先入后出	由编译器自动分配释放
//2_堆区(heap) : 调用函数 : malloc()和free();									由程序员分配内存和释放
//3_全局(静态)区(分为 .bass 以及 .data) :存放全局变量和静态变量;
//4_常量区(.rodata) :存放字符串 数字等常量以及const修饰的全局变量;
//5_代码区(.text):存放程序的执行代码 也可能有字符串常量和define定义的常量存放.


//计算机存储体系：
//1_寄存器(集成到CPU上)
//2_高速缓存(cache)
//3_内存
//4_硬盘
//越往上，与CPU交换信息的速度越快，空间越小，造价越高； 实际使用时信息会有自下往上的信息传递；
//关键字register:(寄存器)
//int main()
//{
//	register int a = 1;//register意为 建议将该变量的位置存放在寄存器中使其读写和运行速度更快 但只能是建议！
//	printf("%d\n", a);
//	return 0;
//}


//#define 不仅可以定义标识符常量 还可定义宏
//#define ADD(x,y) ((x)+(y))
//ADD为宏名 宏是宏 而函数是函数
//(x,y)中的x,y为宏的参数，参数是无类型；
//而((x)+(y))为宏体
//需要知道的是 宏是完成替换的 当下文ADD返回参数给宏时 宏自动给对应参数完成替换 如：
//int c = ADD(a, b)-- > int c = ((a)+(b));
//int main()
//{
//	int a = 10;
//	int b = 20;
//	int c = ADD(a, b);
//	printf("%d\n", c);
//	return 0;
//}


//指针***
//1_内存
//首先：计算机中程序的运行都是在内存中运行的
//为提升内存的使用效率 内存被划分成一个个小的内存单元(类似于excel表格形式) 每个内存单元的大小是一个Byte
//同时每个内存单元有自己的编号 称为该内存单元的地址 地址为便于编号采用16进制数表示(只是一种数据表示方式)
//补充 在计算机内部二进制数据转换为16进制数据最直接 最快捷 占用存储空间最小；
//在32位电脑中 可能的内存地址(寻址空间)数有2^32次方个 换算如下：(地址为32bit位 二进制 故有2^32次方种可能)
//2^32=4294967296Byte
//	=4194304Kb
//	=4096Mb
//	=4Gb 即4Gb个
//而在64位电脑中 可能的内存地址达到了惊人的16384Pb个 但受实例的限制 目前windows仅能支持达到512Gb的内存
//换算关系:
//8 bit =1Byte
//1024 Byte=1Kb
//1024 Kb=1Mb
//1024 Mb=1Gb
//1024 Gb=1Tb
//1024 Tb=1Pb


//2_查看内存地址
//int main()
//{
//	int a = 10;//向内存申请4个字节，用于存储10; 但实际上哪怕变量a要了四个字节单位 a仍然是放在第一个字节单位中;
//	printf("%p\n", &a);//0x 0000 00C5 D28F FC74 这便是内存地址之一(第一个字节的)(随机)	0x表示这个数据是16进制表示的
//	printf("%p\n", a);//000000000000000A	 而这是内存中的数据(16进制的 10) 
//	return 0;
//}
//也可直接查看内存地址调用等信息:F10+调试到末行+调试+窗口+内存+&a即可
//如上操作结果左侧为内存地址 中间为内存中的数据 右边为不准确的内存数据的文本解析


//查看字符类型的ascii码值：
//int main()
//{
//	char a = 0;
//	scanf("%c",&a);
//	printf("%d\n", a);//以整型输出字符时会默认输出ascii码值！
// //反之亦可以利用给定数值当作ascii码值反向输出对应字符：
//	int b = 0;
//	scanf("%d", &b);
//	printf("%c\n", b);//以字符型输出数字时会默认输出ASCII码表中对应字符！
//	return 0;
//}


//3_指针及指针变量
//int main()
//{
//	int b = 20;////注意 内存地址用编号表示 而地址也被称之为指针 而存储指针的变量就是指针变量
//	int* p = &b;//int是因为p存储着b的内存地址&b,而指向的数据为int类型的b  *说明p是指针变量
//	char c = 'w';//上下的p q均为指针变量的名字 而int* 和 char*为其类型声明
//	char* q = &c;//此处c为char型 故存放指向c地址的指针变量q应表示为char*型		对应关系！
//	//指针变量的意义？
//	*p=10;//解引用操作符，和取地址符在一定程度上是互逆关系：即通过p中存放的地址找到p所指的对象 *p就是p指向的对象
//	printf("%d\n", b);//10; 利用指针变量可以很容易地通过地址指向找到最初变量的地址 并且进行数据更改！
//	return 0;
//}注意：口头上经常就将指针变量叫为指针
//指针变量的大小？
//int main()
//{
//	printf("%zu\n", sizeof(char*));//8
//	printf("%zu\n", sizeof(short*));//8
//	printf("%zu\n", sizeof(int*));//8
//	printf("%zu\n", sizeof(long*));//8
//	printf("%zu\n", sizeof(long long*));//8
//	printf("%zu\n", sizeof(float*));//8
//	printf("%zu\n", sizeof(double*));//8
//	//为何结果全为8? 不管任何类型的指针都是在创建指针变量 指针变量是在存放地址的 指针变量的大小取决于存放地址时需要的空间
//	//而64位计算机机器内的地址均为64bit 也即8字节 故指针变量的大小为8字节
//	//值得一提的是 x86是32位处理器 其寄存器是32位的	x86只是由于其CPU架构为x86类型而得名
//	return 0;
//}


//结构体 struct
//C语言给了程序员自定义类型的能力 结构体便是一种自定义类型
//结构体使得C语言能够描述复杂类型 因为结构体是把单一类型组合在一起用的做法
//struct stu//创建结构体类型stu
//{
//	char name[20];
//	int age;
//	char sex[10];
//	char tele[12];//这四个均为结构体的成员(变量)
//};
//
//void print(struct stu* ps)//此处无需计算出值后返回而是直接打印 故使用void表明无返回值 ()内表明参数为结构体类型stu类型的指针变量ps
//{
//	printf("%s\n %d\n %s\n %s\n", (*ps).name, (*ps).age, (*ps).sex, (*ps).tele);
//	//*ps意为解引用指针变量ps以找到s ()是为了提升优先级 因为其优先级低于.和->操作符;'.'仍然是从结构体对象(变量s)中引用成员...
//	printf("%s\n %d\n %s\n %s\n", ps->name, ps->age, ps->sex, ps->tele);//->也是操作符 意为从结构体指针变量中引用成员...
//	//可以理解为 ps指向变量s的地址 而->则更进一步指向name的地址从而引用成员name 即指向的结构体的...
//	//->  =  (*). 此二者是等效的
//}
//
//int main()
//{
//	struct stu s = { " 张三",18,"男","12345678" };//由int ...类型可创建变量联想 结构体类型也是类型 故此处创建结构体类型变量s ："图纸"-->"房子"
//	//注意 结构体类型列出成员时均为{} 而创建相应变量时也用{} 而{}内" 张三"等是在进行相应的初始化 也即整个变量的初始化
//	//printf("%s\n %d\n %s\n %s\n", s.name, s.age, s.sex, s.tele);//.是操作符 意为从结构体对象(变量s)中引用成员... 即结构体对象的...
//	//printf("%s\n %s\n %d\n %s\n", s.name, s.sex, s.age, s.tele);//可见结构体变量创建后对于其成员的调用不必按照创建结构体类型时的顺序！
//	print(&s);//print是一个函数 ()内意为引用s的地址作为函数print的入口参数
//	return 0;
//}


//拆分输入输出
//int main()
//{
//	int a1, a2, a3 = 0;
//	scanf("%3d %3d %3d", &a1, &a2, &a3);//照此输入后 输入的整型数据会每三位数字一份放入到a1 a2 a3中 超出三位也只取三位
//	printf("%d %d %d", a1, a2, a3);
//	return 0;
//}
//注意：%m,nf表示输出的浮点数，m为宽度(域宽)，n为小数点右边数位(精度),未指定n时，隐含的精度为6(因为是单精度浮点型)；
//同时，在字符串的拆分输入输出时：
//int main()
//{
//	char a[10];
//	gets(a);//gets()可以读取含空格的字符串 而scanf不能 但是要用gets()时只能输入字符数组类型的变量；并且！gets()和scanf均不能检测越界
// 补充puts()的用法，puts()与前两个函数的区别是puts()在输出完后会自动换行；
//	printf("%6.3s", a);//要求输出前三个且占六列 %m.ns: 输出m列 但只取字符串字符串中左端n个字符 空格从左往右补位；
//	return 0;//注意 无论是浮点数还是整型还是字符串若写为%-m.n...则表示空格从右往左补位 但若是n>m 则会自动取n值以保证完整性；
//}
//注意：
//int main()
//{
//	char a[10];//由于此处要输入的是字符串数据 故不能用 char a=0;来进行初始化！而是应采用字符数组来放置字符串
//	scanf("%s", &a);
//	printf("%s\n", a);
//	return 0;
//}


//现在 恭喜你到达C语言初阶的世界!
//回顾：C语言语句分类：
//1_表达式语句
//2_函数调用语句
//3_控制语句
//4_复合语句
//5_空语句
//接下来要学习的是其中的控制语句
//前面提到C语言是一种结构性程序设计语言 三大结构便是 顺序 选择 循环
//而控制语句用于控制程序的执行流程，以实现程序的各种结构方式，它们由特定语句定义符组成 C语言提供了9种控制语句
//分成三类如下：
//1_分支语句(条件判断语句)： if语句  switch语句；
//2_循环执行语句：do while语句 while语句 for语句；
//3_转向语句：break语句 goto语句 continue语句；


//if语句：
//语法结构：1
//if(表达式)//若表达式的真值为1，则输出下列语句；
//	语句；
//int main()
//{
//	if (1==2)
//	{
//		printf("%s", "hello");//未输出"hello"
//	}
//	if (1<2)
//	{
//		printf("%s", "hehe\n");//输出"hehe"
//	}
//	int a = 1;
//	if (a=2)//编译器会将这里理解为对a的赋值 所以无论怎样都是"true"  上一步则会被理解为对变量a的初始化
//	{
//		printf("%d", a);//仍然输出了2  因为变量的使用是遵循就近原则的 
//	}
//	return 0;
//}
//语法结构：2
//if (表达式)
//	语句1；
//else
//	语句2；
//与上文同理，只是if和else后面跟的语句都默认只有一条 若要使用多条语句 需用{}括起来 VS中在if后使用Tab键可自动补全 {}表示代码块
//语法结构：3
//if (表达式)
//	语句1；
//else if (表达式)//else if可以多次使用以表明多分支
//	语句2；
//else
//	语句3；//适用于多分支结构
//int main()
//{
//	int age = 0;
//	scanf("%d", &age);
//	if (0 < age < 28)
//	{
//		printf("%s\n", "童年/少年/青年");
//	}
//	else if (28 < age < 50)
//	{
//		printf("%s\n", "中年");
//	}
//	else if (50<age<65)
//	{
//		printf("%s\n", "中老年");
//	}
//	else
//		printf("%s\n", "老年");
//	return 0;
//}//有意思的是 你将会发现不管输入多少 都会输出第一个结果 这是因为C语言并不完全支持数学中的写法
//在数学中 a<x<b 和 x>a且x<b 是等价的 但是在C语言中会认为这两者是 或 的关系 因此 我们需要对程序进行一些修改
//int main()
//{
//	int age = 0;
//	scanf("%d", &age);
//	if (age > 0 && age < 28)//在C语言中 &&表示并且，||表示或者；
//	{
//		printf("%s\n", "童年/少年/青年");
//	}
//	else if (age > 28 && age < 50)
//	{
//		printf("%s\n", "中年");
//	}
//	else if (age>50 && age<65)
//	{
//		printf("%s\n", "中老年");
//	}
//	else
//		printf("%s\n", "老年");
//	return 0;
//}//注意编译器当读取到if内为真时便不会再编译else后面的语句 反之若if内为假便不会编译if后面的语句
// //修改后程序运行正常 可见在C语言中要写成 x>a且x<b 的形式 才能被编译器正确处理；


//悬空else:
//int main()
//{
//	int a = 0;
//	int b = 2;
//	if (a == 1)
//		if (b == 3)
//			printf("%s\n", "haha");
//	else
//		printf("%s\n", "hehe");
//	return 0;
//}//猜猜打印结果？"hehe"吗？			哈哈 啥也没有
//这是因为 if语句是和就近的else匹配的 二者反之也是 所以第一个if是语法结构1的类型，又因为a\=1 所以下面的整个if else都不会执行
//这里容易误以为第一个if和else对齐从而以为会输出"hehe",但事实上 else本身位置是悬空的，与是否对齐无关 类似的悬空情况有很多
//亦得 写代码时要注意其可读性 并尽可能地用{}将代码块括起来 


//预防出现bug小技巧之一：
//在需要使用 == 判断左右两边是否相等时将变量放右边 常量放左边(常左变右)
//int main()
//{
//	int a = 10;
//	if (a=1)//不小心输入错误 少写了一个= 变成了赋值(无所谓真假)
//	{
//		printf("%s", "hehe");//仍然打印了"hehe" 这是因为编译器并不会对其if()内赋值操作报语法错误  这便导致了出现bug的潜在风险
//	}
//	return 0;
//}
//我们不妨写为：
//int main()
//{
//	int a = 10;
//	if (1=a)
//	{
//		printf("%s", "hehe");
//	}//编译器报错了 因为将一个变量赋值给一个常量是不被允许的！  在这种情况下 编写者便能在第一时间内发现这个错误
//	if (1==a)//修改后
//	{
//		printf("%s", "hehe");
//	}//这便于避免bug的出现
//	return 0;
//}

//:判断一个数是否是奇数 分支语句示例如下
//int main()
//{
//	int a = 0;
//	scanf("%d", &a);
//	if (1==a%2)
//	{
//		printf("%d为奇数",a);
//	}
//	else
//	{
//		printf("%d是偶数",a);
//	}
//	return 0;
//}


//输出1-100中的所有奇数:
//int main()
//{
//	int i = 1;
//	while (i<100)
//	{
//		if (1==i%2)
//		{
//			printf("%d\n", i);
//		}
//		i++;
//	}
//	return 0;
//}//这便是经典的循环+分支嵌套！
//纯循环写法:
//int main()
//{
//	int i = 1;
//	while (i<100)
//	{
//		printf("%d\n", i);
//		i += 2;//i+=2即i=i+2;
//	}
//	return 0;
//}

//在讲switch之前，紧急补充关于char类型的知识：
//int main()
//{
//	char a = -1;
//	unsigned char b = -1;
//	signed char c = -1;
//	printf("%d\n%d\n%d\n", a,b,c);//-1 255 -1
//	char d = 128;
//	unsigned char e = 128;
//	signed char f = 128;
//	printf("%d\n%d\n%d\n", d, e, f);//-128 128 -128
//	return 0;
//}//这里涉及到几个很古老的疑惑：
//为什么这里能用整型打印字符型数据？	为什么字符型数据打印为整型时会有有符号和无符号之分，并且打印效果迥异？
//char 类型声明用于存储字符，但是其本质上是整型的一个分支
//这是因为计算机并不能理解字符，所以在存储字符时实际存储的是整型数据，所以在打印时可采用%d,%c两种打印类型
//当采用%d类型时，则直接打印该字符在存储时使用的整型数据(与ASCII码表相对应)
//若采用%c类型时，则会在打印时再根据ASCII码表转换回整型对应的字符
//由此观之，char类型实质上就是整形的分支之一，所以甚至可以直接定义整型变量时使用char来声明
//但是这里又要注意
//1_在使用char类型创建变量时，存在 有符号和无符号之分，这里的有无符号实质是指一个字节(8bit)中首个个bit是否是符号位之分
// 若首bit是符号位，则这个字节大小由后7个二进制数表示，首位仅表示正负:1为负，0为正；			范围:-128到127
// 若首bit不是符号位，则字节大小由8个二进制数共同表示，显然此时能表示更大的数，但不能表示负数；	范围:0到255
//2_如上所示，有符号位字符类型写作 (signed) char;而无符号位字符类型则写作 unsigned char;前者的signed被大部分编译器认为可以忽略
//而上面程序中的无符号字符变量b因为存储整型范围限制，所以无法打印出负数
//而上面的有符号字符变量d和f也因为...，所以无法打印出>127的数
//有趣的是，对于无符号位char类型而言，全体整数都是由0-255的区间构成的，即从-无穷到+无穷是由无数个该区间一前一后紧挨着填充满的
//用样的，计算机对与有符号位char类型也是这么理解的，只不过区间是-128到127；
//由此，你便可以类比理解到 unsigned int,unsigned short int.etc以及用字符型来打印整型数据最后得到字符的原理
//最后，还需补充:无论是有还是无符号位char类型，能存储的整型数据区间大小都是256，但是ASCII码表仍然只能对应0-127
//补充一个定义 char类型定义一个字符类型的变量，而''内则称之为字符常量；


//switch 语句:是一种多路选择结构，通常用于替代一系列嵌套的if-else语句，使代码更清晰易懂;
//int main()
//{
//	switch (整形表达式)//()内是switch的开关，也就是分支结构执行的入口
//	{
//	case 整型常量表达式://整型常量表达式包括字符常量！理由见上
//		语句;//当case后的整型常量表达式==switch中的整型表达式时,程序才会进入这个分支，从而执行后面的语句;
//		break;//break是该分支结构结束的出口,若没有 break,则程序进入此分支之后的分支都会挨个进入并且执行;
//			 //需要知道的是 break能力是有限的 当存在嵌套switch时 内层的break只能跳出内层switch分支 而想要跳出外层则需要外层break才行
//	case...
//		语句;
//		break;
//	default://当switch结构中的case无一匹配时，程序便会进入default,并执行语句,然后退出switch分支结构;
//		语句;
//		break;//似乎哪怕没有default,分支结构依然会到此为止,但是default及后面语句的存在才可以确保程序至少会有一个默认行为！
//	//default语句可以放在switch中的任意一个位置...补充 case语句并不要求顺序 也就是说可以随意摆放case default位置 只要符合语法规则
//	}
// 
//	return 0;
//}
//下面是一个典型的switch语句:
//int main()
//{
//	int day = 0;
//	scanf("%d", &day);
//	switch (day)
//	{
//	case 1:
//		printf("星期一\n");
//		break;
//	case 2:
//		printf("星期二\n");
//		break;
//	case 3:
//		printf("星期三\n");
//		break;
//	case 4:
//		printf("星期四\n");
//		break;
//	case 5:
//		printf("星期五\n");
//		break;
//	case 6:
//		printf("星期六\n");
//		break;
//	case 7:
//		printf("星期天\n");
//		break;
//	default:
//		printf("输入错误\n");
//		break;
//	}
//
//	return 0;
//}
//如果想要在输入1，2，3，4，5时 输出工作日;6，7时 输出周末;可以按照如下操作:
//int main()
//{
//	int day = 0;
//	scanf("%d", &day);
//	switch (day)
//	{
//	case 1://即不使用出口break，任其执行下面的分支路径，直到break为止即可;
//	case 2:
//	case 3:
//	case 4:
//	case 5:
//		printf("weekday\n");
//		break;
//	case 6:
//	case 7:
//		printf("weekend\n");
//		break;
//	default:
//		printf("error\n");
//		break;
//	}
//
//	return 0;
//}
//补充:switch是可以嵌套的，但请注意,break仍然只和相应的的case对应,例如在嵌套的switch中，遇见break仅仅只会跳出当前嵌套，而不是整个分支结构


//while循环:
//int main()
//{
//	int i = 1;
//	while (i<=10)
//	{
//		//if (5==i)
//		//{
//		//	break;//打印结果为1234;可见在while循环中的break可以直接终止整个循环，这点与switch语句不同；
//		//}
//		if (5==i)
//		{
//			continue;//打印结果同样为1234但是右边|光标一直闪烁，这是因为程序一直在运行，还远未结束
//		}//可见continue可以跳过本次循环后面的代码，直接去判断下一次循环是否进行 由于i++在后 故i一直=5 陷入了死循环
//		printf("%d", i);
//		i++;
//	}
//
//	return 0;
//}
//int main()
//{
//	int i = 0;
//	while (i <= 10)
//	{
//		i++;
//		if (5==i)
//		{
//			continue;//为什么这次continue打印出了后面的数并且没有死循环? 这是因为i++在前，从i>5开始if分支便不执行了 于是循环继续 直到i>10为止
//		}
//		printf("%d", i);//打印出了123467891011
//	}
//
//	return 0;
//}


//int main()
//{
//	int ch = getchar();
//	//关于getchar():意为获取一个字符,注意仅为一个字符(人为输入的)，将其放置到变量ch中,类似于scanf();
//	//为什么用int不用char? 首先请注意，对于计算机而言，字符的实质就是ascii数字编码，因此getchar的返回值便是整型数据
//	//其次，当遇到读取错误或者读取到EOF(end of file)时,函数会返回一个'EOF',而EOF本质上是define定义的-1，故也需要整型返回 综上两点
//	//其实若只是常规用来读取字符，char类型也可以，因为char类型也是整型的一种
//	//但是考虑到可能会返回EOF，而EOF(整型的-1)用char类型返回长度会溢出，故综合考量下使用int类型为不会出错的选择
//		putchar(ch);
//	//关于putchar() 类似于printf() 输出int类型数据，但是要输出的字符常常使用unsigned char长度传递(8位)，故实际上这些字符被视为char类型处理；
//	return 0;
//}


//补充：为什么getchar 和scanf是截然不同的两种输入函数？
//因为getchar能够读取\n(空格)和回车，而scanf不能；当键盘的输入数据传递到缓冲区后,若是scanf，则会取走前面的数据而留下\n
//而这将导致在下一次读取时，缓冲区会有残留的数据(空格或回车等)，在一些需要重复读取输入的问题中将可能出错，比如请确认密码时；
//而putchar则不会出现这种情况 当然也可以用putchar来清空缓冲区然后再进行重复的读取输入;
//示例如下:
//int main()
//{
//	char password[20] = { 0 };
//	int ch = 0;
//	printf("请输入密码:\n");
//	scanf("%s", password);
//	printf("请确认密码(Y/N):\n");
//	ch = getchar();//此处采用scanf()读取同样会出错，原因如上；
//	if (ch == 'Y')
//		printf("确认成功\n");
//	else
//		printf("确认失败\n");
//	return 0;
//}
//修改后:(利用getchar来清空缓冲区)
//int main()
//{
//	char password[20] = { 0 };
//	int ch = 0;
//	printf("请输入密码:\n");
//	scanf("%s", password);//此处之所以不用&，是因为数组本身就是地址
//	while (getchar() != '\n')//此处用循环getchar()清空而不是单个getchar()是为了以防在输入的密码中间有空格或者制表符存在的情况
//	{
//		;			// !=需连写，用于判断等式两边是否不相等
//	}
//	//事实上，scanf也能跳过空格和制表符等继续读取，只需要使用前导空格字符 即scanf(" %s",password);但是这种方式还是会导致缓冲区仍有余留
//	printf("请确认密码(Y/N):\n");
//	ch = getchar();
//	if (ch == 'Y')
//		printf("确认成功\n");
//	else
//		printf("确认失败\n");
//
//	return 0;
//}


//int main()
//{
//	int ch = '\0';//初始化为0也可以，因为'\0'的ascii码值就是0；
//	while ((ch = getchar()) != EOF)//注意，虽然getchar每次仅读取一个字符，但放入循环后便会一直读取,直到读取到\n换行继续等待下一次输入
//	{
//		if (ch < '0' || ch>'9')//此处意为当ch中字符对应的ascii码值 <0或者>9的ascii码值时将跳过此次打印，不会打印出来
//			continue;
//		putchar(ch);
//	}//这段代码的作用便是只打印数字字符，跳过其他字符的打印
//	//注意，含有getchar()的循环(其实是通用的方法...)如何让程序停止？ctrl+c(推荐)或ctrl+z+enter  而shift+esc可关闭过程窗;
//	return 0;
//}


//for循环：
//其实我们不难发现，while循环的主体就是三个部分
//int main()
//{
//	int i = 1;//这是对循环参量的初始化部分
//	while (i<=10)//这是循环的条件判断部分
//	{
//		printf("%d\n", i);
//		i++;//这是循环的调整部分
//	}
//	return 0;
//}//这三个部分其实就是while循环的主体，任意一个部分的改变都可能导致完全不同的循环
//可是这三个主体过于分散 不利于可能的修改 由此 我们开始for循环的新大门
//for语句:
//for (size_t i = 0; i < length; i++)//注意 各部分之间用;分隔开
//{
	//由这个for范例可以看出，for括号内其实就是三个主体部分 size_t是变量类型 i=...是初始化值 i<...是条件判断 i++为调整部分
//}
//接下来使用for来实现上一个程序
//int main()
//{
//	for (int i = 1; i <=10; i++)//肉眼可见地利于修改了
//	{
//		printf("%d\n", i);
//	}
//	//printf("%d\n", i);	注意 将打印语句放在for循环之外时 i便是一个未定义的标识符，可见由for循环定义的变量只能在for之内用
//	return 0;
//}//当然，for循环中同样有break and continue并且效果一致
	//但是for中continue满足时并不会跳过后面的调整部分，这与while中不同(while中会跳过i++从而陷入死循环)
//for循环的使用建议:
//1_不要在for循环体内修改变量，以防for循环失去控制；
//2_建议for语句的循环控制变量的取值采用[ )前闭区间后开区间的写法; i<=9是闭区间写法，而i<10则是开区间写法，这样的代码可读性更高
//3_注意，for循环中初始定义的变量的作用域仅限于for循环以内，当走出for之后，编译器便不再认for以内的任何变量值


//for循环的一些变种:
//int main()
//{
//	for  (; ;)//for循环中的三个部分均可以省略，但是不建议初学者这样操作，容易出错;
//	{
//		printf("hehe\n");//这里陷入了死循环;因为判断部分省略了之后这个判断就会恒成立，循环也就会一直进行;
//	}
//	return 0;
//}
//接下来是一个常见的错误引例:
//int main()//不省略
//{
//	int i = 0;
//	int j = 0;
//	for (int i = 0; i < 10; i++)
//	{
//		for (int j = 0; j < 10; j++)
//		{
//			printf("hehe\n");//此时打印了100个hehe 这是因为嵌套for循环的原则是先内后外 只有当内层循环完了之后外层才继续下一次循环
//		}//内层循环完打印十遍hehe，而外层要循环十次，外层嵌套的内层也就要跟着循环十次，故10*10=100;
//	}
//	return 0;
//}

//int main()//省略
//{
//	int i = 0;
//	int j = 0;
//	for (;i< 10;i++)
//	{
//		for (;j< 10;j++)
//		{
//			printf("hehe\n");//结果是打印了十个hehe;为什么呢?
//		}//这是因为对于j而言当j等于10第一次跳出循环时，后续再进入到这个循环时因为j没有初始化为0，所以j依然等于10导致
//	}//也就是说外层循环依然循环了10次，但是内层循环实际上只循环了第一次，后续几次根本没有进入内层循环
//	return 0;
//}
//提醒! for(int a=0;a<10;a++)中int a=0的写法是C99标准之后才支持的，一些较古早的编译器可能只支持for(a=0;a<10;a++)这种写法;

//事实上，可以使用多个变量来控制循环:
//int main()
//{
//	for (int x = 0,y=5; x < 3 && y>4; x++,y++)//这里便同时使用了两种变量来控制循环的开始与结束;
//	{
//		printf("hehe\n");
//	}
//
//	return 0;
//}

//int main()
//{
//	int i = 0;
//	int j = 0;
//	for (int i = 0,j=0; j=0; i++,j++)//请仔细观察！
//	{
//		printf("hehe\n");//为什么循环0次？ 因为判断条件为j=0;意为将0赋给j;0为假 故判断结果是不进入循环;
//	}
//
//	return 0;
//}

//do while循环:
//形如 :
//do
//	循环语句
//while(表达式)
//可见do while循环的特点是 至少先完成一次循环，然后再判断是否进行下一次循环;
//int main()
//{
//	int i = 1;
//	do
//	{
//		printf("%d\n", i);
//		i++;//注意 和while for 一样，若想要在循环中执行多条操作语句，需要用{}括起来;否则程序运行错误或者死循环！
//	}
//	while (i < 11);
//	return 0;
//}
//int main()
//{
//	int i = 0;
//	do
//	{
//		if (4==i)
//		{
//			//break;
//			continue;
//		}
//		printf("%d\n", i);
//		i++;
//	} while (i<10);//0 1 2 3后接空白死循环
//	//在do while语句中，break and continue和在while语句中具有相同效力
//	while (i < 11)
//	{
//		if (4 == i)
//		{
//			continue;
//		}
//		printf("%d\n", i);
//		i++;
//	}//0 1 2 3后接空白死循环
//	//这两者死循环的都因为后置i++，导致i一直等于4，然后一直被跳过...
//	for (int i = 0; i < 11; i++)
//	{
//		if (4==i)
//		{
//			continue;
//		}
//		printf("%d\n", i);
//	}
//	//在这三种写法中，仅有for循环成功达到了预期
//	//这也是为什么 在平时使用时最常用的便是for循环 提高容错 而且书写更方便;
//	return 0;
//}

//运用循环:
//计算阶乘 考虑递归或者循环;
//int main()
//{
//	int n= 0;
//	int t = 1;
//	scanf("%d", &n);
//	for (int i = 1/*i为1或者2均可*/; i <= n; i++)
//	{
//		t = i * t;//这里的t初始化必须均为1，这样1*i才会等于i本身, t的意义就是存储乘积并且迭代;
//	}
//	printf("%d\n", t);
//	return 0;
//}//这种方法不能实现大数运算，因为会溢出，只有模拟实现大数运算，才能解决内存溢出问题;

//计算阶乘之和;
//int main()
//{
//	int n = 0;
//	int t = 1;
//	int s = 0;
//	scanf("%d", &n);
//	for (int i = 1; i <=n; i++)
//	{
//		t = t * i;
//		s = s + t;
//		//需要注意 for循环中定义的变量是有其作用域的 当内外同时定义了一个变量时 一旦离开for 变量值就回归外部定义值了
//	}
//	printf("%d\n", s);//而s之所以能出for而且值为循环后的结果 是因为s不是for循环定义的变量 只是经过了循环
//	return 0;
//}
//另一种写法;
//int main()
//{
//	int n = 0;
//	int i = 1;
//	int sum = 0;
//	//这里可以再定义一个变量，就可以将这个程序改写为输入决定输出型;
//	for (int n = 1; n<=3 ; n++)
//	{
//		int p = 1;//此处添加上初始化;
//		for (int i = 1; i <=n; i++)
//		{
//			p *= i;//打印结果为15 原因是此处p没有在外层循环被初始化，导致内层循环计算单个阶乘时出错(p值一直叠加)
//		}
//		sum += p;
//	}
//	printf("%d\n", sum);//添加初始化后打印结果为9;
//	return 0;
//	//需要注意的是，这种嵌套for的写法时间和空间复杂度都提高了，因为每次计算一个阶乘后下一个都要从头开始，很浪费资源
//	//当我们采用上一个写法时，新阶乘只需要在前一个基础上*i就可以了，而原阶乘又可以直接拿去相加，节省了时间和空间
//}

//关于调试(Debug)
//需要知道，VS并不只是一个编译器，而是一个IDE，其中当然也包含了调试器
//在上方 项目 的下面可以看到Debug，这表示当前是调试版本，里面包含调试信息，程序员可以在里面进行各种调试，而后者则不能调试;
//而点击后可以选择为Release，也就是发布版本，这往往是进行了各种优化使得程序在代码大小和运行速度上都是最优解的，是利于发布和用户使用的版本
//常用的调试是 点按F10/F11 程序会自动按照流程走 F10与F11的区别在于后者可以帮助我们进入函数内部而前者会跳过函数代码块
//因此常用F11 点按后程序的执行情况便一句一句清晰可见 通常还需要用到监视窗口以看到变量值的变化，或者查看内存的地址变化等等
//还有的调试是F9(设置断点)+F5(执行调试)，不过这需要鼠标点按 故较少用
//年轻人，多做调试吧，提高自己的纠错能力，这也是代码水平的一部分！


//在一个有序数组中查找某个数n:
//int main()
//{
//	int i = 0;
//	int arr[] = { 1,2,3,4,5,6,7,8 };
//	int sz = sizeof(arr) / sizeof(arr[0]);
//	int k = 35;
//	for (int i = 0; i <=sz; i++)
//	{
//		if (arr[i]==k)
//		{
//			printf("找到了\n%d\n", arr[i]);
//			break;
//		}
//		if (i == sz)
//		{
//			printf("没找到\n");
//		}
//	}
//	return 0;
//}//这种低级算法好处是哪怕数组内部是无序的也同样可以使用,但是这本身比较浪费有序数组的条件
//接下来我们来讲二分查找:
//何为二分查找?
//经典猜数字:
//1到100请猜一个数，如何才能更快? 
//50 大/小 25/75 大/小 ...
//上述就是二分查找 这带来的是肉眼可见的速度提升，相较于枚举而言;下面我们来学习一下其代码表示;
//仍然用于在一个有序数组中查找某个数;
//int main()
//{
//	int arr[] = { 1,2,3,4,5,6,7,8,9 };
//	int sz = sizeof(arr) / sizeof(arr[0]);
//	int k = 0;
//	scanf("%d", &k);//k为欲查找数
//	int left = 0;//意为左逼近
//	int right = sz - 1;//意为右逼近，sz-1是因为当有sz个数时尾数的下标为sz-1
//	while (left<=right)
//	{
//		//int mid = (left + right) / 2;//如若担心mid的值越界(整型范围)，可改写为:
//		int mid = left + (right - left) / 2;//这种写法下允许了更大值和左右均遇到奇数时的查找,虽然仍然有越界可能;
//		if (arr[mid]<k)
//		{
//			left = mid + 1;//此处为何一定要+1?
//		}
//		else if (arr[mid]>k)
//		{
//			right = mid - 1;//此处为何一定要-1?
//		}
//		else
//		{
//			printf("找到了\n下标是%d\n", mid);
//			break;
//		}
//	}//若上面的循环中left right不加减1则当出现.5时，系统会保留为整数，当遇到边界值时,left/right会一直被赋为同一个值 导致死循环
//	if (left>right)//若不加减1 也同样无法出现left>right的情况 只能是陷入相等的死循环
//	{
//		printf("找不到匹配项\n");
//	}
//	return 0;
//}

//试着打印一个字符从两端到中间逐渐显现出的效果
//#include<windows.h>//这里为了展示渐进效果，需要使用sleep函数，而sleep需要从这个头文件蕴含的库函数中调用;
//#include<stdlib.h>//这里为了实现每次渐进仅展示一行的效果调用了系统命令 system("cls") 而调用system这个库函数需要包含这个头文件
//int main()
//{
//	char arr1[] = "Welcome to code world!!!";//arr1是欲显现的字符数组;
//	char arr2[] = "########################";//arr2是显现过程即开始过程挡住的字符数组(即渐进效果)
//	int left = 0;
//	int right = strlen(arr2 - 1);//用arr2/1均可，因为上下长度一致，strlen计算字符串长度会包含字符串中间的空格 -1是因为right是下标
//	//int right = sizeof(arr2 - 2);//此处-2是因为sizeof包含了"\0"故而计算出的个数会多一个;
//	while (left<=right)
//	{
//		arr2[left] = arr1[left];
//		arr2[right] = arr1[right];
//		printf("%s\n", arr2);
//			Sleep(1000);//Sleep 意为休眠多久多久，括号内的数字为多少分之一秒 此处为千分之一秒;S要大写 注意
//			system("cls");//system是一个库函数，可以执行系统命令 表示 clear screen 清屏
//		left++;
//		right--;
//	}
//	printf("%s\n", arr2);//这里是为了在while最后一次打印后不清屏而不得不添加的补充打印 目的仅仅是为了打印最后一次
//	return 0;
//}

//接下来试试 设计一个程序，使得用户可以输入密码并实现验证(<=3次) 假定密码为 abc123;
//#include<string.h>//本程序用到了 strcmp 调用此函数需要调用该头文件 考虑到此源文件开头已经包含了此头文件 此处便不再赘述;
//int main()
//{
//	int i = 0;
//	char password[20] = { 0 };//初始化一个字符数组 注意要确定字符数目的上限 否则程序不会正常结束;
//	printf("请输入密码\n");
//	for (i=0 ; i < 3; i++)//此处for不使用int i =0;
//	{
//		//这是因为一旦一个变量在for之中被声明 那么该变量的作用域将限制于for内 意为:这是一个在for循环内新创建的一个局部变量
//		//哪怕在外界已经声明了一个重名变量 当离开for时，该变量的值会立刻回归到外界声明的值;
//		//而外界声明了但for内不声明的变量的值便是可以带出for循环的了 此处便是为了带出i的值以使当三次输入错误时 最后的if语句能正常实现
//		scanf("%s", password);
//		if (strcmp(password,"abc123") == 0)//strcmp 意为string compare 用于字符间的比较 实质是比较ASCII码值之和
//		{
//			printf("密码正确\n");
//			break;//若无此跳出 则会陷入死循环
//		}// 当括号内前者大于后者时 strcmp返回一个正值 反之则返回一个负值(多数编译器对应返回的就是1和-1) 相等时则返回0;
//		else
//		{
//			printf("密码错误\n");
//		}
//		
//	}
//	if (3==i)
//	{
//		printf("三次密码均输入错误 请明天再试!\n");
//	}
//	return 0;
//}


//猜数字游戏
//思路:
//1 电脑随机生成一个数;
//2 玩家来猜一个数;
//3 电脑给出大/小/猜对;
//4 玩完后返回菜单页面,等候下一次选择;

//设计菜单页面:
//void menu()
//{
//	printf("####################\n");
//	printf("###请选择是否游玩###\n");
//	printf("#####  1 游玩  #####\n");
//	printf("#####  0 退出  #####\n");
//}

//设计游戏主体部分:
//void Game()
//{
////	printf("%d\n", rand());//srand是随机数发生器的初始化函数 和rand函数均被放于<stdilb.h>这个头文件中 故使用时需引入该头文件
////	printf("%d\n", rand());//原型: void srand (unsigned int seed) seed相当于一个种子 srand函数根据这个seed设置一个随机起点
////	printf("%d\n", rand());//而rand函数根据这个随机起点 返回一个随机数 范围是0~0x7ffff(32767) 注意 除非给一个变化的种子
////	printf("%d\n", rand());//否则这个随机数就是伪的随机数(多次编译时产生的随机数是一样的)
//	srand(1);//值得注意 rand函数每一次调用时都会查看之前是否调用了srand函数 若调用了 则rand函数会调用srand(seed)来初始化它的随机值
//	printf("%d\n", rand());//若之前没有调用srand 则会默认调用srand(1)来初始化它的随机值
//	printf("%d\n", rand());
//	printf("%d\n", rand());
//	srand(2);
//	printf("%d\n", rand());
//	printf("%d\n", rand());
//	printf("%d\n", rand());
//	srand(3);
//	printf("%d\n", rand());
//	printf("%d\n", rand());
//	printf("%d\n", rand());//由这三次结果可知 当每次输入不同的种子时 产生的每组随机数都是不一样的
//	//那么 接下来问题就变成了如何让srand(seed)中存在一个变化的种子
//}
//接下来介绍时间戳:
//time函数包含于<time.h>这个头文件中
//time函数可以获取当前的系统时间:是指从1970年1月1日零时零分到目前为止所经过时间的秒数累计 也即 时间戳
//可见时间戳就是一个一直都在变化的量
//time_t time(time_t*t); 这是time函数的形式 对于64位处理器 time_t是long int 或者 long long int类型
//该函数提供两种返回方式 返回值或者返回指针参数 当参数为空指针(NULL)时只返回值 而NULL的定义是(void*)0 可见time(NULL)和time(0)是等效的
//看来我们需要使用这个time(NULL) 但是srand()中的种子seed要求是unsigned int 类型 故我们还需要强制类型转换
//即 srand((unsigned int)time(NULL)) 这样便得到了一个变化的种子 接下来我们再来写一下游戏的主体部分试试
//void Game()
//{
//	int guess = 0;//guess用于放置玩家猜的值
//	int ran = rand()%100 + 1;//rand()%100表示的值将不会超过100(取模运算);即0~99 而+1后得到的范围就是1~100之间 范围更加合理了
//	int count = 0;//count用于记录猜的次数;
//	while (1)
//	{
//		printf("请输入数字\n");
//		scanf("%d", &guess);
//		if (guess<ran)
//		{
//			printf("你猜小了 笨蛋\n");
//		}
//		else if (guess>ran)
//		{
//			printf("你猜大了 傻卵\n");
//		}
//		else
//		{
//			printf("恭喜！ 你猜对了！\n共计猜了%d次\n",count+1);
//			break;
//		}
//		count++;
//	}
//}

//int main()
//{
//	int input = 0;
//	srand((unsigned int)time(NULL));
//	//将srand置于这里是因为整个工程中只需要设置一次随机生成数的起点就可以了 并非每次生成随机数都需要设置一次起点
//	//如果是后者 也就是说将这个srand置于Game函数中的话 将导致一旦生成随机数过快(相差不超过1s) 将生成同一个随机数 这是不可取的
//	do
//	{
//		menu();
//		scanf("%d", &input);
//		switch (input)
//		{
//		case 1:
//			Game();
//			break;
//		case 0:
//			printf("退出游戏\n");
//			break;
//		default:
//			printf("输入错误，请重新输入!\n");
//			break;
//		}
//	} while (input);//此处通过输入input的值来判断是否进入下一次循环 准确来说是输入值也就是真假值(0/1/其他) 这个设计很巧妙
//
//	return 0;
//}


//goto 语句 即瞬时跳转语句;
//C语言提供了可以滥用的goto语句和标记跳转的标号;
//但是从理论上来说 goto语句是没有太大实际意义的 因为没有它我们也能轻易写出代码来
//它的两个缺点:
//1_由于goto语句的随意性 导致它可能让整个程序的执行顺序变得混乱 这可能导致更多的bug出现 威胁程序的安全
//2_goto语句无法跳转到单独的函数代码块中 也就是说跳转的位置是受限的
//它的优点:
//goto语句最常用的就是用于跳出深度嵌套结构 比如多重循环 这是break难以达到的效果 因为它只能跳转到上一层循环 但goto却可以跳出整体
//这是一个goto语句的示例:
//int main()
//{
//	char input[20] = { 0 };
//	system("shutdown -s -t 60");//shutdown -s:关机指令 -t:设置关机指令(需要设置时间) 60则是设置的时间
//again:
//	printf("请注意！你的电脑即将在60秒后关机\n若输入:我是猪\n即可取消关机\n");
//	scanf("%s", input);
//	if (strcmp(input,"我是猪")==0)
//	{
//		system("shutdown -a");//-a 表示 -annul 即取消指令
//		printf("已取消关机:>\n");
//	}
//	else
//	{
//		goto again;
//	}
//	return 0;
//}//不难发现 这段代码也可以使用循环来写 也就是用循环主体替换again后面的内容即可


//函数:
//在C语言中函数的定义与数学中略有不同
//在C语言中 
//函数是一个子程序，是一个大型程序的某部分代码，由一个或多个语句块组成，负责完成某项特殊的任务，具有一定的独立性;
//特征:一般会有输入参数并有返回值，提供对过程的封装和细节的隐藏，这些代码通常被集成为软件库。
//分类：1_库函数 2_自定义函数
//为什么会有库函数?
//库函数是C语言后续发展来的 可以提高写代码的效率和代码的标准化程度 还可以降低出现bug的可能;
//在www.cplusplus.com中可以查看库函数列表
//通过这个网站我们可以很迅速地学习到各类库函数的用法
//简单总结一下，C语言常用的库函数有:
//IO函数
//字符串操作函数
//字符操作函数
//内存操作函数
//时间/日期函数
//数学函数
//其他
//当然，请注意使用这些库函数时必须要包含能调用这些库函数的头文件
//自定义函数也由以下几个部分组成：
//ret_type_(返回值类型...可以是void 即不返回) fun_name(函数名)(paral,*参数 参数最好写上类型！)
//{
	//statement;//语句项
//}//{}括起来的内容是自定义函数的主体部分 也即函数的实现
//需要知道 主体程序传递给函数的参数是实参 而函数名括号内的变量是形参 形参是实参的一份临时拷贝
//所以当自定义函数无返回值时 函数部分对形参的修改不会影响实参
//但是请注意 如果主程序传递到函数的是变量的地址 那么此时改动形参和改动实参的效果就可能是一样的
//因为当用一个指针变量来存放这个传递过来的地址后 一旦对这个这个指针进行解引用 那么此时就可以通过这个指针指向的地址直接对原变量(实参)进行修改
//所以 当我们需要函数对实参进行修改时 就可以传递实参对应的地址 反之则正常使用形参来进行函数操作就可以了
//这里其实也涉及到两种函数调用方式 1 传值调用(后者); 2 传址调用(前者)
//关于实参:
//实参是真实传递给函数的参数 实参可以是常量 变量 表达式 函数等 在进行函数调用时 实参必须要有确定的值 以便把这些值传递给形参
//关于形参:
//形参是指函数名括号中的变量 形参只有在函数被调用的过程中才实例化(分配内存单元) 并且形参在函数被调用完后会自动销毁 故形参只在函数调用的过程中存在
//形参和实参的命名可以相同 也可以不同 这两者的作用域不同 所以无论是否重名都不会互相影响 形参只是实参的临时拷贝

//求100~200之间的素数?(素数指仅能被1和自己整除的数 也就是说2到该数之间没有数可以整除该数)
//int main()
//{
//	int i = 0;//用i表示100~200之间的数
//	int count = 0;//count用于计算素数的个数
//	//for (i = 100; i <= 200; i++)//容易知道 当i>2后的素数必然是奇数 所以我们可以就此从源头上减小计算复杂度
//	for (i = 101; i <= 200; i += 2)
//	{
//			int t = 1;//用t的值来得知该数是否是素数
//			//for (int j = 2; j < i-1; j++)//思考 这里是否也可以简化?是否一定要用2到i-1之间每一个数去除试试?``````答案是否定的！
//			//由数学知识可知 其实我们只需要试到根号下i就可以了 因为根号i已经是除i以外最大的一个因数了
//			//所以我们稍作优化 降低其时间上的损耗;
//			for (int j = 2; j <= sqrt(i); j++)//sqrt 是开方函数 调用该函数需要包含<math.h>这个头文件
//			{
//				int z = i % j;
//				if (0 == z)
//				{
//					t = 0;//t为0则说明该数不是素数
//				}
//			}
//			if (1 == t)
//			{
//				printf("%d ", i);
//				count++;
//			}
//	}
//	printf("\ncount= %d\n", count);
//	return 0;
//}
//接下来我们来看看如何用函数表示
//int ion_prime(int n)//注意函数的命名 ion means is or not 而prime number意为素数 这里简写prime
//{
//	for (int j = 2; j <= sqrt(n); j++)
//	{
//		if (0 == n % j)
//		{
//			return 0;
//		}
//		//else
//		//{
//		//	return 1;
//		////为什么这种写法是错误的?  因为将return 1放入for内的话 这个for并未循环到sqrt(n)为止而是第一次循环就返回1 跳出了函数体
//		//}
//		//else if (1== n % j)
//		//{
//		//	return 1;
//		////不难发现 这种写法也是错误的 因为函数也会在第一次循环时提前结束
//		//}
//	}
//	return 1;//因此 我们直接将返回1放在for循环之外 让for循环完成之后再返回 真
//}
//int main()
//{
//	int i = 0;
//	int count = 0;
//	for (i = 101; i <= 200; i += 2)
//	{
//		if (ion_prime(i))//此处直接用函数返回值来进行真假判断 这是常见技巧
//		{
//			printf("%d ", i);
//			count++;
//		}
//		
//	}
//	printf("\ncount= %d\n", count);
//	return 0;
//}

//写一个函数 判断公元0到2000年之间有多少闰年
//首先我们需要知道 判断闰年有两个判断条件
//1_这个年份可以被4整除 但不可以被一百整除
//2_这个年份如果被400整除 那么这一年也是闰年
//由此 我们可以先写出一个不用函数的写法
//int main()
//{
//	int i = 0;//i表示年份
//	int count = 0;//count表示出现闰年的个数
//	for ( i = 0; i <= 2000; i++)
//	{
//		//if (0 == i%4)
//		//{
//		//	if (0 != i%100)
//		//	{
//		//		printf("%d ", i);
//		//		count++;
//		//	}
//		//}
//		//else if (0 == i%400)
//		//{
//		//	printf("%d ", i);
//		//	count++;//不难发现 这种写法下 满足规则2的闰年其实并没有被打印下来 因为此处的第一二中情况并不是并列关系 换成else也不行
//		//}
//		//if (0 == i%400)//只有这种写法才是并列关系的if 也才能使两条规则同时满足
//		//{
//		//		printf("%d ", i);
//		//	count++;
//		//}
//		//其实这里的两条规则都是 并且 并列 关系的组合 因此我们还可以换种写法 更为简洁
//		if (((0 == i%4)&&(0! = i%100))||(0 == i%400))
//		{
//			printf("%d ", i);
//			count++;
//		}
//	}
//	printf("\ncount=%d\n", count);
//	return 0;
//}
//接下来试试函数的写法
//int ion_leap_year(int year)//leap year是闰年的意思
//{
//	if (((0 == year%4)&&(0 != year%100))||(0 == year%400))
//	{
//		return 1;
//	}
//	else
//	{
//		return 0;
//	}
//	//为什么不在函数内同时完成year的判断和打印？
//	//因为这将导致函数的二功能不够单一
//	//函数的功能越单一 使用时也就越自由 越不用顾虑 在程序封装之后也更好使用
//	//关于函数自定义的一个口诀:高内聚(内部功能完整凝练)	  低耦合(与程序的其他部分关联度要小)
//}
//int main()
//{
//	int i = 0;
//	int count = 0;
//	for ( i = 0; i <= 2000; i++)
//	{
//		if (ion_leap_year(i))
//		{
//			printf("%d ", i);
//			count++;
//		}
//		else
//		{
//			continue;
//		}
//	}
//	printf("\ncount=%d", count);
//	return 0;
//}

//写一个函数 实现整型有序数组的二分查找
//int search(int *arr, int k,int sz)//这里可以直接用指针变量*arr接受 因为数组名就是一个地址(数组的传递是以数组中的首地址来进行传递的)
//{
//	//如果上方采用(int arr[],int k,int sz)的形式其实也是一样的 arr[]看起来是个数组 但里面放的也是指针 因为数组传递过来的就是首地址
//	//但是无论怎样写 sz的值都不能放在函数中进行计算 为什么呢?
//	//这是因为 传递过来的是数组的首地址 那么sizeof(arr)就是arr[]中首位元素所占的内存大小(int 类型占4)也即是sizeof(arr[0])
//	//那么如果sz让这两者相除 结果必然恒为1 left和right也就直接相等了 这显然是不合理的
//	//由此得出/！	我们无法在函数内部去计算一个函数参数部分中数组的大小或者元素个数！
//	int left = 0;
//	int right = sz - 1;
//	while (left <= right)
//	{
//
//		int mid = left + (right - left) / 2;//注意 该语句必须放在循环以内 否则mid就只会赋一次值 后续程序由于arr[mid]不变将陷入死循环
//		if (arr[mid] < k)
//		{
//			left = mid + 1;
//		}
//		else if (arr[mid] > k)
//		{
//			right = mid - 1;
//		}
//		else
//		{
//			return mid;
//			//下面之所以直接接return -1而不是再用一个if(left>right)是因为return优先级远高于break(只能跳出循环)
//			//如果条件满足 那么return在此处就可以直接终止函数(这也是为何此处不用接break)
//		}
//	}
//	return -1;//return -1是因为要做区别 -1绝不可能是返回的下标 但是0却可能是返回的下标
//}
//int main()
//{
//	int arr[] = {1,2,3,4,5,6,7,8,9,10};
//	int k = 0;
//	int sz = sizeof(arr) / sizeof(arr[0]);
//	scanf("%d", &k);//k为欲查找的数 显然k<=10;
//	if (search(arr , k , sz) != -1)//注意 当主体程序传过去数组时 无论哪种传递方式都只能在主程序这边写数组名 不能写arr[]
//	{
//		printf("找到了 下标是：%d\n", search(arr , k , sz));
//	}
//	if (search(arr , k , sz) == -1)
//	{
//		printf("找不到对应下标\n");
//	}
//	return 0;
//}

//有时 真假值的返回也可以采用布尔类型(需引入头文件<stdbool.h>)	例如：
//bool ion_even(int x)//这个函数用于判断是否是偶数(even number)，奇数的英文(odd number)
//{
//	if (0 == x%2)
//	{
//		return true;//也就是 1
//	}
//	return false;//也就是0
//}
////bool类型的返回值只有 true/false两种 这也使得相较于传统的1/0返回值 它显得更美观直接 同时减少了bug出现的可能(有时1/0不好用于返回真假值)
////但是因为它是C99标准之后的产物 同时功用有替代品 所以使用较少 但是若要提升代码可读性 也可以使用bool类型来代替传统的1/0返回真假值
//int main()
//{
//	int i = 0;
//	for ( i = 1; i < 10; i++)
//	{
//		if (ion_even(i))//此处根据布尔类型调用函数的返回值来作为判断依据
//		{
//			printf("%d ", i);
//		}
//	}
//	return 0;
//}

//写一个函数 每调用一次函数 num的值就+1
//第一种写法 传址调用
//int num_(int* p)
//{
//	(*p)++;//注意此处*p必须加括号 否则调用顺序会出错
//}
//int main()
//{
//	int num = 0;
//	num_(&num);//每调用一次 num_ num的值就会直接加一
//	printf("%d\n", num);
//	return 0;
//}
//第二种写法 传值调用
//int num_(int n)
//{
//	return ++n;
//}
//int main()
//{
//	int num = 0;
//	num=num_(num);//这种写法就是通过在函数中来进行++的操作后返回值又放到num中来实现要求的
//	printf("%d\n", num);
//	return 0;
//}

//函数的嵌套调用
//函数是允许互相调用的 但是不允许嵌套定义
//int ad(int x)
//{
//	return ++x;
//}
//int zs(int n)
//{
//	return ad(n);//这便是函数的嵌套调用 每一层函数之间依然是平等关系
//}
//int main()
//{
//	int i = 0;
//	zs(i);
//	printf("%d\n", zs(i));
//	return 0;
//}
//int add(int x, int y)
//{
//	return x + y;
//}
//int sub(int x, int y)
//{
//	return x - y;
//}
//接下来来看一种错误写法
//int add(int x, int y)
//{
//	return x + y;
//	int sub(int x, int y)//这种写法就是错误的了 因为函数不可以嵌套定义:一个函数中不能再去定义另外一个函数
//	{
//		return x - y;
//	}
//	//如果要实现函数的嵌套调用 至少对函数要先定义 再嵌套调用
//}
//int main()
//{
//	int x, y = 0;
//	scanf("%d %d", &x, &y);
//	printf("两数之和是 %d\n", add(x, y));//注意加减乘除的命名 加 addition 减 subtract 乘 multiply 除 divide
//	printf("两数之差是 %d\n", sub(x, y));
//	return 0;
//}

//函数的链式访问 (实现依赖于函数的返回值)
//链式访问 意为用前一个函数的返回值作为后一个函数的参数
//接下来看一个经典的链式访问
//int main()
//{
//	int i = 43;
//	printf("%d", printf("%d", printf("%d", i)));
//	//猜猜打印结果？
//	//为什么打印结果为4321？
//	//需要知道 printf函数的返回值是 打印字符的数目
//	//根据链式访问原理 最内层的printf返回值--打印字符(43)的数目--2 作为中间printf返回值--打印字符(2)的数目--1 又作为最外层printf打印值
//	//由此 得到了43 2 1的数据
//	return 0;
//}
//注意 当函数不写返回类型时 系统默认返回int型 但这是很不规范的代码 
//同样也不要有返回类型的函数结果不返回值(此时大部分编译器会默认返回函数中最后一条指令执行的结果) 这些都是不规范的代码写法
//注意一下的写法
//int main(void)//这里的void写法并没有错 只是想明确说明 main函数不需要参数 以避免有些ide错误地给main放置了参数
//	//事实上 main有三种参数: int argc,char *argv[],char *envp[] 这三种参数都有实际意义 只不过一般情况下编译器默认main是不需要参数的
//	//但是这种被默认的执行程度会稍弱于明确强调void 只是说在大多数情况下我们无需担心这一点 所以可以直接省略void
//{
//	printf("hehe\n");
//}

//函数的声明和定义：
//函数声明就是告诉编译器有一个什么样的函数是长什么样的 但是这个函数是否真的存在 函数声明决定不了(需要函数的定义)
//并且函数的声明一般出现在函数的使用之前 要满足先声明后使用 如果将函数声明放在使用后面 编译器就会报一个警告"函数...未定义..."(能运行但是)
//函数的声明和函数的主体可以分开
//比如 可以先在主函数之前写 int ion_prime(int x) 但是函数主体可以放在主函数之后写
//函数的声明一般要放在头文件中的
//函数的定义是指函数的具体实现，交代函数的功能实现
//我们知道
//int ion_prime(int x);//这是函数的声明
//接下来这一块是函数体 函数体和函数所声明的部分的组合才是函数的完整定义
//{
//	for (int i = 2; i < sqrt(x); i+=2)
//	{
//		if (0 == x%i)
//		{
//			return 1;
//		}
//	}
//	return 0;
//}
//接下来具体阐述为什么说函数的声明一般要放在头文件中
//总结起来就是：
//1_为了模块化和可维护性： 
//将函数声明放在头文件中可以帮助代码模块化，使代码更易于维护。通过在头文件中声明函数，可以清晰地了解库或模块提供了哪些功能，以及如何使用它们。
//2_为了避免重复定义：
//如果不使用头文件，当在多个源文件中引用相同的函数时，每个文件都会包含相同的函数声明，这可能导致重复定义错误。使用头文件可避免这种情况，因为源文件只需要包含一次头文件即可。
//3_为了便于扩展： 
//如果要更新函数原型，只需更新一次头文件，所有引用该函数的源文件都会受益于更新，而无需逐个修改。
//事实上 当我们进行真正的程序开发时
//为了更好地进行团队协作以及实现模块化开发 我们往往是将一个程序分为多个源文件同时进行开发的 在最后才实现程序的整体封装
//而这时如果我们要自定义一个函数 我们常常将这个函数的声明放到一个头文件中去 然后再将函数的定义部分放到另外一个源文件中去
//只要我们需要调用这个函数 我们就只需要写下	例如#include"ion_prime.h"	这个程序就会根据这个引用头文件中的声明找到对应函数的定义
//然后对这个函数进行实现
//意义?
//这里简单介绍一种情况下将自定义函数的声明和定义分开放在不同文件的意义
//当程序员A写了一个APP时 他想将该APP卖给B公司赚钱 但是他又不能直接将源码一股脑都交给B公司(可能代码被对方骗到手后就翻脸不认人了)
//于是他可以选择将自定义函数的声明放在一个头文件中 再将定义放在另一个源文件中 含有主体程序的源文件就不涉及到该函数定义部分了
//然后将含有函数定义的项目fun(含fun.h)编译成静态库fun-->fun.lib 静态库中都是二进制编码 很难轻易被反编码为原先的代码
//这时他再将该静态库和对应的fun.h以及主体源文件一同卖给B公司即可 B公司通过fun.h(函数声明)就可以了解到该函数是如何使用的
//然后B公司再在主源文件中导入静态库: #pragma comment(lib,"fun.lib")  后就可以正常使用该程序中的函数了(虽然他无法得知函数具体是如何实现的)
//可以看到这种处理方法 极大地保护了代码的安全 同时满足了代码对于迁移使用的需要


//！！！ 函数的递归
//递归是程序调用自身的编程技巧 只需要少量的代码就能描述出多次重复的计算 递归的主要思考方式就是：大事化小
//实现递归的两个条件
//1_存在限制条件 当满足限制条件后 递归函数就不再继续
//2_每一次递归调用之后都会越来越接近这个限制条件
//引入... 请写出一段代码 使得它能接受一个整型值(无符号),并按照顺序打印它的每一位 如输入1234 打印 1 2 3 4
//int main()
//{
//	//unsigned int a1,a2,a3,a4= 0;
//	//scanf("%1u %1u %1u %1u", &a1, &a2, &a3, &a4);//输入 1234		//%1u表示每次只读入一位数据并依次存储到对应的变量中去
//	//printf("%u %u %u %u\n", a1, a2, a3, a4);//打印1 2 3 4
//	//这是由前面的关于打印格式的知识所知的 但很显然 当输入123时这段代码便不能正常运行了 
//	//于是我们想到了取模运算
//	unsigned int a = 0;
//	scanf("%u", &a);
//	while (a)//通过a的值来作为判断依据 最后a=0则跳出循环
//	{
//		printf("%d ", a % 10);//通过取模运算 得到每个数的尾数
//		a = a / 10;//再通过除法运算(整数除法 最后得到的数必是0) 将每次除后的整数部分赋给a(其实也就是a的前几位)
//	}//但是这样打印的结果是倒过来的:< 咋办捏
//	//简单粗暴的思路:把每次取模得到的值放到另一个创建的数组中去 然后再从末尾往前用一个for打印(每次i--)即可
//}

//下面这种对于取模的妙用也是可以实现的 别称 首位剥离法 而上面的思路是末尾剥离法 这两种是常见的对于取模的化用 合成首尾剥离法
//int main()
//{
//	unsigned int num = 0;
//	scanf("%u", &num);
//	int temp = num; //temp用于保存原始值
//	int count = 0; //count用于计算数字的位数
//	while (temp > 0) 
//	{
//		temp = temp / 10;
//		count++;
//	}
//	temp = num;
//	for (int i = count - 1; i >= 0; i--)
//	{
//		int j = pow(10, i);//调用pow需要包含<math.h> pow(a,x)的返回值是a^x次幂
//		printf("%d ", temp / j);//首位剥离法<打印的是除法结果 末尾剥离法却是取模结果> 依次是--> 1 (234) ->2 (34) -> 3 4 ->4
//		temp = temp % j;// temp-->以1234为例 temp=1234->234->34->4
//	}
//	return 0;
//}//不过如果我们还是想要让思路和代码呈现更简洁的话 那接下来就要请出今天的主角--递归函数了

//！！！递归函数的中心思想-->大事化小 一个递归函数的实现代码往往不会超过6行！
//void print_order1(unsigned int n)
//{
//	if (n>9)//规则一 递归函数需要有限制条件<这个条件是为了当n的位数减小到个位时及时停下 不至于停下过早 也不至于过晚>
//		//每次调用函数都会在栈区申请空间 如果没有这个限制条件递归函数就会一直递进深入 最后出现Stack overflow(栈溢出) 最终程序崩溃!
//	{
//		print_order1(n / 10);//规则二 每一次递归调用都会更接近这个限制
//	}
//	//捋捋思路：
//	//递归要将大事化小 前面我们采用末尾剥离法时 发现该思路是可行的就是顺序有误
//	//如果我们可以让数据从小到大<1 12 123 1234>的顺序挨个取模<1 2 3 4>的顺序就出来了
//	//而递归函数的作用就是将数据由大化小(通过不断调用函数本身 但是执行不同n值的整数除法来实现 直到个位数为止)
//	//此时数据已经按照由小到大的层级排好了<1位 12位 123位...>然后我们再让其每一层都取模并且打印一次然后一层层回归到外层函数即可
//	//其中规则一是当n是个位数时就不再继续递归<限制> 规则二是每一次递归都会让这个数的位数减少一 该数也会不断逼近个位数
//	//这 就是递归函数！！！ 
//	//递归递归 其实就是两个部分 -->先递进深入 再回归向上
//	printf("%d ", n % 10);
//}
//int main()
//{
//	unsigned int num = 0;
//	scanf("%u", &num);
//	print_order1(num);//这里命名为print_order1意为 这个函数的功能就是print 但要按照order 每次打印 1 个 即print_order1
//	return 0;
//}

//接下来 我们来试着实现以下 strlen 函数 即计算字符长度
//int my_strlen(char* p)//这里用数组形式作为形参也行 即 char brr[]也可以
//{
//	int count = 0;
//	while((*p) != '\0')//这里之所以能够直接比较字符而没有调用strcmp是因为根据指向地址直接用字符本身<'a'...>来比较了(本质ASCII码值)
//			//而之前比较字符数组和 "abc123"是否相等 因为涉及到调用数组内所有字符这么一个过程 才需要用到strcmp函数
//			//事实上 普通的字符(串)都可以直接进行比较的！
//	{
//		count++;
//		p++;
//		//这里的指针p++与常规++不同的是 原本p中存放的是arr[0]的地址 p++后就直接将其中的地址更换为arr[1]的地址了
//		//也就是说p++对应的其实是arr[0]->arr[1]  p指针指向的对象也就成了数组中第二个字符了
//		//注意！无论这个指针指向的对象是什么类型 或者说这个数组是什么类型 p++的效果都是如此 这是语法规定的！
//	}
//	return count;
//}
//int main()
//{
//	char arr[] = "abc";
//	int c = my_strlen(arr);
//	printf("%d\n",c);
//	return 0;
//}

//如果这个题目 是 在不创建临时变量的情况下 模拟实现strlen函数
//注意 以上方法的my_strlen函数中实际上创建了 count这个用于计数的临时变量 如何在不创建临时变量的情况下实现？
//int my_strlen(char* arr)
//{
//	if (*arr != '\0')//递归的限制
//	{
//		return 1 + my_strlen(arr+1);//每一次递归都会更接近该限制 这是递归的必备条件！！！
//		//注意 这里千万不能用arr++;arr++会陷入死递归！ 推荐写为arr+1 因为++arr改变了arr的值 arr+1只是改变了函数识别到的地址
//		//递归 如果首元素不是'\0';就返回1 并且进入下一个递归函数中 如果该递归到下一层仍然不是'\0'开头就再+1 反之+0
//		//再注意！ 递归调用的过程中往往是单向完成任务的 此处在递进深入的过程中 my...函数一直都没有+1! 直到回归向上时才开始+0 +1..
//	}
//	else
//	{
//		return 0;//注意！这里的返回0 并不是整个函数的返回值 而是递归每一层加减值的区别 思路是 用1+my...再1+1+my...直到首元素为'\0'
//	}
//}
//int main()
//{
//	char arr[] = "abc";
//	printf("%d\n", my_strlen(arr));
//	return 0;
//}
//这就满足了不创建临时变量的条件

//递归与迭代...
//迭代就是重复 循环就是一种迭代  来看看两者区别
//还是欲求 n的阶乘
//int ite(int m)//迭代的英文描述 iteration
//{
//	int i = 0;
//	int j = 1;//j用于存放阶乘值
//	for (i = 1; i <= m; i++)
//	{
//		j = j * i;
//	}
//	return j;//j初始化为1 这很重要 因为要包含 m=0时阶乘要返回1
//	//这里和递归一样 采用数学思维 将阶乘看作 i<=1;i>2两部分 只不过这里的for循环能将两者都包含其中
//}

//int rec(int n)//recursive function是递归函数的英文 这里取rec为递归函数的代表
//{
//	if (n <= 1)
//	{
//		return 1;
//	}
//	else
//	{
//		return n * rec(n - 1);
//	}
//}
//int main()
//{
//	int n = 0;
//	scanf("%d", &n);
//	//int ret = rec(n);
//	int ret = ite(n);
//	printf("%d\n", ret);
//	return 0;
//}//在这种情况下 似乎递归更加地小巧实用 但是也并不是所有情况都如此！

//求斐波那契数列输入为n的值 不考虑溢出
//斐波那契数列：1 1 2 3 5 8 13 21 44
//即 当n>2时 n=(n-1)+(n-2);
//用递归来描述依然思路简洁：
//int rec(int i)
//{
//	if (i > 2)
//	{
//		return rec(i - 1) + rec(i - 2);//但是这里却出现了问题 当输入n=50时 程序计算了很长时间 以至于半天加载不出来 这是为什么?
//		//当存在多递归模型时 函数很容易存在大量重复的计算量
//		//此处双递归 当输入 n=50时 对应：
//		//return rec(49)+rec(48)... 49+48 48+47... 48+47 47+46 47+46 46+45... 以此类推 越到递进深处 重复的计算量越大(千万级以上)
//	}
//	else
//	{
//		return 1;
//	}
//}

//对应迭代写法则不会如此复杂地计算 但是代码量也随之增加了
//int ite(int n)
//{
//	/*int a = 1;
//	int b = 1;
//	int c = 0;
//	if (n>2)
//	{
//		for (int i = 3; i <= n; i++)
//		{
//		c = a + b;
//		a = b;
//		b = c;
//		}
//		return c;
//	}
//	return 1;*/
//	//或者 while: --类
//	int a = 1;
//	int b = 1;
//	int c = 1;//c赋值为1是为了将n=0，1时包含其中---直接返回c=1即可
//	while (n >= 3)
//	{
//		c = a + b;
//		a = b;
//		b = c;
//		n--;
//	}
//	return c;
//}
//int main()
//{
//	int n = 0;
//	scanf("%d", &n);
//	//int ret = rec(n);
//	int ret = ite(n);
//	printf("%d\n", ret);
//	return 0;
//}

//由此引出一个问题 何时采用递归 何时又采用迭代？
//当可能要调用多递归模型时 请谨慎使用递归函数以避免大量重复计算;
//很多时候我们只是运用递归的思路来解释问题 以使思路更清晰 但是这些问题的迭代实现往往效率更高 只是可读性稍差
//当一个问题相当复杂 难以用迭代实现时 此时递归实现的简洁性可以来弥补它运行时产生的开销
//但其实 哪怕不进入死递归 递归函数仍然可能导致栈溢出！ 如何解决？
//1_简单粗暴 尽量使用非递归函数替换递归函数
//2_使用static对象替代局部变量 
//这不仅可以减少每次递进和返回时产生局部变量对栈区的消耗 而且静态常量还可以保存递归调用的中间状态 便利地为各个调用层所访问


